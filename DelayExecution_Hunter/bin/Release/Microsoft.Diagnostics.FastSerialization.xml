<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Diagnostics.FastSerialization</name>
    </assembly>
    <members>
        <member name="T:FastSerialization.StreamLabel">
            <summary>
            A StreamLabel represents a position in a IStreamReader or IStreamWriter.
            In memory it is represented as a 64 bit signed value but to preserve compat 
            with the FastSerializer.1 format it is a 32 bit unsigned value when
            serialized in a file. FastSerializer can parse files exceeding 32 bit sizes
            as long as the format doesn't persist a StreamLabel in the content. NetTrace 
            is an example of this.
            During writing it is generated by the IStreamWriter.GetLabel method an
            consumed by the IStreamWriter.WriteLabel method. On reading you can use
            IStreamReader.Current and and IStreamReader. 
            </summary>
        </member>
        <member name="F:FastSerialization.StreamLabel.Invalid">
            <summary>
            Represents a stream label that is not a valid value
            </summary>
        </member>
        <member name="T:FastSerialization.IStreamWriter">
            <summary>
            IStreamWriter is meant to be a very simple streaming protocol. You can write integral types,
            strings, and labels to the stream itself.  
            
            IStreamWrite can be thought of a simplified System.IO.BinaryWriter, or maybe the writer
            part of a System.IO.Stream with a few helpers for primitive types.
            
            See also IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.Write(System.Byte)">
            <summary>
            Write a byte to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.Write(System.Int16)">
            <summary>
            Write a short to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.Write(System.Int32)">
            <summary>
            Write an int to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.Write(System.Int64)">
            <summary>
            Write a long to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.Write(FastSerialization.StreamLabel)">
            <summary>
            Write a StreamLabel (a pointer to another part of the stream) to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.Write(System.String)">
            <summary>
            Write a string to a stream (supports null values).  
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriter.GetLabel">
            <summary>
            Get the stream label for the current position (points at whatever is written next
            </summary>
            <returns></returns>
        </member>
        <member name="M:FastSerialization.IStreamWriter.WriteSuffixLabel(FastSerialization.StreamLabel)">
            <summary>
            Write a SuffixLabel it must be the last thing written to the stream.   The stream 
            guarantees that this value can be efficiently read at any time (probably by seeking
            back from the end of the stream)).   The idea is that when you generate a 'tableOfContents'
            you can only do this after processing the data (and probably writing it out), If you
            remember where you write this table of contents and then write a suffix label to it
            as the last thing in the stream using this API, you guarantee that the reader can 
            efficiently seek to the end, read the value, and then goto that position.  (See
            IStreamReader.GotoSuffixLabel for more)
            </summary>
        </member>
        <member name="T:FastSerialization.IStreamReader">
            IStreamReader is meant to be a very simple streaming protocol. You can read integral types,
            strings, and labels to the stream itself.  You can also goto labels you have read from the stream. 
            
            IStreamReader can be thought of a simplified System.IO.BinaryReder, or maybe the reader
            part of a System.IO.Stream with a few helpers for primitive types.
            
            See also IStreamWriter
        </member>
        <member name="M:FastSerialization.IStreamReader.ReadByte">
            <summary>
            Read a byte from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.ReadInt16">
            <summary>
            Read a short from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.ReadInt32">
            <summary>
            Read an int from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.ReadInt64">
            <summary>
            Read a long from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.ReadString">
            <summary>
            Read a string from the stream.   Can represent null strings 
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a span of bytes from the stream.
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.ReadLabel">
            <summary>
            Read a StreamLabel (pointer to some other part of the stream) from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.Goto(FastSerialization.StreamLabel)">
            <summary>
            Goto a location in the stream
            </summary>
        </member>
        <member name="P:FastSerialization.IStreamReader.Current">
            <summary>
            Returns the current position in the stream.  
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamReader.GotoSuffixLabel">
            <summary>
            Sometimes information is only known after writing the entire stream.  This information can be put
            on the end of the stream, but there needs to be a way of finding it relative to the end, rather
            than from the beginning.   A IStreamReader, however, does not actually let you go 'backwards' easily
            because it does not guarantee the size what it writes out (it might compress).  
            
            The solution is the concept of a 'suffixLabel' which is location in the stream where you can always 
            efficiently get to.
            
            It is written with a special API (WriteSuffixLabel that must be the last thing written.   It is 
            expected that it simply write an uncompressed StreamLabel.   It can then be used by using the
            GotoSTreamLabel() method below.   This goes to this well know position in the stream.   We expect
            this is implemented by seeking to the end of the stream, reading the uncompressed streamLabel, 
            and then seeking to that position.  
            </summary>
        </member>
        <member name="T:FastSerialization.IStreamWriterExentions">
            <summary>
            Support for higher level operations on IStreamWriter and IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriterExentions.Write(FastSerialization.IStreamWriter,System.Guid)">
            <summary>
            Writes a Guid to stream 'writer' as sequence of 8 bytes
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriterExentions.ReadGuid(FastSerialization.IStreamReader)">
            <summary>
            Reads a Guid to stream 'reader' as sequence of 8 bytes and returns it
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriterExentions.Add(FastSerialization.StreamLabel,System.Int32)">
            <summary>
            Returns a StreamLabel that is the sum of label + offset.  
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriterExentions.Sub(FastSerialization.StreamLabel,FastSerialization.StreamLabel)">
            <summary>
            Returns the difference between two stream labels 
            </summary>
        </member>
        <member name="M:FastSerialization.IStreamWriterExentions.Skip(FastSerialization.IStreamReader,System.Int32)">
            <summary>
            Convenience method for skipping a a certain number of bytes in the stream.  
            </summary>
        </member>
        <member name="T:FastSerialization.ForwardReference">
            <summary>
            Like a StreamLabel, a ForwardReference represents a pointer to a location in the stream.  
            However unlike a StreamLabel, the exact value in the stream does not need to be known at the
            time the forward references is written.  Instead the ID is written, and later that ID is 
            associated with the target location (using DefineForwardReference).   
            </summary>
        </member>
        <member name="F:FastSerialization.ForwardReference.Invalid">
            <summary>
            Returned when no appropriate ForwardReference exists.  
            </summary>
        </member>
        <member name="T:FastSerialization.Serializer">
            <summary>
            #SerializerIntroduction see also #StreamLayout
            
            The Serializer class is a general purpose object graph serializer helper. While it does not have
            any knowledge of the serialization format of individual object, it does impose conventions on how to
            serialize support information like the header (which holds versioning information), a trailer (which
            holds deferred pointer information), and how types are versioned. However these conventions are
            intended to be very generic and thus this class can be used for essentially any serialization need.
            
            Goals:
                * Allows full range of serialization, including subclassing and cyclic object graphs.
                * Can be serialized and deserialized efficiently sequentially (no seeks MANDATED on read or
                    write). This allows the serializer to be used over pipes and other non-seekable devices).
                * Pay for play (thus very efficient in simple cases (no subclassing or cyclic graphs).
                * Ideally self-describing, and debuggable (output as XML if desired?)
            
            Versioning:
                * We want the ability for new formats to accept old versions if objects wish to support old
                    formats
                * Also wish to allow new formats to be read by OLD version if the new format is just an
                    'extension' (data added to end of objects). This makes making new versions almost pain-free.
                    
            Concepts:
                * No-seek requirement
                
                    The serialized form should be such that it can be deserialized efficiently in a serial fashion
                    (no seeks). This means all information needed to deserialize has to be 'just in time' (can't
                    be some table at the end). Pragmatically this means that type information (needed to create
                    instances), has to be output on first use, so it is available for the deserializer.
                    
                * Laziness requirement
                
                    While is should be possible to read the serialized for sequentially, we should also not force
                    it. It should be possible to have a large file that represents a persisted structure that can
                    be lazily brought into memory on demand. This means that all information needed to
                    deserialize must also be 'randomly available' and not depend on reading from the beginning.
                    Pragmatically this means that type information, and forward forwardReference information needs to
                    have a table in a well known Location at the end so that it can be found without having to
                    search the file sequentially.
                
                * Versioning requirement
                    
                    To allow OLD code to access NEW formats, it must be the case that the serialized form of
                    every instance knows how to 'skip' past any new data (even if it does not know its exact
                    size). To support this, objects have 'begin' and 'end' tags, which allows the deserializer to
                    skip the next object.
                    
                * Polymorphism requirement
                
                    Because the user of a filed may not know the exact instance stored there, in general objects
                    need to store the exact type of the instance. Thus they need to store a type identifier, this
                    can be folded into the 'begin' tag.
                    
                * Arbitrary object graph (circularity) requirement (Forward references)
                
                    The serializer needs to be able to serialize arbitrary object graphs, including those with
                    cycles in them. While you can do this without forward references, the system is more flexible
                    if it has the concept of a forward reference. Thus whenever a object reference is required, a
                    'forward forwardReference' can be given instead. What gets serialized is simply an unique forward
                    reference index (index into an array), and at some later time that index is given its true
                    value. This can either happen with the target object is serialized (see
                    Serializer.Tags.ForwardDefintion) or at the end of the serialization in a forward
                    reference table (which allows forward references to be resolved without scanning then entire
                    file.
                    
                * Contract between objects IFastSerializable.ToStream:
                
                    The heart of the serialization and deserialization process the IFastSerializable
                    interface, which implements just two methods: ToStream (for serializing an object), and
                    FromStream (for deserializing and object). This interfaces is the mechanism by which objects
                    tell the serializer what data to store for an individual instance. However this core is not
                    enough. An object that implements IFastSerializable must also implement a default
                    constructor (constructor with no args), so that that deserializer can create the object (and
                    then call FromStream to populated it).
                    
                    The ToStream method is only responsible for serializing the data in the object, and by itself
                    is not sufficient to serialize an interconnected, polymorphic graph of objects. It needs
                    help from the Serializer and Deserialize to do this. Serializer takes on the
                    responsibility to deal with persisting type information (so that Deserialize can create
                    the correct type before IFastSerializable.FromStream is called). It is also the
                    serializer's responsibility to provide the mechanism for dealing with circular object graphs
                    and forward references.
                
                * Layout of a serialized object: A serialized object has the following basic format
                
                    * If the object is the definition of a previous forward references, then the definition must
                        begin with a Serializer.Tags.ForwardDefintion tag followed by a forward forwardReference
                        index which is being defined.
                    * Serializer.Tags.BeginObject tag
                    * A reference to the SerializationType for the object. This reference CANNOT be a
                        forward forwardReference because its value is needed during the deserialization process before
                        forward references are resolved.
                    * All the data that that objects 'IFastSerializable.ToStream method wrote. This is the
                        heart of the deserialized data, and the object itself has a lot of control over this
                        format.
                    * Serializer.Tags.EndObject tag. This marks the end of the object. It quickly finds bugs
                        in ToStream FromStream mismatches, and also allows for V1 deserializers to skip past
                        additional fields added since V1.
                    
                * Serializing Object references:
                  When an object forwardReference is serialized, any of the following may follow in the stream
                  
                    * Serializer.Tags.NullReference used to encode a null object forwardReference.
                    * Serializer.Tags.BeginObject or Serializer.Tags.ForwardDefintion, which indicates
                        that this the first time the target object has been referenced, and the target is being
                        serialized on the spot.
                    * Serializer.Tags.ObjectReference which indicates that the target object has already
                        been serialized and what follows is the StreamLabel of where the definition is.
                    * Serializer.Tags.ForwardReference followed by a new forward forwardReference index. This
                        indicates that the object is not yet serialized, but the serializer has chosen not to
                        immediately serialize the object. Ultimately this object will be defined, but has not
                        happened yet.
                       
                * Serializing Types:
                  Types are simply objects of type SerializationType which contain enough information about
                  the type for the Deserializer to do its work (it full name and version number).   They are
                  serialized just like all other types.  The only thing special about it is that references to
                  types after the BeginObject tag must not be forward references.  
             
            #StreamLayout:
                The structure of the file as a whole is simply a list of objects.  The first and last objects in
                the file are part of the serialization infrastructure.  
                
            Layout Synopsis
                * Signature representing Serializer format
                * EntryObject (most of the rest of the file)
                    * BeginObject tag
                    * Type for This object (which is a object of type SerializationType)
                        * BeginObject tag
                        * Type for SerializationType  POSITION1
                            * BeginObject tag
                            * Type for SerializationType
                                 * ObjectReference tag           // This is how our recursion ends.  
                                 * StreamLabel for POSITION1
                            * Version Field for SerializationType
                            * Minimum Version Field for SerializationType
                            * FullName string for SerializationType                
                            * EndObject tag
                        * Version field for EntryObject's type
                        * Minimum Version field for EntryObject's type
                        * FullName string for EntryObject's type
                        * EndObject tag
                    * Field1  
                    * Field2 
                    * V2_Field (this should be tagged so that it can be skipped by V1 deserializers.  
                    * EndObject tag
                * ForwardReferenceTable pseudo-object
                    * Count of forward references
                    * StreamLabel for forward ref 0
                    * StreamLabel for forward ref 1.
                    * ...
                * SerializationTrailer pseudo-object
                    * StreamLabel ForwardReferenceTable
                * StreamLabel to SerializationTrailer
                * End of stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.#ctor(System.String,FastSerialization.IFastSerializable)">
            <summary>
            Create a serializer writes 'entryObject' to a file.  
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.#ctor(System.IO.Stream,FastSerialization.IFastSerializable)">
            <summary>
            Create a serializer that writes <paramref name="entryObject"/> to a <see cref="T:System.IO.Stream"/>. The serializer
            will close the stream when it closes.
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.#ctor(System.IO.Stream,FastSerialization.IFastSerializable,System.Boolean)">
            <summary>
            Create a serializer that writes <paramref name="entryObject"/> to a <see cref="T:System.IO.Stream"/>. The
            <paramref name="leaveOpen"/> parameter determines whether the serializer will close the stream when it
            closes.
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.#ctor(FastSerialization.IStreamWriter,FastSerialization.IFastSerializable)">
            <summary>
            Create a serializer that writes 'entryObject' another IStreamWriter 
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Boolean)">
            <summary>
            Write a bool to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Byte)">
            <summary>
            Write a byte to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Int16)">
            <summary>
            Write a short to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Int32)">
            <summary>
            Write an int to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Int64)">
            <summary>
            Write a long to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Guid)">
            <summary>
            Write a Guid to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.String)">
            <summary>
            Write a string to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Single)">
            <summary>
            Write a float to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(System.Double)">
            <summary>
            Write a double to a stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(FastSerialization.StreamLabel)">
            <summary>
            Write a StreamLabel (pointer to some other part of the stream whose location is current known) to the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(FastSerialization.ForwardReference)">
            <summary>
            Write a ForwardReference (pointer to some other part of the stream that whose location is not currently known) to the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Write(FastSerialization.IFastSerializable)">
            <summary>
            If the object is potentially aliased (multiple references to it), you should write it with this method.
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteDefered(FastSerialization.IFastSerializable)">
            <summary>
            To tune working set (or disk seeks), or to make the dump of the format more readable, it is
            valuable to have control over which of several references to an object will actually cause it to
            be serialized (by default the first encountered does it).
            
            WriteDefered allows you to write just a forwardReference to an object with the expectation that
            somewhere later in the serialization process the object will be serialized. If no call to
            WriteObject() occurs, then the object is serialized automatically before the stream is closed
            (thus dangling references are impossible).        
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WritePrivate(FastSerialization.IFastSerializable)">
            <summary>
            This is an optimized version of WriteObjectReference that can be used in some cases.
            
            If the object is not aliased (it has an 'owner' and only that owner has references to it (which
            implies its lifetime is strictly less than its owners), then the serialization system does not
            need to put the object in the 'interning' table. This saves a space (entries in the intern table
            as well as 'SyncEntry' overhead of creating hash codes for object) as well as time (to create
            that bookkeeping) for each object that is treated as private (which can add up if because it is
            common that many objects are private).  The private instances are also marked in the serialized
            format so on reading there is a similar bookkeeping savings. 
            
            The ultimate bits written by WritePrivateObject are the same as WriteObject.
            
            TODO Need a DEBUG mode where we detect if others besides the owner reference the object.
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.GetForwardReference">
            <summary>
            Create a ForwardReference.   At some point before the end of the serialization, DefineForwardReference must be called on this value 
            </summary>
            <returns></returns>
        </member>
        <member name="M:FastSerialization.Serializer.DefineForwardReference(FastSerialization.ForwardReference)">
            <summary>
            Define the ForwardReference forwardReference to point at the current write location.  
            </summary>
            <param name="forwardReference"></param>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(System.Boolean)">
            <summary>
            Write a byte preceded by a tag that indicates its a byte.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(System.Byte)">
            <summary>
            Write a byte preceded by a tag that indicates its a byte.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(System.Int16)">
            <summary>
            Write a byte preceded by a tag that indicates its a short.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(System.Int32)">
            <summary>
            Write a byte preceded by a tag that indicates its a int.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(System.Int64)">
            <summary>
            Write a byte preceded by a tag that indicates its a long.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(System.String)">
            <summary>
            Write a byte preceded by a tag that indicates its a string.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTagged(FastSerialization.IFastSerializable)">
            <summary>
            Write a byte preceded by a tag that indicates its a object.  These should be read with the corresponding TryReadTagged operation
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTaggedBlobHeader(System.Int32)">
            <summary>
            Writes the header for a skipping an arbitrary blob.   THus it writes a Blob
            tag and the size, and the caller must then write 'sizes' bytes of data in 
            some way.   This allows you to create regions of arbitrary size that can
            be skipped by old as well as new parsers.  
            </summary>
            <param name="size"></param>
        </member>
        <member name="M:FastSerialization.Serializer.WriteTaggedEnd">
            <summary>
            Writes an end tag (which is different from all others).   This is useful 
            when you have a deferred region of tagged items.  
            </summary>
        </member>
        <member name="P:FastSerialization.Serializer.Writer">
            <summary>
            Retrieve the underlying stream we are writing to.  Generally the Write* methods are enough. 
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Close">
            <summary>
            Completes the writing of the stream. 
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Log(System.String)">
            <summary>
            To help debug any serialization issues, you can write data to a side file called 'log.serialize.xml'
            which can track exactly what serialization operations occurred.  
            </summary>
        </member>
        <member name="M:FastSerialization.Serializer.Dispose">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="T:FastSerialization.Deserializer">
            <summary>
            Deserializer is a helper class that holds all the information needed to deserialize an object
            graph as a whole (things like the table of objects already deserialized, and the list of types in
            the object graph.  
            
            see #SerializerIntroduction for more
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.#ctor(System.String)">
            <summary>
            Create a Deserializer that reads its data from a given file
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.#ctor(System.IO.Stream,System.String)">
            <summary>
            Create a Deserializer that reads its data from a given System.IO.Stream.   The stream will be closed when the Deserializer is done with it.  
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.#ctor(System.IO.Stream,System.String,System.Boolean)">
            <summary>
            Create a Deserializer that reads its data from a given System.IO.Stream. The
            <paramref name="leaveOpen"/> parameter determines whether the deserializer will close the stream when it
            closes.
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.#ctor(FastSerialization.IStreamReader,System.String)">
            <summary>
            Create a Deserializer that reads its data from a given IStreamReader.   The stream will be closed when the Deserializer is done with it.  
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.GetEntryTypeName">
            <summary>
            Returns the full name of the type of the entry object without actually creating it.
            Will return null on failure.  
            </summary>  
        </member>
        <member name="M:FastSerialization.Deserializer.GetEntryObject``1(``0@)">
            <summary>
            GetEntryObject is the main deserialization entry point.  The serialization stream always has an object that represents the stream as
            a whole, called the entry object and this returns it and places it in 'ret'
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.GetEntryObject">
            <summary>
            GetEntryObject is the main deserialization entry point.  The serialization stream always has an object that represents the stream as
            a whole, called the entry object and this returns it and returns it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Boolean@)">
            <summary>
            Read a bool from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Byte@)">
            <summary>
            Read a byte from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Int16@)">
            <summary>
            Read a short from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Int32@)">
            <summary>
            Read an int from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Int64@)">
            <summary>
            Read a long from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Guid@)">
            <summary>
            Read a Guid from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Single@)">
            <summary>
            Read a float from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.Double@)">
            <summary>
            Read a double from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(System.String@)">
            <summary>
            Read a string from the stream.  Can represent null
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read(FastSerialization.StreamLabel@)">
            <summary>
            d) from the stream
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Read``1(``0@)">
            <summary>
            Read a IFastSerializable object from the stream and place it in ret
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadObject">
            <summary>
            Read a IFastSerializable object from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadBool">
            <summary>
            Read a bool from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadByte">
            <summary>
            Read a byte from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadInt16">
            <summary>
            Read a short from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadInt">
            <summary>
            Read an int from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadInt64">
            <summary>
            Read a long from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadFloat">
            <summary>
            Read a float from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadDouble">
            <summary>
            Read a double from the stream and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadString">
            <summary>
            Read in a string value and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadLabel">
            <summary>
            Read in a StreamLabel (a pointer to some other part of the stream) and return it
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ReadForwardReference">
            <summary>
            Read in a ForwardReference (a pointer to some other part of the stream which was not known at the tie it was written) and return it
            Use ResolveForwardReference to convert the ForwardReference to a StreamLabel
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.ResolveForwardReference(FastSerialization.ForwardReference,System.Boolean)">
            <summary>
            Given a forward reference find the StreamLabel (location in the stream) that it points at).  
            Normally this call preserves the current read location, but if you do don't care you can 
            set preserveCurrent as an optimization to make it more efficient.  
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.VersionBeingRead">
            <summary>
            Meant to be called from FromStream.  It returns the version number of the 
            type being deserialized.   It can be used so that new code can recognizes that it
            is reading an old file format and adjust what it reads.   
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.MinimumReaderVersionBeingRead">
            <summary>
            Meant to be called from FromStream.  It returns the version number of the MinimumReaderVersion
            of the type that was serialized.   
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.Name">
            <summary>
            The filename if read from a file or the stream name if read from a stream
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.TypeResolver">
            <summary>
            If set this function is set, then it is called whenever a type name from the serialization
            data is encountered.  It is your you then need to look that up.  If it is not present 
            it uses Type.GetType(string) which only checks the current assembly and mscorlib. 
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.RegisterFactory(System.Type,System.Func{FastSerialization.IFastSerializable})">
            <summary>
            For every IFastSerializable object being deserialized, the Deserializer needs to create 'empty' objects 
            that 'FromStream' is invoked on.  The Deserializer gets these 'empty' objects by calling a 'factory'
            delegate for that type.   Thus all types being deserialized must have a factory.   
            
            RegisterFactory registers such a factory for particular 'type'.  
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.RegisterDefaultFactory(System.Func{System.Type,FastSerialization.IFastSerializable})">
            <summary>
            For every IFastSerializable object being deserialized, the Deserializer needs to create 'empty' objects 
            that 'FromStream' is invoked on.  The Deserializer gets these 'empty' objects by calling a 'factory'
            delegate for that type.   Thus all types being deserialized must have a factory.   
            
            RegisterDefaultFactory registers a factory that is passed a type parameter and returns a new IFastSerialable object. 
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged(System.Boolean@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged bool, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged(System.Byte@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged byte, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged(System.Int16@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged short, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged(System.Int32@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged int, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged(System.Int64@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged long, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged(System.String@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged string, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTaggedBlobHeader">
            <summary>
            Try to read the header for a tagged blob of bytes.  If Current points at a tagged
            blob it succeeds and returns the size of the blob (the caller must read or skip 
            past it manually) If it is not a tagged blob it returns a size of 0 and resets
            the read pointer to what it was before this method was called.  
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTagged``1(``0@)">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged FastSerializable, return int in ret and return true, otherwise leave the cursor unchanged and return false
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.TryReadTaggedObject">
            <summary>
            Try to read tagged value from the stream.  If it is a tagged FastSerializable, return it, otherwise leave the cursor unchanged and return null
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Goto(FastSerialization.StreamLabel)">
            <summary>
            Set the read position to the given StreamLabel
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Goto(FastSerialization.ForwardReference)">
            <summary>
            Set the read position to the given ForwardReference
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.Current">
            <summary>
            Returns the current read position in the stream. 
            </summary>
        </member>
        <member name="P:FastSerialization.Deserializer.Reader">
            <summary>
            Fetch the underlying IStreamReader that the deserializer reads data from 
            </summary>
        </member>
        <member name="M:FastSerialization.Deserializer.Dispose">
            <summary>
            Close the IStreamReader and free resources associated with the Deserializer
            </summary>
        </member>
        <member name="F:FastSerialization.Deserializer.deferForwardReferences">
            <summary>
            When we encounter a forward reference, we can either go to the forward reference table immediately and resolve it 
            (deferForwardReferences == false), or simply remember that that position needs to be fixed up and continue with
            the deserialization.   This later approach allows 'no seek' deserialization.   This variable which scheme we do. 
            </summary>
        </member>
        <member name="T:FastSerialization.DeferedRegion">
            <summary>
            #DeferedRegionOverview. 
            
            A DeferedRegion help make 'lazy' objects. You will have a DeferedRegion for each block of object you
            wish to independently decide whether to deserialize lazily (typically you have one per object however
            in the limit you can have one per field, it is up to you).
            
            When you call DeferedRegion.Write you give it a delegate that will write all the deferred fields.
            The Write operation will place a forward reference in the stream that skips all the fields written,
            then the fields themselves, then define the forward reference. This allows readers to skip the
            deferred fields.
            
            When you call DeferedRegion.Read  you also give it a delegate that reads all the deferred fields.
            However when 'Read' instead of reading the fields it
            
                * remembers the deserializer, stream position, and reading delegate.
                * it uses the forward reference to skip the region.
                
            When DeferedRegion.FinishRead is called, it first checks if the region was already restored. 
            If not it used the information to read in the deferred region and returns.  Thus this FinishRead
            should be called before any deferred field is used.  
            </summary>
        </member>
        <member name="M:FastSerialization.DeferedRegion.Write(FastSerialization.Serializer,System.Action)">
            <summary>
            see #DeferedRegionOverview.  
            TODO more 
            </summary>
        </member>
        <member name="M:FastSerialization.DeferedRegion.Read(FastSerialization.Deserializer,System.Action)">
            <summary>
            See overview in DeferedRegion class comment.  
            This call indicates that the 'fromStream' delegate  can deserialize a region of the object, which
            was serialized with the DeferedRegion.Write method.   The read skips the data for the region (thus
            no objects associated with the region are created in memory) but the deferred object remembers 
            'fromStream' and will call it when 'FinishRead()' is called. 
            </summary>
        </member>
        <member name="M:FastSerialization.DeferedRegion.FinishRead(System.Boolean)">
            <summary>
            FinishRead indicates that you need to deserialize the lazy region you defined with the 'Read' method.
            If the region has already been deserialized, nothing is done.   Otherwise when you call this
            method the current position in the stream is put back to where it was when Read was called and the
            'fromStream' delegate registered in 'Read' is called to perform the deserialization.    
            </summary>
        </member>
        <member name="P:FastSerialization.DeferedRegion.IsFinished">
            <summary>
            Returns true if the FinsihRead() has already been called. 
            </summary>
        </member>
        <member name="P:FastSerialization.DeferedRegion.Deserializer">
            <summary>
            Get the deserializer associated with this DeferredRegion
            </summary>
        </member>
        <member name="P:FastSerialization.DeferedRegion.StartPosition">
            <summary>
            Get the stream position when Read was called
            </summary>
        </member>
        <member name="M:FastSerialization.DeferedRegion.FinishReadHelper(System.Boolean)">
            <summary>
            This helper is just here to insure that FinishRead gets inlined 
            </summary>
        </member>
        <member name="T:FastSerialization.IFastSerializable">
            <summary>
            A type can opt into being serializable by implementing IFastSerializable and a default constructor
            (constructor that takes not arguments).
            
            Conceptually all clients of IFastSerializable also implement IFastSerializableVersion
            however the serializer will assume a default implementation of IFastSerializableVersion (that
            Returns version 1 and assumes all versions are allowed to deserialize it.  
            </summary>
        </member>
        <member name="M:FastSerialization.IFastSerializable.ToStream(FastSerialization.Serializer)">
            <summary>
            Given a Serializer, write yourself to the output stream. Conceptually this routine is NOT
            responsible for serializing its type information but only its field values. However it is
            conceptually responsible for the full transitive closure of its fields.
            
            * For primitive fields, the choice is easy, simply call Serializer.Write
            * For object fields there is a choice
                * If is is only references by the enclosing object (eg and therefore field's lifetime is
                    identical to referencing object), then the Serialize.WritePrivateObject can be
                    used.  This skips placing the object in the interning table (that insures it is written
                    exactly once).  
                * Otherwise call Serialize.WriteObject
            * For value type fields (or collections of structs), you serialize the component fields.  
            * For collections, typically you serialize an integer inclusiveCountRet followed by each object. 
            </summary>
        </member>
        <member name="M:FastSerialization.IFastSerializable.FromStream(FastSerialization.Deserializer)">
            <summary>
            
            Given a reader, and a 'this' instance, made by calling the default constructor, create a fully
            initialized instance of the object from the reader stream.  The deserializer provides the extra
            state needed to do this for cyclic object graphs.  
            
            Note that it is legal for the instance to cache the deserializer and thus be 'lazy' about when
            the actual deserialization happens (thus large persisted strucuture on the disk might stay on the
            disk).  
            
            Typically the FromStream implementation is an exact mirror of the ToStream implementation, where
            there is a Read() for every Write(). 
            </summary>
        </member>
        <member name="T:FastSerialization.IFastSerializableVersion">
            <summary>
            Objects implement IFastSerializableVersion to indicate what the current version is for writing
            and which readers can read the current version.   If this interface is not implemented a default is
            provided (assuming version 1 for writing and MinimumVersion = 0).  
            
            By default Serializer.WriteObject will place marks when the object ends and always skip to the
            end even if the FromStream did not read all the object data.   This allows considerable versioning
            flexibility.  Simply by placing the new data at the end of the existing serialization, new versions
            of the type can be read by OLD deserializers (new fields will have the value determined by the
            default constructor (typically 0 or null).  This makes is relatively easy to keep MinimumVersion = 0
            (the ideal case).  
            </summary>
        </member>
        <member name="P:FastSerialization.IFastSerializableVersion.Version">
            <summary>
            This is the version number for the serialization CODE (that is the app decoding the format)
            It should be incremented whenever a change is made to IFastSerializable.ToStream and the format 
            is publicly disseminated.  It must not vary from instance to instance.  This is pretty straightforward.   
            It defaults to 0
            </summary>
        </member>
        <member name="P:FastSerialization.IFastSerializableVersion.MinimumVersionCanRead">
             <summary>
             At some point typically you give up allowing new versions of the read to read old wire formats
             This is the Minimum version of the serialized data that this reader can deserialize.   Trying
             to read wire formats strictly smaller (older) than this will fail.   Setting this to the current
             version indicates that you don't care about ever reading data generated with an older version
             of the code.  
             
             If you set this to something other than your current version, you are obligated to insure that
             your FromStream() method can handle all formats >= than this number. 
            
             You can achieve this if you simply use the 'WriteTagged' and 'ReadTagged' APIs in your 'ToStream' 
             and 'FromStream' after your V1 AND you always add new fields to the end of your class.   
             This is the best practice.   Thus  
             
                 void IFastSerializable.ToStream(Serializer serializer)
                 {
                     serializer.Write(Ver_1_Field1);
                     serializer.Write(Ver_1_Field2);
                     // ...
                     serializer.WriteTagged(Ver_2_Field1);   
                     serializer.WriteTagged(Ver_2_Field2);
                     // ...
                     serializer.WriteTagged(Ver_3_Field1);
                 }
             
                 void IFastSerializable.FromStream(Deserializer deserializer)
                 {
                     deserializer.Read(out Ver_1_Field1);
                     deserializer.Read(out Ver_1_Field2);
                     // ...
                     deserializer.TryReadTagged(ref Ver_2_Field1);  // If data no present (old format) then Ver_2_Field1 not set.
                     deserializer.TryReadTagged(ref Ver_2_Field2);  // ditto...
                     // ...
                     deserializer.TryReadTagged(ref Ver_3_Field1);    
                 } 
             
             Tagging outputs a byte tag in addition to the field itself.   If that is a problem you can also use the
             VersionBeingRead to find out what format is being read and write code that explicitly handles it.  
             Note however that this only gets you Backward compatibility (new readers can read the old format, but old readers 
             will still not be able to read the new format), which is why this is not the preferred method.  
             
                 void IFastSerializable.FromStream(Deserializer deserializer)
                 {
                     // We assume that MinVersionCanRead == 4
                     // Deserialize things that are common to all versions (4 and earlier) 
                     
                     if (deserializer.VersionBeingRead >= 5)
                     {
                         deserializer.Read(AVersion5Field);
                         if (deserializer.VersionBeingRead >= 5)
                             deserializer.ReadTagged(AVersion6Field);    
                     }
                 }
             </summary>
        </member>
        <member name="P:FastSerialization.IFastSerializableVersion.MinimumReaderVersion">
            <summary>
            This is the minimum version of a READER that can read this format.   If you don't support forward
            compatibility (old readers reading data generated by new readers) then this should be set to 
            the current version.  
            
            If you set this to something besides the current version you are obligated to insure that your
            ToStream() method ONLY adds fields at the end, AND that all of those added fields use the WriteTagged()
            operations (which tags the data in a way that old readers can skip even if they don't know what it is)
            In addition your FromStream() method must read these with the ReadTagged() deserializer APIs.  
            
            See the comment in front of MinimumVersionCanRead for an example of using the WriteTagged() and ReadTagged() 
            methods. 
            </summary>
        </member>
        <member name="T:FastSerialization.SerializationException">
            <summary>
            Thrown when the deserializer detects an error. 
            </summary>
        </member>
        <member name="M:FastSerialization.SerializationException.#ctor(System.String)">
            <summary>
            Thown when a error occurs in serialization.  
            </summary>
        </member>
        <member name="P:FastSerialization.SerializationType.Version">
            <summary>
            This is the version represents the version of both the reading
            code and the version for the format for this type in serialized form.  
            See IFastSerializableVersion for more.  
            </summary>
        </member>
        <member name="P:FastSerialization.SerializationType.MinimumReaderVersion">
            <summary>
            The version the the smallest (oldest) reader code that can read 
            this file format.  Readers strictly less than this are rejected.  
            This allows support for forward compatbility.   
            See IFastSerializableVersion for more.  
            </summary>
        </member>
        <member name="M:FastSerialization.SegmentedMemoryStreamReader.#ctor(System.Collections.Generic.SegmentedList{System.Byte})">
            <summary>
            Create a IStreamReader (reads binary data) from a given byte buffer
            </summary>
        </member>
        <member name="M:FastSerialization.SegmentedMemoryStreamReader.#ctor(System.Collections.Generic.SegmentedList{System.Byte},System.Int32,System.Int32)">
            <summary>
            Create a IStreamReader (reads binary data) from a given subregion of a byte buffer 
            </summary>
        </member>
        <member name="P:FastSerialization.SegmentedMemoryStreamReader.Length">
            <summary>
            The total length of bytes that this reader can read.  
            </summary>
        </member>
        <member name="M:FastSerialization.SegmentedMemoryStreamReader.ReadByte">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.SegmentedMemoryStreamReader.ReadInt16">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.SegmentedMemoryStreamReader.ReadInt32">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.SegmentedMemoryStreamReader.ReadInt64">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.SegmentedMemoryStreamReader.ReadString">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.SegmentedMemoryStreamReader.ReadLabel">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.SegmentedMemoryStreamReader.Goto(FastSerialization.StreamLabel)">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="P:FastSerialization.SegmentedMemoryStreamReader.Current">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.SegmentedMemoryStreamReader.GotoSuffixLabel">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.SegmentedMemoryStreamReader.Dispose">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="M:FastSerialization.SegmentedMemoryStreamReader.Dispose(System.Boolean)">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="T:FastSerialization.MemoryStreamReader">
            <summary>
            A MemoryStreamReader is an implementation of the IStreamReader interface that works over a given byte[] array.  
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.#ctor(System.Byte[])">
            <summary>
            Create a IStreamReader (reads binary data) from a given byte buffer
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a IStreamReader (reads binary data) from a given subregion of a byte buffer 
            </summary>
        </member>
        <member name="P:FastSerialization.MemoryStreamReader.Length">
            <summary>
            The total length of bytes that this reader can read.
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.ReadByte">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.ReadInt16">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.ReadInt32">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.ReadInt64">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.ReadString">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.ReadLabel">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.Goto(FastSerialization.StreamLabel)">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="P:FastSerialization.MemoryStreamReader.Current">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.GotoSuffixLabel">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.Dispose">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamReader.Dispose(System.Boolean)">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="T:FastSerialization.MemoryStreamWriter">
            <summary>
            A StreamWriter is an implementation of the IStreamWriter interface that generates a byte[] array. 
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.#ctor(System.Int32)">
            <summary>
            Create IStreamWriter that writes its data to an internal byte[] buffer.  It will grow as needed. 
            Call 'GetReader' to get a IStreamReader for the written bytes. 
            
            Call 'GetBytes' call to get the raw array.  Only the first 'Length' bytes are valid
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.GetReader">
            <summary>
            Returns a IStreamReader that will read the written bytes. You cannot write additional bytes to the stream after making this call.
            </summary>
            <returns></returns>
        </member>
        <member name="P:FastSerialization.MemoryStreamWriter.Length">
            <summary>
            The number of bytes written so far.
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.GetBytes">
            <summary>
            The array that holds the serialized data.
            </summary>
            <returns></returns>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Clear">
            <summary>
            Clears any data that was previously written.  
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Write(System.Byte)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Write(System.Int16)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Write(System.Int32)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Write(System.Int64)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Write(FastSerialization.StreamLabel)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Write(System.String)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.GetLabel">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.WriteSuffixLabel(FastSerialization.StreamLabel)">
            <summary>
            Implementation of IStreamWriter
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Dispose">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.Dispose(System.Boolean)">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="M:FastSerialization.MemoryStreamWriter.MakeSpace">
            <summary>
            Makespace makes at least sizeof(long) bytes available (or throws OutOfMemory)
            </summary>
        </member>
        <member name="T:FastSerialization.IOStreamStreamReader">
            <summary>
            A IOStreamStreamReader hooks a MemoryStreamReader up to an input System.IO.Stream.  
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamReader.#ctor(System.String)">
            <summary>
            Create a new IOStreamStreamReader from the given file.  
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:FastSerialization.IOStreamStreamReader.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
            <summary>
            Create a new IOStreamStreamReader from the given System.IO.Stream.   Optionally you can specify the size of the read buffer
            The stream will be closed by the IOStreamStreamReader when it is closed.  
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamReader.Close">
            <summary>
            close the file or underlying stream and clean up 
            </summary>
        </member>
        <member name="P:FastSerialization.IOStreamStreamReader.Current">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamReader.Goto(FastSerialization.StreamLabel)">
            <summary>
            Implementation of IStreamReader
            </summary>
        </member>
        <member name="P:FastSerialization.IOStreamStreamReader.Length">
            <summary>
            Implementation of MemoryStreamReader
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamReader.Dispose(System.Boolean)">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamReader.Fill(System.Int32)">
            <summary>
            Fill the buffer, making sure at least 'minimum' byte are available to read.  Throw an exception
            if there are not that many bytes.  
            </summary>
            <param name="minimum"></param>
        </member>
        <member name="T:FastSerialization.PinnedStreamReader">
            <summary>
            A PinnedStreamReader is an IOStream reader that will pin its read buffer.
            This allows it it support a 'GetPointer' API efficiently.   The 
            GetPointer API lets you access data from the stream as raw byte 
            blobs without having to copy the data.  
            </summary>
        </member>
        <member name="M:FastSerialization.PinnedStreamReader.#ctor(System.String,System.Int32)">
            <summary>
            Create a new PinnedStreamReader that gets its data from a given file.  You can optionally set the size of the read buffer.  
            </summary>
        </member>
        <member name="M:FastSerialization.PinnedStreamReader.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Create a new PinnedStreamReader that gets its data from a given System.IO.Stream.  You can optionally set the size of the read buffer.  
            The stream will be closed by the PinnedStreamReader when it is closed.  
            </summary>
        </member>
        <member name="M:FastSerialization.PinnedStreamReader.Clone">
            <summary>
            Clone the PinnnedStreamReader so that it reads from the same stream as this one.   They will share the same
            System.IO.Stream, but each will lock and seek when accessing that stream so they can both safely share it.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:FastSerialization.PinnedStreamReader.GetPointer(FastSerialization.StreamLabel,System.Int32)">
            <summary>
            Get a byte* pointer to the input buffer at 'Position' in the IReadStream that is at least 'length' bytes long.  
            (thus ptr to ptr+len is valid).   Note that length cannot be larger than the buffer size passed to the reader
            when it was constructed.  
            </summary>
        </member>
        <member name="M:FastSerialization.PinnedStreamReader.GetPointer(System.Int32)">
            <summary>
            Get a byte* pointer to the input buffer at the current read position is at least 'length' bytes long.  
            (thus ptr to ptr+len is valid).   Note that length cannot be larger than the buffer size passed to the reader
            when it was constructed.  
            </summary>
        </member>
        <member name="T:FastSerialization.IOStreamStreamWriter">
            <summary>
            A IOStreamStreamWriter hooks a MemoryStreamWriter up to an output System.IO.Stream
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.#ctor(System.String)">
            <summary>
            Create a IOStreamStreamWriter that writes its data to a given file that it creates
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.#ctor(System.IO.Stream,System.Int32,System.Boolean)">
            <summary>
            Create a IOStreamStreamWriter that writes its data to a System.IO.Stream
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.Flush">
            <summary>
            Flush any written data to the underlying System.IO.Stream
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.Close">
            <summary>
            Insures the bytes in the stream are written to the stream and cleans up resources.  
            </summary>
        </member>
        <member name="P:FastSerialization.IOStreamStreamWriter.RawStream">
            <summary>
            Access the underlying System.IO.Stream.   You should avoid using this if at all possible.  
            </summary>
        </member>
        <member name="P:FastSerialization.IOStreamStreamWriter.Length">
            <summary>
            Implementation of the MemoryStreamWriter interface 
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.GetLabel">
            <summary>
            Implementation of the IStreamWriter interface 
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.Clear">
            <summary>
            Implementation of the MemoryStreamWriter interface 
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.GetReader">
            <summary>
            Implementation of the MemoryStreamWriter interface 
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.GetBytes">
            <summary>
            Implementation of the MemoryStreamWriter interface 
            </summary>
        </member>
        <member name="M:FastSerialization.IOStreamStreamWriter.Dispose(System.Boolean)">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="T:System.Collections.Generic.GrowableArray`1">
            <summary>
            A cheap version of List(T). The idea is to make it as cheap as if you did it 'by hand' using an array and
            an int which represents the logical charCount. It is a struct to avoid an extra pointer dereference, so this
            is really meant to be embedded in other structures.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.#ctor(System.Int32)">
            <summary>
            Create a growable array with the given initial size it will grow as needed.  There is also the
            default constructor that assumes initialSize of 0 (and does not actually allocate the array. 
            </summary>
            <param name="initialSize"></param>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.Item(System.Int32)">
            <summary>
            Fetch the element at the given index.  Will throw an IndexOutOfRange exception otherwise
            </summary>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.Count">
            <summary>
            The number of elements in the array
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Clear">
            <summary>
            Remove all elements in the array. 
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Add(`0)">
            <summary>
            Add an item at the end of the array, growing as necessary. 
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all items 'items' to the end of the array, growing as necessary. 
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Insert(System.Int32,`0)">
            <summary>
            Insert 'item' directly at 'index', shifting all items >= index up.  'index' can be code:Count in
            which case the item is appended to the end.  Larger indexes are not allowed. 
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
            Remove 'count' elements starting at 'index'
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Set(System.Int32,`0)">
            <summary>
            Sets the 'index' element to 'value' growing the array if necessary (filling in default values if necessary).  
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Get(System.Int32)">
            <summary>
            Gets the value at 'index'.   Never fails, will return 'default' if out of range.  
            </summary>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.Empty">
            <summary>
            Returns true if there are no elements in the array. 
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Pop">
            <summary>
            Remove the last element added and return it. Will throw if there are no elements.
            </summary>
            <returns></returns>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.Top">
            <summary>
            Returns the last element added  Will throw if there are no elements. 
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Trim(System.Int32)">
            <summary>
            Trims the size of the array so that no more than 'maxWaste' slots are wasted.   Useful when
            you know that the array has stopped growing.  
            </summary>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.EmptyCapacity">
            <summary>
            Returns true if the Growable array was initialized by the default constructor
            which has no capacity (and thus will cause growth on the first addition).
            This method allows you to lazily set the compacity of your GrowableArray by
            testing if it is of EmtpyCapacity, and if so set it to some useful capacity.
            This avoids unnecessary reallocs to get to a reasonable capacity.   
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.ToString">
            <summary>
            A string representing the array.   Only intended for debugging.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.BinarySearch``1(``0,System.Int32@,System.Func{``0,`0,System.Int32})">
            <summary>
            Sets 'index' to the the smallest index such that all elements with index > 'idx' are > key.  If
            index does not match any elements a new element should always be placed AFTER index.  Note that this
            means that index may be -1 if the new element belongs in the first position.  
            
            Returns true if the return index matched exactly (success)
            
            TODO FIX NOW harmonize with List.BinarySearch
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Sort(System.Int32,System.Int32,System.Comparison{`0})">
            <summary>
            Sort the range starting at 'index' of length 'count' using 'comparision' in assending order
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Sort(System.Comparison{`0})">
            <summary>
            Sort the whole array using 'comparison' in ascending order
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Foreach``1(System.Func{`0,``0})">
            <summary>
            Executes 'func' for each element in the GrowableArray and returns a GrowableArray 
            for the result.  
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.Search``1(``0,System.Int32,System.Func{``0,`0,System.Int32},System.Int32@)">
            <summary>
            Perform a linear search starting at 'startIndex'.  If found return true and the index in 'index'.
            It is legal that 'startIndex' is greater than the charCount, in which case, the search returns false
            immediately.   This allows a nice loop to find all items matching a pattern. 
            </summary>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.UnderlyingArray">
            <summary>
            Returns the underlying array.  Should not be used most of the time!
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.GetEnumerator">
            <summary>
            Implementation of foreach protocol
            </summary>
            <returns></returns>
        </member>
        <member name="T:System.Collections.Generic.GrowableArray`1.GrowableArrayEnumerator">
            <summary>
            Enumerator for foreach interface
            </summary>
        </member>
        <member name="P:System.Collections.Generic.GrowableArray`1.GrowableArrayEnumerator.Current">
            <summary>
            implementation of IEnumerable interface
            </summary>
        </member>
        <member name="M:System.Collections.Generic.GrowableArray`1.GrowableArrayEnumerator.MoveNext">
            <summary>
            implementation of IEnumerable interface
            </summary>
        </member>
        <member name="T:System.Collections.Generic.SegmentedList`1">
            <summary>
            Segmented list implementation, copied from Microsoft.Exchange.Collections.
            </summary>
            <typeparam name="T">The type of the list element.</typeparam>
            <remarks>
            This class implement a list which is allocated in segments, to avoid large lists to go into LOH.
            </remarks>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.#ctor(System.Int32)">
            <summary>
            Constructs SegmentedList.
            </summary>
            <param name="segmentSize">Segment size</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs SegmentedList.
            </summary>
            <param name="segmentSize">Segment size</param>
            <param name="initialCapacity">Initial capacity</param>
        </member>
        <member name="P:System.Collections.Generic.SegmentedList`1.Count">
            <summary>
            Returns the count of elements in the list.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.SegmentedList`1.UnderlyingArray">
            <summary>
            Copy to Array
            </summary>
            <returns>Array copy</returns>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.Pop">
            <summary>
            Returns the last element on the list and removes it from it.
            </summary>
            <returns>The last element that was on the list.</returns>
        </member>
        <member name="P:System.Collections.Generic.SegmentedList`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Returns true if this ICollection is read-only.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.SegmentedList`1.Item(System.Int32)">
            <summary>
            Gets or sets the given element in the list.
            </summary>
            <param name="index">Element index.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.IsValidIndex(System.Int32)">
            <summary>
            Necessary if the list is being used as an array since it creates the segments lazily.
            </summary>
            <param name="index"></param>
            <returns>true if the segment is allocated and false otherwise</returns>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.GetSlot(System.Int32,System.Int32@)">
            <summary>
            Get slot of an element
            </summary>
            <param name="index"></param>
            <param name="slot"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.Add(`0)">
            <summary>
            Adds new element at the end of the list.
            </summary>
            <param name="item">New element.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts new element at the given position in the list.
            </summary>
            <param name="index">Insert position.</param>
            <param name="item">New element to insert.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.RemoveAt(System.Int32)">
            <summary>
            Removes element at the given position in the list.
            </summary>
            <param name="index">Position of the element to remove.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">
            <summary>
            Performs a binary search in a sorted list.
            </summary>
            <param name="item">Element to search for.</param>
            <param name="comparer">Comparer to use.</param>
            <returns>Non-negative position of the element if found, negative binary complement of the position of the next element if not found.</returns>
            <remarks>The implementation was copied from CLR BinarySearch implementation.</remarks>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.BinarySearch(`0,System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Performs a binary search in a sorted list.
            </summary>
            <param name="item">Element to search for.</param>
            <param name="low">The lowest index in which to search.</param>
            <param name="high">The highest index in which to search.</param>
            <param name="comparer">Comparer to use.</param>
            <returns>The index </returns>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.Sort">
            <summary>
            Sorts the list using default comparer for elements.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the list using specified comparer for elements.
            </summary>
            <param name="comparer">Comparer to use.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.AppendFrom(System.Collections.Generic.SegmentedList{`0},System.Int32,System.Int32)">
            <summary>
            Appends a range of elements from anothe list.
            </summary>
            <param name="from">Source list.</param>
            <param name="index">Start index in the source list.</param>
            <param name="count">Count of elements from the source list to append.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.GetEnumerator">
            <summary>
            Returns the enumerator.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.ToArray">
            <summary>
            Copy to Array
            </summary>
            <returns>Array copy</returns>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.CopyTo(`0[],System.Int32)">
            <summary>
            CopyTo copies a collection into an Array, starting at a particular
            index into the array.
            </summary>
            <param name="array">Destination array.</param>
            <param name="arrayIndex">Destination array starting index.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.CopyRangeTo(`0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies the contents of the collection that are within a range into an Array, starting at a particular
            index into the array.
            </summary>
            <param name="array">Destination array.</param>
            <param name="arrayIndex">Destination array starting index.</param>
            <param name="startIndex">The collection index from where the copying should start.</param>
            <param name="endIndex">The collection index where the copying should end.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Returns the enumerator.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns the enumerator.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.System#Collections#Generic#ICollection{T}#Clear">
            <summary>
            Clears the list (removes all elements).
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.System#Collections#Generic#ICollection{T}#Contains(`0)">
            <summary>
            Check if ICollection contains the given element.
            </summary>
            <param name="item">Element to check.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.System#Collections#Generic#ICollection{T}#CopyTo(`0[],System.Int32)">
            <summary>
            CopyTo copies a collection into an Array, starting at a particular
            index into the array.
            </summary>
            <param name="array">Destination array.</param>
            <param name="arrayIndex">Destination array starting index.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <summary>
            Removes the given element from this ICollection.
            </summary>
            <param name="item">Element to remove.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.AddRoomForElement(System.Int32)">
            <summary>
            Shifts the tail of the list to make room for a new inserted element.
            </summary>
            <param name="index">Index of a new inserted element.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.RemoveRoomForElement(System.Int32)">
            <summary>
            Shifts the tail of the list to remove the element.
            </summary>
            <param name="index">Index of the removed element.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.EnsureCapacity(System.Int32)">
            <summary>
            Ensures that we have enough capacity for the given number of elements.
            </summary>
            <param name="minCapacity">Number of elements.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.SwapIfGreaterWithItems(System.Collections.Generic.IComparer{`0},System.Int32,System.Int32)">
            <summary>
            Helper method for QuickSort.
            </summary>
            <param name="comparer">Comparer to use.</param>
            <param name="a">Position of the first element.</param>
            <param name="b">Position of the second element.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.QuickSort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            QuickSort implementation.
            </summary>
            <param name="left">left boundary.</param>
            <param name="right">right boundary.</param>
            <param name="comparer">Comparer to use.</param>
            <remarks>The implementation was copied from CLR QuickSort implementation.</remarks>
        </member>
        <member name="T:System.Collections.Generic.SegmentedList`1.Enumerator">
            <summary>
            Enumerator over the segmented list.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.Enumerator.#ctor(System.Collections.Generic.SegmentedList{`0})">
            <summary>
            Constructws the Enumerator.
            </summary>
            <param name="list">List to enumerate.</param>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.Enumerator.Dispose">
            <summary>
            Disposes the Enumerator.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.Enumerator.MoveNext">
            <summary>
            Moves to the nest element in the list.
            </summary>
            <returns>True if move successful, false if there are no more elements.</returns>
        </member>
        <member name="P:System.Collections.Generic.SegmentedList`1.Enumerator.Current">
            <summary>
            Returns the current element.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.SegmentedList`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            Returns the current element.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SegmentedList`1.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            Resets the enumerator to initial state.
            </summary>
        </member>
    </members>
</doc>
