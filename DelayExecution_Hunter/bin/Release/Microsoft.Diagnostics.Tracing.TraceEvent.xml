<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Diagnostics.Tracing.TraceEvent</name>
    </assembly>
    <members>
        <member name="M:Microsoft.Diagnostics.Tracing.AutomatedAnalysis.StackView.GetTraceEventStackSource(Microsoft.Diagnostics.Tracing.Stacks.StackSource)">
            <summary>
            Unwind the wrapped sources to get to a TraceEventStackSource if possible. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.BPerfEventSource">
            <summary>
            BPerf Trace Log (BTL) are files generated by the CPU Samples Collector tool in https://github.com/Microsoft/BPerf
            The layout of the file is as follows -->
            
            Format:
            4 byte integer describing compressed size
            4 byte integer describing uncompressed size
            byte[compressed size]
            
            The byte array is a list of EVENT_RECORDs. Each Event_RECORD is aligned to 16-bytes.
            
            The EVENT_RECORD is laid out as a memory dump of the structure in memory. All pointers from
            the structure are laid out successively in front of the EVENT_RECORD.
            
            The compression mechanism is using the LZ4 17-Bits Window, 3 Bit Run Length, 4 Bits Match Length.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.BPerfEventSource.#ctor(System.String,Microsoft.Diagnostics.Tracing.TraceEventDispatcherOptions)">
            <summary>
            This constructor is used when the consumer has an offset within the BTL file that it would like to seek to.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.BPerfEventSource.#ctor(System.String,Microsoft.Diagnostics.Tracing.TraceEventDispatcherOptions,System.Byte[],System.Byte[],System.Boolean)">
            <summary>
            This constructor is used when the consumer is supplying the buffers for reasons like buffer pooling.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ActivityComputer">
            <summary>
            An ActivityComputer is a state machine that track information about Activities.  In particular, it can
            compute a activity aware call stack. (GetCallStack).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource,Microsoft.Diagnostics.Symbols.SymbolReader,Microsoft.Diagnostics.Tracing.GCReferenceComputer)">
            <summary>
            Construct a new ActivityComputer that will process events from 'eventLog' and output activity - aware stacks to 'outputStackSource'. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ActivityComputer.Log">
            <summary>
            Returns the TraceLog that is associated with the computer (at construction time)
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.ActivityComputer.Create">
            <summary>
            Fires when an activity is first created (scheduled).   The activity exists, and has an ID, but has not run yet. 
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.ActivityComputer.Start">
            <summary>
            First when an activity starts to run (using a thread).  It fires after the start has logically happened.  
            so you are logically in the started activity.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.ActivityComputer.Stop">
            <summary>
            Fires when the activity ends (no longer using a thread).  It fires just BEFORE the task actually dies 
            (that is you ask the activity of the event being passed to 'Stop' it will still give the passed
            activity as the answer).   The first TraceActivity is the activity that was stopped, the second
            is the activity that exists afer the stop completes.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.ActivityComputer.AfterStop">
            <summary>
            Like OnStop but gets called AFTER the stop has completed (thus the current thread's activity has been updated)
            The activity may be null, which indicates a failure to look up the activity being stopped (and thus the
            thread's activity will be set to null).  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.ActivityComputer.AwaitUnblocks">
            <summary>
            AwaitUnblocks is a specialized form of the 'Start' event that fires when a task starts because
            an AWAIT has ended.   The start event also fires on awaits end and comes AFTER the AwaitUnblocks
            event has been delivered.    
            
            Not every AWAIT end causes a callback.  Because an AWAIT begin happens for every FRAME you only
            want a callback for the FIRST task (activity) created by parent of this activity.  This is what
            this callback does.  
            
            AwaitUnblocks are often treated differently because you want to consider the time between the begin 
            (Activity Created) and awaitUnbock to be accounted for as on the critical path, whereas for 'normal' 
            tasks you normally don't think that time is interesting.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetCurrentActivity(Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Fetches the current activity for 'thread'  at the present time (the current event being dispatched).  
            Never returns null because there is always and activity (it may be the thread task).  
            This is arguably the main thing that this computer keeps track of.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetActivityRepresentingThread(Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Gets the default activity for a thread (the activity a thread is doing when the thread starts).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ActivityComputer.Item(Microsoft.Diagnostics.Tracing.Etlx.ActivityIndex)">
            <summary>
            Maps an activity index back to its activity.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetCallStack(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.TraceEvent,System.Func{Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex},System.Boolean)">
            <summary>
            Returns a activity-aware call stackIndex associated with'ouputStackSource' for the call stack associated with 'data'.
            Such activity-aware call stacks have pseudo-frame every time on thread causes another task to run code (because the  
            creator 'caused' the target code).
            
            If 'topFrames' is non-null, then this function is called with a Thread and is expected to return a CallStack index that
            represents the thread-and-process nodes of the stack.   This allows the returned stack to be have pseudo-frames 
            at the root of the stack.  Typically this is used to represent the 'request' or other 'global' context.   If it is not
            present the thread and process are used to form these nodes.  
            
            This needs to be a function mapping threads to the stack base rather than just the stack base  because in the presence 
            of activities the thread at the 'base' whose 'top' you want may not be the one that 'data' started with, so the caller 
            needs to be prepared to answer the question about any thread.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetCallStackForActivity(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceActivity,System.Func{Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex})">
            <summary>
            Returns a StackSource call stack associated with outputStackSource for the activity 'activity'   (that is the call stack at the 
            the time this activity was first created.   This stack will have it 'top' defined by topFrames (by default just the thread and process frames)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetActivityStack(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceActivity)">
            <summary>
            This is not a call stack but rather the chain of ACTIVITIES (tasks), and can be formed even when call stacks   
            
            Returns a Stack Source stack associated with outputStackSource where each frame is a task starting with 'activity' and
            going back until the activity has no parent (e.g. the Thread's default activity).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ActivityComputer.NoCache">
            <summary>
            If set, we don't assume that the top top frames are an attribute of the TOP THREAD  (if they vary based on
            the current activity, then you can't cache.   Setting this disables caching.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.IsThreadParkedInThreadPool(Microsoft.Diagnostics.Tracing.Etlx.TraceLog,Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Returns true if the call stack is in the thread pool parked (not running user code)  
            This means that the thread CAN'T be running an active activity and we can kill it.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ActivityComputer.CallStackCache">
            <summary>
            This cache remembers Activity * CallStackIndex pairs and the result.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ActivityComputer.CallStackCache.CurrentActivityIndex">
            <summary>
            Remembers the current Activity for 'Get' and 'Put' operations.   Needs to be set before Get or Put is called.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.CallStackCache.Get(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Gets the cache entry for the CurrnetActivityIndex with the call stack 'fromStackIndex'  returns Invalid if
            there is no entry.   
            
            This is not passed the CurrentActivityIndex, so it can implement the CallStackMap interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.CallStackCache.Put(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            updates the cache entry for the CurrnetActivityIndex with the call stack 'fromStackIndex'  with the value 
            'toStackIndex'
            
            This is not passed the CurrentActivityIndex, so it can implement the CallStackMap interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.OnCreated(Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind)">
            <summary>
            Creation handles ANY creation of a task.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.OnStop(Microsoft.Diagnostics.Tracing.TraceEvent,Microsoft.Diagnostics.Tracing.Etlx.TraceActivity,Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Activity can be null, which means we could not figure out the activity we are stopping.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetTPLRawID(Microsoft.Diagnostics.Tracing.TraceEvent,System.Int32,Microsoft.Diagnostics.Tracing.ActivityComputer.IDType)">
            <summary>
            Get a trace wide ID for a TPL event.   TPL tasks might be 'Scheduled' in the sense
            that it might run independently on another thread.  Tasks that do 'BeginWait and 'EndWait'
            are not scheduled.  The same ID might have both operating simultaneously (if you wait
            on a scheduled task).  Thus you need an independent ID for both.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.GetCallStackWithActivityFrames(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.TraceActivity,System.Func{Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex})">
            <summary>
            if 'activity' has not creator (it is top-level), then return baseStack (near execution) followed by 'top' representing the thread-process frames.
            
            otherwise, find the fragment of 'baseStack' up to the point to enters the threadpool (the user code) and splice it to the stack of the creator
            of the activity and return that.  (thus returning your full user-stack).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.TrimETWFrames(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Trims off frames that call ETW logic and return.   If the pattern is not matched, we return  callStackIndex
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.IsRecursiveTask(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            If the stack from 'startStack' (closest to execution) through 'stopStack' is the same as 'baseStack' return a non-invalid frame 
            indicating that it is recursive and should be dropped.  The frame index returned is the name of the task on 'baseStack' that
            begins the recursion (so you can update it if necessary)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.SpliceStack(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Create a stack which is executing at 'startStack' and finds the region until 'stopStack', appending that (in order) to 'baseStack'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.FindThreadPoolTransition(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Returns the point in 'callStackIndex' where the CLR thread pool transitions from 
            a thread pool worker to the work being done by the threadpool.  
            
            Basically we find the closest to execution (furthest from thread-start) call to a 'Run' method
            that shows we are running an independent task.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ActivityComputer.ResolveWellKnownSymbols">
            <summary>
            Used by TrimETWFrames and FindThreadPoolTransition to find particular frame names and place the information in 'm_methodFlags'
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ActivityComputer.m_methodFlags">
            <summary>
            We look for various well known methods inside the Task library.   This array maps method indexes 
            and returns a bitvector of 'kinds' of methods (Run, Schedule, ScheduleHelper).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.GCReferenceID">
            <summary>
            A small number that you can get from the GetReferenceForGCAddress that is
            invariant as the GC address moves around during GCs.   Because this index
            is small it can be used to store information about the GC reference in a
            side growable array.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.GCReferenceID.Dead">
            <summary>
            Indicates that the address is no longer alive.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.GCReferenceComputer">
            <summary>
            This computer will keep track of GC references as they change over time 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.GCReferenceComputer.#ctor(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            Create a new GCRefernece computer from the stream of events 'source'.   When 'source' is processed
            you can call 'GetReferenceForGCAddress' to get stable ids for GC references.  
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.GCReferenceComputer.GetReferenceForGCAddress(System.UInt64)">
            <summary>
            Get a stable ID for a GcAddress.  This ID can be compared for object identity.
            This only works at the current point in time when scanning the source.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.GCReferenceComputer.DisposeGCReference(Microsoft.Diagnostics.Tracing.GCReferenceID)">
            <summary>
            If you no longer need to track the GC reference, call this function to remove the tracking.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer">
            <summary>
            A EventPipeThreadTimeComputer does a simple simulation of what each thread is doing to create stack events that represent 
            CPU, blocked time
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceLog,Microsoft.Diagnostics.Symbols.SymbolReader)">
            <summary>
            Create a new ThreadTimeComputer
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.UseTasks">
            <summary>
            If set we compute thread time using Tasks
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.IncludeEventSourceEvents">
            <summary>
            Track additional info on like EventName or so.
            Default to true to keep backward compatibility.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.GroupByStartStopActivity">
            <summary>
            Use start-stop activities as the grouping construct. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.IgnoreApplicationInsightsRequestsWithRelatedActivityId">
            <summary>
            Reduce nested application insights requests by using related activity id.
            </summary>
            <value></value>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.GenerateThreadTimeStacks(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceEvents)">
            <summary>
            Generate the thread time stacks, outputting to 'stackSource'.  
            </summary>
            <param name="outputStackSource"></param>
            <param name="traceEvents">Optional filtered trace events.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.UpdateThreadToWorkOnStartStopActivity(Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.StartStopActivity,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Updates it so that 'thread' is now working on newStartStop, which can be null which means that it is not working on any 
            start-stop task. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.OnSampledProfile(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            This can actually be called with any event that has a stack.   Basically it will log a CPU sample whose
            size is the time between the last such call and the current one.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.GetCallStack(Microsoft.Diagnostics.Tracing.TraceEvent,Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Get the call stack for 'data'  Note that you thread must be data.Thread().   We pass it just to save the lookup.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.GetTopFramesForActivityComputerCase(Microsoft.Diagnostics.Tracing.TraceEvent,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,System.Boolean)">
            <summary>
            Returns a function that figures out the top (closest to stack root) frames for an event.  Often
            this returns null which means 'use the normal thread-process frames'. 
            Normally this stack is for the current time, but if 'getAtCreationTime' is true, it will compute the
            stack at the time that the current activity was CREATED rather than the current time.  This works 
            better for await time.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.ThreadState">
            <summary>
            Represents all the information that we need to track for each thread.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.m_unknownTimeStartMsec">
            <summary>
            Used to create UNKNOWN frames for start-stop activities.   This is indexed by StartStopActivityIndex.
            and for each start-stop activity indicates when unknown time starts.   However if that activity still
            has known activities associated with it then the number will be negative, and its value is the 
            ref-count of known activities (thus when it falls to 0, it we set it to the start of unknown time. 
            This is indexed by the TOP-MOST start-stop activity.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.m_threadToStartStopActivity">
            <summary>
            maps thread ID to the current TOP-MOST start-stop activity running on that thread.   Used to updated m_unknownTimeStartMsec 
            to figure out when to put in UNKNOWN_ASYNC nodes.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.SampleProfilerThreadTimeComputer.m_startStopActivityToAsyncUnknownSamples">
            <summary>
            Sadly, with AWAIT nodes might come into existence AFTER we would have normally identified 
            a region as having no thread/await working on it.  Thus you have to be able to 'undo' ASYNC_UNKONWN
            nodes.   We solve this by remembering all of our ASYNC_UNKNOWN nodes on a list (basically provisional)
            and only add them when the start-stop activity dies (when we know there can't be another AWAIT.  
            Note that we only care about TOP-MOST activities.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ServerRequestComputer">
            <summary>
            Calculates stacks grouping them by the server request (e.g. ASP.NET) request they are for)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ServerRequestComputer.#ctor(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            Create a new ServerRequest Computer.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ServerRequestComputer.GetCurrentRequest(Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            The server request that we currently processing
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ServerRequest">
            <summary>
            A ServerRequest contains all the information we know about a server request (e.g. ASP.NET request)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ServerRequest.Url">
            <summary>
            Any URL associated with the request
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ServerRequest.ID">
            <summary>
            If the request has a GUID associated with it to uniquely identify it, this is it
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ServerRequest.StartTime">
            <summary>
            The time that the request started (or the earliest that we know about it)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StartStopActivityComputer">
            <summary>
            Calculates start-stop activities (computes duration),  It uses the 'standard' mechanism of using 
            ActivityIDs to corelate the start and stop (and any other events between the start and stop, 
            and use the RelatedActivityID on START events to indicate the creator of the activity, so you can
            form nested start-stop activities.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource,Microsoft.Diagnostics.Tracing.ActivityComputer,System.Boolean)">
            <summary>
            Create a new ServerRequest Computer.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.GetCurrentStartStopActivity(Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            The current start-stop activity on the given thread.   
            If present 'context' is used to look up the current activityID and try to use that to repair missing Starts.  
            Basically if we can't figure out what StartStop activity the thread from just the threadID we can use the activityID 
            from the 'context' event to find it as a backup.     
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.GetStartStopActivityForActivity(Microsoft.Diagnostics.Tracing.Etlx.TraceActivity)">
            <summary>
            Gets the current Start-Stop activity for a given TraceActivity.  
            </summary>
            <param name="curActivity"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.GetCurrentStartStopActivityStack(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,System.Boolean)">
            <summary>
            Returns a stack index representing the nesting of Start-Stop activities for the thread 'curThread' at the current time
            (At this point of the current event for the computer).   The stack starts with a frame for the process of the thread, then 
            has all the start-stop activity frames, then a frame representing 'topThread' which may not be the same as 'thread' since
            'topThread' is the thread that spawned the first task, not the currently executing thread.  
            
            Normally this stack is for the current time, but if 'getAtCreationTime' is true, it will compute the
            stack at the time that the current activity was CREATED rather than the current time.  This works 
            better for await time
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.GetStartStopActivityStack(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.StartStopActivity,Microsoft.Diagnostics.Tracing.Etlx.TraceProcess)">
            <summary>
            Gets a stack that represents the nesting of the Start-Stop tasks.  curActivity can be null, in which case just he process node is returned.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.Start">
            <summary>
            If set, called AFTER a Start-Stop activity starts, called with the activity and the event that caused the start. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.Stop">
            <summary>
            If set, called BEFORE a Start-Stop activity stops, called with the activity and the event that caused the start. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.IsActivityPath(System.Guid,System.Int32)">
            <summary>
            Returns true if 'guid' follow the EventSouce style activity ID for the process with ID processID.  
            You can pass a process ID of 0 to this routine and it will do the best it can, but the possibility
            of error is significantly higher (but still under .1%)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.ActivityPathProcessID(System.Guid)">
            <summary>
            Assuming guid is an Activity Path, extract the process ID from it.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.ActivityPathString(System.Guid)">
            <summary>
            returns a string representation for the activity path.  If the GUID is not an activity path then it returns
            the normal string representation for a GUID.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.DoStopIfNecessary">
            <summary>
            We don't do a stop all processing associated with the stop event is done.  Thus if we are not 'on'
            the stop event, then you can do any deferred processing.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.TryProcessDiagnosticSourceStartEvents(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Try to process some predefined DiagnosticSource ("Microsoft.EntityFrameworkCore.BeforeExecuteCommand" and "Microsoft.AspNetCore.Hosting.BeginRequest") start events.
            This will try to filter the events by "EventName", if failed it will return false without any further processing.
            </summary>
            <returns>Whether or not succeeded in processing the event</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.FixAndProcessWindowsASP(Microsoft.Diagnostics.Tracing.TraceEvent,System.Collections.Generic.KeyValuePair{System.Guid,System.Guid}[])">
            <summary>
            fix ASP.NET receiving events  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.GetActiveStartStopActivityTable(System.Guid,System.Int32)">
            <summary>
            Look up a start-stop activity by its ID.   Note that the 'activityID' needs to be unique for that instance 
            within a process.  (across ALL start-stop activities, which means it may need components that encode its 
            provider and task).   We pass the process ID as well so that it will be unique in the whole trace.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StartStopActivityComputer.NumberListCodes">
            <summary>
            The encoding for a list of numbers used to make Activity  Guids.   Basically
            we operate on nibbles (which are nice because they show up as hex digits).  The
            list is ended with a end nibble (0) and depending on the nibble value (Below)
            the value is either encoded into nibble itself or it can spill over into the
            bytes that follow.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StartStopActivityIndex">
            <summary>
            An dense number that defines the identity of a StartStopActivity.  Used to create side arrays 
            for StartStopActivity info.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.StartStopActivityIndex.Illegal">
            <summary>
            An illegal index, sutable for a sentinal.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StartStopActivity">
            <summary>
            A StartStop reresents an activity between a start and stop event as generated by EvetSource.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.Index">
            <summary>
            The index (small dense numbers suitabilty for array indexing) for this activity. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.Name">
            <summary>
            The name of the activity (The Task name for the start-stop event as well as the activity ID)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.KnownType">
            <summary>
            Known Activity Type
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.ExtraInfo">
            <summary>
            If the activity has additional information associated with it (e.g. a URL), put it here.  Can be null.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.TaskName">
            <summary>
            The Task name (the name prefix that is common to both the start and stop event)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.ProcessID">
            <summary>
            The processID associated with this activity
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.ActivityID">
            <summary>
            The Activity ID (as a GUID) that matches the start and stop together. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.ActivityPathString">
            <summary>
            The path of creators that created this activity.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.Creator">
            <summary>
            The start-stop activity that created this activity (thus it makes a tree)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.StartEventIndex">
            <summary>
            The TraceLog event Index, of the start event (you can get addition info)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.StopEventIndex">
            <summary>
            The TraceLog event Index, of the stop event (you can get addition info)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.StartTimeRelativeMSec">
            <summary>
            The time in MSec from the start of the trace when the start event happened. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.DurationMSec">
            <summary>
            The duration of activity in MSec (diff between stop and start)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StartStopActivity.IsStopped">
            <summary>
            This activity has completed (the Stop event has been received).  Thus Duration is valid.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivity.GetActivityStack(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Returns a stack on the outputStackSource which has a frame for each activity that
            caused this activity, as well as the root of the given 'rootStack' (often a stack representing the process).    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivity.ToString">
            <summary>
            override.   Gives the name and start time.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StartStopActivity.RememberStop(Microsoft.Diagnostics.Tracing.EventIndex,System.Double,Microsoft.Diagnostics.Tracing.Etlx.ActivityIndex)">
            <summary>
            We don't update the state for the stop at the time of the stop, but at the next call to any of the StartStopActivityComputer APIs.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TcpIpComputer">
            <summary>
            A TcpIpComputer keeps track of TCP/IP connections so that you can correlate individual reads and
            writes with the connection info (like the IP address of each end), as well as data packets being
            sent (if you have packet capture turned on).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TcpIpComputer.#ctor(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            Create a new GCRefernece computer from the stream of events 'source'.   When 'source' is processed
            you can call 'GetReferenceForGCAddress' to get stable ids for GC references.  
            </summary>
            <param name="source"></param>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer">
            <summary>
            A ThreadTimeComputer does a simple simulation of what each thread is doing to create stack events that represent 
            CPU, blocked time, disk and Network activity.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceLog,Microsoft.Diagnostics.Symbols.SymbolReader)">
            <summary>
            Create a new ThreadTimeComputer
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.UseTasks">
            <summary>
            If set we compute thread time using Tasks
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.IncludeEventSourceEvents">
            <summary>
            Track additional info on like EventName or so.
            Default to true to keep backward compatibility.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.BlockedTimeOnly">
            <summary>
            If set we compute blocked time 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.ExcludeReadyThread">
            <summary>
            If set we don't show ready thread information 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GroupByAspNetRequest">
            <summary>
            If set we group by ASP.NET Request
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.MiniumReadiedTimeMSec">
            <summary>
            If we spend less then this amount of time waiting for the CPU, don't bother showing it.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GroupByStartStopActivity">
            <summary>
            LIke the GroupByAspNetRequest but use start-stop activities instead of ASP.NET Requests as the grouping construct. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.IgnoreApplicationInsightsRequestsWithRelatedActivityId">
            <summary>
            Reduce nested application insights requests by using related activity id.
            </summary>
            <value></value>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.NoAwaitTime">
            <summary>
            Don't show AwaitTime.  For CPU only traces showing await time is misleading since
            blocked time will not show up.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GenerateThreadTimeStacks(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceEvents)">
            <summary>
            Generate the thread time stacks, outputting to 'stackSource'.  
            </summary>
            <param name="outputStackSource"></param>
            <param name="traceEvents">Optional filtered trace events.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.UpdateThreadToWorkOnStartStopActivity(Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.StartStopActivity,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Updates it so that 'thread' is now working on newStartStop, which can be null which means that it is not working on any 
            start-stop task. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.OnSampledProfile(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            This can actually be called with any event that has a stack.   Basically it will log a CPU sample whose
            size is the time between the last such call and the current one.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GetCallStack(Microsoft.Diagnostics.Tracing.TraceEvent,Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Get the call stack for 'data'  Note that you thread must be data.Thread().   We pass it just to save the lookup.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GetTopFramesForActivityComputerCase(Microsoft.Diagnostics.Tracing.TraceEvent,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,System.Boolean)">
            <summary>
            Returns a function that figures out the top (closest to stack root) frames for an event.  Often
            this returns null which means 'use the normal thread-process frames'. 
            Normally this stack is for the current time, but if 'getAtCreationTime' is true, it will compute the
            stack at the time that the current activity was CREATED rather than the current time.  This works 
            better for await time.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.ThreadState">
            <summary>
            Represents all the information that we need to track for each thread.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GetAspNetGuid(Microsoft.Diagnostics.Tracing.Etlx.TraceActivity)">
            <summary>
            Given and activity, return the ASP.NET Guid associated with it (or Guid.Empty if there is not one). 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GetAspNetFromProcessFrameThroughThreadFrameStack(System.Guid,Microsoft.Diagnostics.Tracing.TraceEvent,Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Computes the ASP.NET Pseudo frames from the process frame through the thread frame (which includes all 
            the pseudo-frames for the ASP.NET groupings. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.TransferAspNetRequestToThread(System.Guid,Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex,System.String)">
            <summary>
            Indicates that the aspNet request represented by aspNetGuid is now being  handled by the thread with index 
            newThreadIndex.  Thus any old threads handling this request are 'cleared' and replaced with 'newThreadIndex'
            If 'newThreadIndex == Invalid then the entry for aspNetGuid is removed.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.GenerateReadyThreadNodes(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,System.Double,System.Int32)">
            <summary>
            Generate a stack that from the root looks like 'stackIndex followed by 'READIED BY TID(XXXX)' 
            followed by frames of 'readyThreadCallStack' (suffixed by READIED_BY)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.NetworkInfo">
            <summary>
             NetworkInfo remembers useful information to tag blocked time that seems to be network related. 
             It is the value of the m_lastPacketForProcess table mapping threads to network information. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.AspNetRequestInfo">
            <summary>
            AspNetRequestInfo remembers everything we care about associate with an single ASP.NET request.  
            It is the value of the m_aspNetRequestInfo table. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.m_unknownTimeStartMsec">
            <summary>
            Used to create UNKNOWN frames for start-stop activities.   This is indexed by StartStopActivityIndex.
            and for each start-stop activity indicates when unknown time starts.   However if that activity still
            has known activities associated with it then the number will be negative, and its value is the 
            ref-count of known activities (thus when it falls to 0, it we set it to the start of unknown time. 
            This is indexed by the TOP-MOST start-stop activity.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.m_threadToStartStopActivity">
            <summary>
            maps thread ID to the current TOP-MOST start-stop activity running on that thread.   Used to updated m_unknownTimeStartMsec 
            to figure out when to put in UNKNOWN_ASYNC nodes.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.m_startStopActivityToAsyncUnknownSamples">
            <summary>
            Sadly, with AWAIT nodes might come into existence AFTER we would have normally identified 
            a region as having no thread/await working on it.  Thus you have to be able to 'undo' ASYNC_UNKONWN
            nodes.   We solve this by remembering all of our ASYNC_UNKNOWN nodes on a list (basically provisional)
            and only add them when the start-stop activity dies (when we know there can't be another AWAIT.  
            Note that we only care about TOP-MOST activities.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.m_IRPToThread">
            <summary>
            m_IRPToThread maps the I/O request to the thread that initiated it.  This way we can associate
            the disk read size and file with the thread that asked for it.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.m_threadIDUsingProc">
            <summary>
            Maps processor number to the OS threadID of the thread that is using it.   Allows you 
            to determine how (CPU) idle the machine is.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ThreadTimeStackComputer.m_numIdleProcs">
            <summary>
            Using m_threadIDUsingProc, we compute how many processor are current doing nothing 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.NewThreadTimeComputer.Log">
            <summary>
            Returns the TraceLog that is associated with the computer (at construction time)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntimeExtensions">
            <summary>
            Extension methods to enable TraceManagedProcess
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime">
            <summary>
            Extension properties for TraceProcess that include necessary .NET values
            
            TODO This implementation is poor at idenitfying the ParentPID, 64bitness, and Start/End times
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime.RuntimeVersion">
            <summary>
            Returns the textual version of the .NET Framework
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime.StartupFlags">
            <summary>
            Returns the .NET startup flags
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime.RuntimeBuiltTime">
            <summary>
            Date and time of when the runtime was built
            This is useful when a more detailed version is not present
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime.GC">
            <summary>
            Garbage Collector (GC) specific details about this process
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime.GCStart">
            <summary>
            Fired on the start of a GC
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime.GCEnd">
            <summary>
            Fired at the end of the GC.  Given the nature of the GC, it is possible that multiple GCs will be inflight at the same time.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime.JIT">
            <summary>
            Just-in-time compilation (JIT) specific details about this process
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime.JITMethodStart">
            <summary>
            Fired when a managed method is starting to compile (jit)
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime.JITMethodEnd">
            <summary>
            Fired when a managed method is done compiling (jitting).  Given the nature of the JIT, it is possible that multiple methods will be compiled at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime.HasAnyKnownOptimizationTier">
            <summary>
            Indicates whether any of the jitted method code versions have a known optimization tier
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime.IsTieredCompilationEnabled">
            <summary>
            Indicates whether tiered compilation is enabled
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime.ToString">
            <summary>
            An XML representation of the TraceEventProcess (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime.SetupCallbacks(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            Gathers relevant details about the processes in the event source
            </summary>
            <param name="source"></param>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.TraceGarbageCollector">
            <summary>
            Garbage Collector (GC) specific details about this process
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.TraceGarbageCollector.Stats">
            <summary>
            Process view of GC statistics
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.TraceGarbageCollector.Generations">
            <summary>
            Process view of GC generational statistics
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceGarbageCollector.GCs">
            <summary>
            Process view of all GCs
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.TraceJitCompiler">
            <summary>
            Just-in-time compilation (JIT) specific details about this process
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.TraceJitCompiler.Stats">
            <summary>
            Process view of JIT statistics
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceJitCompiler.Methods">
            <summary>
            Process view of all methods jitted
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.Number">
            <summary>
            Primary GC information
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.Type">
            <summary>
            Type of the GC, eg. NonConcurrent, Background or Foreground
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.Reason">
            <summary>
            Reason for the GC, eg. exhausted small heap, etc.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.Generation">
            <summary>
            Generation of the heap collected.  If you compare Generation at the start and stop GC events they may differ.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.StartRelativeMSec">
            <summary>
            Time relative to the start of the trace.  Useful for ordering
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.DurationMSec">
            <summary>
            Duration of the GC, excluding the suspension time
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.PauseDurationMSec">
            <summary>
            Duration the EE suspended the process
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.SuspendDurationMSec">
            <summary>
            Time the EE took to suspend all the threads
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.PercentTimeInGC">
            <summary>
            Percentage time the GC took compared to the process lifetime
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.ProcessCpuMSec">
            <summary>
            The number of CPU samples gathered for the lifetime of this process
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GCCpuMSec">
            <summary>
            The number of CPU samples gathered during a GC
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.PerHeapMarkTimes">
            <summary>
            Mark time information per heap.  Key is the heap number
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.DurationSinceLastRestartMSec">
            <summary>
            Time since the last EE restart
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.PauseStartRelativeMSec">
             <summary>
            Realtive time to the trace of when the GC pause began
             </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.IsComplete">
            <summary>
            Marks if the GC is in a completed state
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.ServerGcHeapHistories">
            <summary>
            Server GC histories
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.AllocedSinceLastGCBasedOnAllocTickMB">
            <summary>
            Amount of memory allocated since last GC.  Requires GCAllocationTicks enabled.  The 
            data is split into small and large heaps
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.HeapCount">
            <summary>
            Number of heaps.  -1 is the default
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GetPinnedObjectSizes">
            <summary>
            Calculate the size of all pinned objects
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GetPinnedObjectPercentage">
            <summary>
            Percentage of the pinned objects created by the user
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GetTotalGCTime">
            <summary>
            Total time taken by the GC
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GCGenerationName">
            <summary>
            Friendly GC name including type, reason and generation
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.HeapSizeAfterMB">
            <summary>
            Heap size after GC (mb)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.PromotedMB">
            <summary>
            Amount of memory promoted with GC (mb)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.SurvivalPercent(Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens)">
            <summary>
            Memory survival percentage by generation
            </summary>
            <param name="gen"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GenSizeAfterMB(Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens)">
            <summary>
            Heap size by generation after GC (mb)
            </summary>
            <param name="gen"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GenFragmentationMB(Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens)">
            <summary>
            Heap fragmentation by generation (mb)
            </summary>
            <param name="gen"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GenFragmentationPercent(Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens)">
            <summary>
            Percentage of heap fragmented by generation 
            </summary>
            <param name="gen"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GenInMB(Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens)">
            <summary>
            Amount of memory at the start of the GC by generation (mb)
            </summary>
            <param name="gen"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GenOutMB(Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens)">
            <summary>
            Amount of memory after the gc by generation (mb)
            </summary>
            <param name="gen"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GenPromotedMB(Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens)">
            <summary>
            Memory promoted by generation (mb)
            Note that in 4.0 TotalPromotedSize is not entirely accurate (since it doesn't
            count the pins that got demoted. We could consider using the PerHeap event data
            to compute the accurate promoted size. 
            In 4.5 this is accurate.
            </summary>
            <param name="gen"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GenBudgetMB(Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens)">
            <summary>
            Heap budget by generation (mb)
            </summary>
            <param name="gen"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GenObjSizeAfterMB(Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens)">
            <summary>
            Object size by generation after GC (mb)
            </summary>
            <param name="gen"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GlobalCondemnedReasons">
            <summary>
            Global condemned reasons by GC
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.PerHeapCondemnedReasons">
            <summary>
            Heap condemned reasons by GC
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.FindFirstHighestCondemnedHeap">
            <summary>
            Identify the first and greatest condemned heap
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.IsLowEphemeral">
            <summary>
            Indicates that the GC has low ephemeral space
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.IsNotCompacting">
            <summary>
            Indicates that the GC was not compacting
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GetCondemnedReasons(System.Collections.Generic.Dictionary{Microsoft.Diagnostics.Tracing.Analysis.GC.CondemnedReasonGroup,System.Int32})">
            <summary>
            Returns the condemned reason for this heap
            </summary>
            <param name="ReasonsInfo"></param>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.PerHeapHistories">
            <summary>
            Per heap statistics
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.TotalPinnedPlugSize">
            <summary>
            Sum of the pinned plug sizes
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.TotalUserPinnedPlugSize">
            <summary>
            Sum of the user created pinned plug sizes
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.HeapStats">
            <summary>
            Per heap statstics
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.LOHWaitThreads">
            <summary>
            Large object heap wait threads
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GlobalHeapHistory">
            <summary>
            Process heap statistics
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.FreeList">
            <summary>
            Free list efficiency statistics
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.AllocedSinceLastGCMB">
            <summary>
            Memory allocated since last GC (mb)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.RatioPeakAfter">
            <summary>
            Ratio of heap size before and after
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.AllocRateMBSec">
            <summary>
            Ratio of allocations since last GC over time executed
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.HeapSizePeakMB">
            <summary>
            Peak heap size before GCs (mb)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.UserAllocated">
            <summary>
            Per generation view of user allocated data
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.HeapSizeBeforeMB">
            <summary>
            Heap size before gc (mb)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GenSizeBeforeMB">
            <summary>
            Per generation view of heap sizes before GC (mb)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.PauseTimePercentageSinceLastGC">
            <summary>
            This represents the percentage time spent paused for this GC since the last GC completed. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GetUserAllocated(System.Collections.Generic.List{Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC},Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC,Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens)">
            <summary>
            Get what's allocated into gen0 or gen3. For server GC this gets the total for 
            all heaps.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.GetUserAllocatedPerHeap(System.Collections.Generic.List{Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC},Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC,System.Int32,Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens)">
            <summary>
            For a given heap, get what's allocated into gen0 or gen3.
            We calculate this differently on 4.0, 4.5 Beta and 4.5 RC+.
            The caveat with 4.0 and 4.5 Beta is that when survival rate is 0,
            We don't know how to calculate the allocated - so we just use the
            last GC's budget (We should indicate this in the tool)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.TraceGC.is20Event">
            <summary>
            Legacy properties that need to be refactored and removed
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.GC.CondemnedReasonGroup">
            <summary>
            Condemned reasons are organized into the following groups.
            Each group corresponds to one or more reasons. 
            Groups are organized in the way that they mean something to users. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.GC.BGCAllocWaitInfo">
            <summary>
            Background GC allocation information
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.GC.ThreadWorkSpan">
            <summary>
            Span of thread work recorded by CSwitch or CPU Sample Profile events
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.GC.InducedType">
            <summary>
            Reason for an induced GC
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.GC.EncodedCondemnedReasons">
            <summary>
            CondemnedReason
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.GC.GCCondemnedReasons">
            <summary>
            Heap condemned reason
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCCondemnedReasons.CondemnedReasonGroups">
            <summary>
            This records which reasons are used and the value. Since the biggest value
            we need to record is the generation number a byte is sufficient.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.GC.MarkInfo">
            <summary>
            Container for mark times
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.GC.GCPerHeapHistory">
            <summary>
            Per heap statistics
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.GC.GCGlobalHeapHistory">
            <summary>
            Process heap statistics
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.GC.GCHeapStats">
            <summary>
            Per heap stastics
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.GC.FreeListEfficiency">
             <summary>
             Approximations we do in this function for V4_5 and prior:
             On 4.0 we didn't separate free list from free obj, so we just use fragmentation (which is the sum)
             as an approximation. This makes the efficiency value a bit larger than it actually is.
             We don't actually update in for the older gen - this means we only know the out for the younger 
             gen which isn't necessarily all allocated into the older gen. So we could see cases where the 
             out is > 0, yet the older gen's free list doesn't change. Using the younger gen's out as an 
             approximation makes the efficiency value larger than it actually is.
            
             For V4_6 this requires no approximation.
            
             
             </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats">
            <summary>
            Statistical garbage collector (GC) information about a managed process
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.Count">
            <summary>
            Number of GC's for this process
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.NumInduced">
            <summary>
            Number of GC's which were induced, eg. GC.Collect, etc.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.PinnedObjectSizes">
            <summary>
            Total size of the pinned objects seen at collection time
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.PinnedObjectPercentage">
            <summary>
            Of all the memory that is current pinned, how much of it is from pinned objects
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.NumWithPinEvents">
            <summary>
            Number of GC's that contained pinned objects
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.NumWithPinPlugEvents">
            <summary>
            Number of GC's that contained pin plugs
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.MaxPauseDurationMSec">
            <summary>
            The longest pause duration (ms)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.MeanPauseDurationMSec">
            <summary>
            Avarege pause duration (ms)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.MeanSizeAfterMB">
            <summary>
            Average heap size after a GC (mb)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.MeanSizePeakMB">
            <summary>
            Average peak heap size (mb)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.MeanCpuMSec">
            <summary>
            Average exclusive cpu samples (ms) during GC's
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.TotalPauseTimeMSec">
            <summary>
            Total GC pause time (ms)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.MaxSuspendDurationMSec">
            <summary>
            Max suspend duration (ms), should be very small
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.MaxSizePeakMB">
            <summary>
            Max peak heap size (mb)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.MaxAllocRateMBSec">
            <summary>
            Max allocation per second (mb/sec)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.TotalAllocatedMB">
            <summary>
            Total allocations in the process lifetime (mb)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.TotalCpuMSec">
            <summary>
            Total exclusive cpu samples (ms)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.TotalPromotedMB">
            <summary>
            Total memory promoted between generations (mb)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.TotalSizeAfterMB">
            <summary>
            (obsolete) Total size of heaps after GC'ss (mb)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.TotalSizePeakMB">
            <summary>
            (obsolete) Total peak heap sizes (mb)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.Interesting">
            <summary>
            Indication if this process is interesting from a GC pov
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.FinalizedObjects">
            <summary>
            List of finalizer objects
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.GetGCPauseTimePercentage">
            <summary>
            Percentage of time spent paused as compared to the process lifetime
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.ProcessDuration">
            <summary>
            Running time of the process.  Measured as time spent between first and last GC event observed
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.GCVersionInfoMismatch">
            <summary>
            Means it detected that the ETW information is in a format it does not understand.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.IsServerGCUsed">
            <summary>
            Indicator of if ServerGC is enabled (1).  -1 indicates that not enough events have been processed to know for sure.
            We don't necessarily have the GCSettings event (only fired at the beginning if we attach)
            So we have to detect whether we are running server GC or not.
            Till we get our first GlobalHeapHistory event which indicates whether we use server GC 
            or not this remains -1.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.HeapCount">
            <summary>
            Number of heaps.  -1 indicates that not enough events have been processed to know for sure.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.GC.GCStats.HasDetailedGCInfo">
            <summary>
            Indicator if PerHeapHistories is present
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats">
            <summary>
            Process statistics about JIT'd code
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.Count">
            <summary>
            Number of JITT'd methods
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.TotalCpuTimeMSec">
            <summary>
            Total cpu samples for this process
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.CountForeground">
            <summary>
            Number of methods JITT'd by foreground threads just prior to execution
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.TotalForegroundCpuTimeMSec">
            <summary>
            Total time spent compiling methods on foreground threads
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.CountBackgroundMultiCoreJit">
            <summary>
            Number of methods JITT'd by the multicore JIT background threads
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.TotalBackgroundMultiCoreJitCpuTimeMSec">
            <summary>
            Total time spent compiling methods on background threads for multicore JIT
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.CountBackgroundTieredCompilation">
            <summary>
            Number of methods JITT'd by the tiered compilation background threads
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.TotalBackgroundTieredCompilationCpuTimeMSec">
            <summary>
            Total time spent compiling methods on background threads for tiered compilation
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.TotalILSize">
            <summary>
            Total IL size for all JITT'd methods
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.TotalNativeSize">
            <summary>
            Total native code size for all JITT'd methods
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.TotalHotCodeAllocSize">
            <summary>
            Total hot code size allocated for all JITT'd methods
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.TotalRODataAllocSize">
            <summary>
            Total read-only data size allocated for all JITT'd methods
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.TotalAllocSizeForJitCode">
            <summary>
            Total size allocated for all JITT'd methods
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.IsJitAllocSizePresent">
            <summary>
            If data from alloc size for JIT event present
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.IsClr4">
            <summary>
            Indication if this is running on .NET 4.x+
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.Interesting">
            <summary>
            Indicates if this process has sufficient JIT activity to be interesting
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.BackgroundJitAbortedAtMSec">
            <summary>
            Background JIT: Time Jit was aborted (ms)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.LastAssemblyLoadNameBeforeAbort">
            <summary>
            Background JIT: Assembly name of last assembly loaded before JIT aborted
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.LastAssemblyLoadBeforeAbortMSec">
            <summary>
            Background JIT: Relative start time of last assembly loaded before JIT aborted
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.LastAssemblyLoadBeforeAbortSuccessful">
            <summary>
            Background JIT: Indication if the last assembly load was successful before JIT aborted
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.BackgroundJitThread">
            <summary>
            Background JIT: Thread id of the background JIT
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.BackgroundJITEventsOn">
            <summary>
            Background JIT: Indication that background JIT events are enabled
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.HasAtLeastOneKnownOptimizationTier">
            <summary>
            Indicates whether any of the jitted method code versions in this process have a known optimization tier
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.InliningSuccesses">
            <summary>
            List of successfully inlinded methods
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.InliningFailures">
            <summary>
            List of failed inlined methods
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.RecordedModules">
            <summary>
            Modules encountered while processing managed samples
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.SymbolsMissing">
            <summary>
            List of modules whose symbols were not successfully loaded
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.AddMethodToStatistics(Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod)">
            <summary>
            Aggregate a method to be included in the statistics
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.MethodComplete(Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime,Microsoft.Diagnostics.Tracing.Parsers.Clr.MethodLoadUnloadTraceDataBase,System.String,System.Int32,System.Boolean@)">
            <summary>
            Legacy
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.LogJitMethodAllocation(Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime,Microsoft.Diagnostics.Tracing.Parsers.Clr.MethodJitMemoryAllocatedForCodeTraceData)">
            <summary>
            Handles AllocRequest event for JIT
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.JIT.JITStats.MethodKey">
            <summary>
            Uniquely represents a method within a process.
            Used as a lookup key for data structures.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.JIT.InliningSuccessResult">
            <summary>
            JIT inlining successes
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.JIT.InliningFailureResult">
            <summary>
            JIT inlining failures
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod">
            <summary>
            Per method information
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.CompileCpuTimeMSec">
            <summary>
            Time taken to compile the method
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.ILSize">
            <summary>
            IL size of method
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.NativeSize">
            <summary>
            Native code size of method
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.JitHotCodeRequestSize">
            <summary>
            Hot code size allocated for JIT code of method
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.JitRODataRequestSize">
            <summary>
            Read-only data size allocated for JIT code of method
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.AllocatedSizeForJitCode">
            <summary>
            Total size allocated for JIT code of method
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.JitAllocFlag">
            <summary>
            Jit allocation flag
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.StartTimeMSec">
            <summary>
            Relative start time of JIT'd method
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.MethodName">
            <summary>
            Method name
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.ModuleILPath">
            <summary>
            Module name
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.ThreadID">
            <summary>
            Thread id where JIT'd
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.IsBackground">
            <summary>
            Indication of if it was JIT'd in the background
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.CompilationThreadKind">
            <summary>
            Indication of if it was JIT'd in the background and why
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.DistanceAhead">
            <summary>
            Amount of time the method was forcasted to JIT
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.BlockedReason">
            <summary>
            Indication of if the background JIT request was blocked and why
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.RunCpuTimeMSec">
            <summary>
            Number of cpu samples for this method
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.OptimizationTier">
            <summary>
            The optimization tier at which the method was jitted
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.VersionID">
            <summary>
            The version id that is created by the runtime code versioning feature. This is an incrementing counter that starts at 0 for each method.
            The ETW events historically name this as the ReJITID event parameter in the payload, but we have now co-opted its usage.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.JIT.TraceJittedMethod.ForegroundMethodRequestTimeMSec">
            <summary>
            Legacy
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.TraceProcessesExtensions">
            <summary>
            TraceProcess Extension methods
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.ProcessIndex">
            <summary>
            Each process is given a unique index from 0 to TraceProcesses.Count-1 and unlike 
            the OS Process ID, is  unambiguous (The OS process ID can be reused after a
            process dies).  ProcessIndex represents this index.   By using an enum rather than an int
            it allows stronger typing and reduces the potential for errors.  
            <para>
            It is expected that users of this library might keep arrays of size TraceProcesses.Count to store
            additional data associated with a process in the trace.  
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Analysis.ProcessIndex.Invalid">
            <summary>
            Returned when no appropriate Process exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.TraceProcesses">
            <summary>
            A TraceProcesses instance represents the list of processes in the Event log.  
            
            TraceProcesses are IEnumerable, and will return the processes in order of creation time.   
            
            This is a copy of the reduced code from TraceLog!TraceProcesses (removal of elements that
            depend on TraceLog - there is a lot of them)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcesses.Log">
            <summary>
            The log associated with this collection of processes. 
            </summary> 
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcesses.Count">
            <summary>
            The count of the number of TraceProcess instances in the TraceProcesses list. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcesses.Item(Microsoft.Diagnostics.Tracing.Analysis.ProcessIndex)">
            <summary>
            Each process that occurs in the log is given a unique index (which unlike the PID is unique), that
            ranges from 0 to Count - 1.   Return the TraceProcess for the given index.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.TraceProcesses.ToString">
            <summary>
            An XML representation of the TraceEventProcesses (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.TraceProcesses.System#Collections#Generic#IEnumerable{Microsoft#Diagnostics#Tracing#Analysis#TraceProcess}#GetEnumerator">
            <summary>
            Enumerate all the processes that occurred in the trace log, ordered by creation time.   
            </summary> 
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.TraceProcesses.GetProcess(System.Int32,System.Int64)">
            <summary>
            Given an OS process ID and a time, return the last TraceProcess that has the same process ID,
            and whose offset start time is less than 'timeQPC'. If 'timeQPC' is during the thread's lifetime this
            is guaranteed to be the correct process. Using timeQPC = TraceLog.sessionEndTimeQPC will return the
            last process with the given PID, even if it had died.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.TraceProcesses.#ctor(Microsoft.Diagnostics.Tracing.Analysis.TraceLog,Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            TraceProcesses represents the entire ETL moduleFile log.   At the node level it is organized by threads.  
            
            The TraceProcesses also is where we put various caches that are independent of the process involved. 
            These include a cache for TraceModuleFile that represent native images that can be loaded into a
            process, as well as the process lookup tables and a cache that remembers the last calls to
            GetNameForAddress(). 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess">
            <summary>
            A step towards a refactored TraceProcess that will move down the dependcy chain from
            TraceLog to Source.  This is only the portion of TraceProcess that is needed for ManagedProcess
            to exist.  Also note, that the surface area is intended to match 100% with
            Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.  The namespace change is intention to avoid 
            collision of the name and to indicate that it is moving down the depdnency chain.
            
            This is a slightly modified copy of the code from TraceLog!TraceProcess
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.ProcessID">
            <summary>
            The OS process ID associated with the process. It is NOT unique across the whole log.  Use
            ProcessIndex for that. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.ProcessIndex">
            <summary>
            The index into the logical array of TraceProcesses for this process. Unlike ProcessID (which
            may be reused after the process dies, the process index is unique in the log. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.Name">
            <summary>
            This is a short name for the process.  It is the image file name without the path or suffix.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.CommandLine">
            <summary>
            The command line that started the process (may be empty string if unknown)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.ImageFileName">
            <summary>
            The path name of the EXE that started the process (may be empty string if unknown)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.StartTime">
            <summary>
            The time when the process started.  Returns the time the trace started if the process existed when the trace started.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.StartTimeRelativeMsec">
            <summary>
            The time when the process started.  Returns the time the trace started if the process existed when the trace started.  
            Returned as the number of MSec from the beginning of the trace. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.EndTime">
            <summary>
            The time when the process ended.  Returns the time the trace ended if the process existed when the trace ended.  
            Returned as a DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.EndTimeRelativeMsec">
            <summary>
            The time when the process ended.  Returns the time the trace ended if the process existed when the trace ended. 
            Returned as the number of MSec from the beginning of the trace. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.ParentID">
            <summary>
            The process ID of the parent process 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.Parent">
            <summary>
            The process that started this process.  Returns null if unknown.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.ExitStatus">
            <summary>
            If the process exited, the exit status of the process.  Otherwise null. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.CPUMSec">
            <summary>
            The amount of CPU time spent in this process based on the kernel CPU sampling events.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.Is64Bit">
            <summary>
            Returns true if the process is a 64 bit process
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.Log">
            <summary>
            The log file associated with the process. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.PeakWorkingSet">
            <summary>
            Peak working set
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.PeakVirtual">
            <summary>
            Peak virtual size
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.Threads">
            <summary>
            A list of all the threads that occurred in this process.  
            </summary> 
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.LoadedModules">
            <summary>
            Returns the list of modules that were loaded by the process.  The modules may be managed or
            native, and include native modules that were loaded event before the trace started.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.EventsInProcess">
            <summary>
            Filters events to only those for a particular process. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.EventsDuringProcess">
            <summary>
            Filters events to only that occurred during the time the process was alive. 
            </summary>
            
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Analysis.TraceProcess.ToString">
            <summary>
            An XML representation of the TraceEventProcess (for debugging)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Analysis.TraceLog">
            <summary>
            Dummy stubs so Microsoft.Diagnostics.Tracing.Etlx namespace is not necessary
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Ctf.CtfMetadata">
            <summary>
            The parsed metadata.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Ctf.CtfTrace">
            <summary>
            Information about the trace itself.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Ctf.CtfStream">
            <summary>
            Information about a single stream in the trace.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Ctf.CtfEnvironment">
            <summary>
            The environment the trace was taken in.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Ctf.CtfClock">
            <summary>
            A clock definition in the trace.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Ctf.CtfEvent">
            <summary>
            A definition of an event.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Ctf.CtfMetadataLegacyParser">
            <summary>
            A manual parser for CtfMetadata.  Eventually this should be replaced when CtfMetadata no longer
            uses a custom, BNF style format.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Ctf.CtfMetadataParser">
            <summary>
            The abstract metadata parser class.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Ctf.CtfDeclarationTypes">
            <summary>
            The types that may be declared in CtfMetatdata.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Ctf.CtfMetadataDeclaration">
            <summary>
            This class represents the top level entry 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Ctf.CtfPropertyBag">
            <summary>
            A simple class to make parsing out properties easier.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Ctf.CtfUnresolvedType">
            <summary>
            Represents a type which has been referenced by name, but has not yet been resolved to a concrete type.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser">
            <summary>
            A DynamicTraceEventParser is a parser that understands how to read the embedded manifests that occur in the 
            dataStream (System.Diagnostics.Tracing.EventSources do this).   
            
            See also TDHDynamicTraceEventParser which knows how to read the manifest that are registered globally with
            the machine.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.ManifestEventID">
            <summary>
            The event ID for the EventSource manifest emission event.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.#ctor(Microsoft.Diagnostics.Tracing.TraceEventSource)">
            <summary>
            Create a new DynamicTraceEventParser (which can parse ETW providers that dump their manifests
            to the ETW data stream) an attach it to the ETW data stream 'source'.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.DynamicProviders">
            <summary>
            Returns a list of providers (their manifest) that this TraceParser knows about.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.AddDynamicProvider(Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest,System.Boolean)">
            <summary>
            Given a manifest describing the provider add its information to the parser.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.WriteAllManifests(System.String)">
            <summary>
            Utility method that stores all the manifests known to the DynamicTraceEventParser to the directory 'directoryPath'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.ReadAllManifests(System.String)">
            <summary>
            Utility method that read all the manifests the directory 'directoryPath' into the parser.   
            Manifests must end in a .man or .manifest.xml suffix.   It will throw an error if
            the manifest is incorrect or using unsupported options.  
            </summary>        
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.IsStatic">
            <summary>
            Override.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.DynamicProviderAdded">
            <summary>
            This event, will be fired any time a new Provider is added to the table
            of ETW providers known to this DynamicTraceEventParser.   This includes
            when the EventSource manifest events are encountered as well as any
            explicit calls to AddDynamicProvider.  (including ReadAllManifests).
            
            The Parser will filter out duplicate manifest events, however if an
            old version of a provider's manifest is encountered, and later a newer
            version is encountered, you can receive this event more than once for
            a single provider.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.GetProviderName">
            <summary>
            override
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.CheckForDynamicManifest(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Called on unhandled events to look for manifests.    Returns true if we added a new manifest (which may have updated the lookup table)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParser.EnumerateTemplates(System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Action{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            Override 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData">
            <summary>
            DynamicTraceEventData is an event that knows how to take runtime information to parse event fields (and payload)
            
            This meta-data is distilled down to a array of field names and an array of PayloadFetches which contain enough
            information to find the field data in the payload blob.   This meta-data is used in the 
            DynamicTraceEventData.PayloadNames and DynamicTraceEventData.PayloadValue methods.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.Dispatch">
            <summary>
            Implements TraceEvent interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadNames">
            <summary>
            Implements TraceEvent interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadValue(System.Int32)">
            <summary>
            Implements TraceEvent interface
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.StructValue">
            <summary>
             Used by PayloadValue to represent a structure.   It is basically a IDictionary with a ToString() that 
             returns the value as JSON. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.StructValue.Quote(System.Text.StringBuilder,System.String)">
            <summary>
             Uses C style conventions to quote a string 'value' and append to the string builder 'sb'.
             Thus all \ are turned into \\ and all " into \"
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadString(System.Int32,System.IFormatProvider)">
            <summary>
            Implements TraceEvent interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.Target">
            <summary>
            Implements TraceEvent interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.GetCountForArray(Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch,Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetchArrayInfo,System.Int32@)">
            <summary>
            Returns the count of elements for the array represented by 'arrayInfo'
            It also will adjust 'offset' so that it points at the beginning of the
            array data (skips past the count). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch.#ctor(System.UInt16,System.UInt16,System.Type,System.Collections.Generic.IDictionary{System.Int64,System.String})">
            <summary>
            Constructor for normal types, (int, string) ...)   Also handles Enums (which are ints with a map)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch.#ctor(System.UInt16,Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TdhInputType,System.Int32)">
            <summary>
            Initialized a PayloadFetch for a given inType.  REturns Size = DynamicTraceEventData.UNKNOWN_SIZE
            if the type is unknown.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch.ArrayPayloadFetch(System.UInt16,Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch,System.UInt16,System.UInt16)">
            <summary>
            Returns a payload fetch for a Array.   If you know the count, then you can give it. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch.Offset">
            <summary>
            Offset from the beginning of the struct.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData.PayloadFetch.LazyMap">
            <summary>
            LazyMap allow out to set a function that returns a map 
            instead of the map itself.   This will be evaluated when the map
            is fetched (which gives time for the map table to be populated.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.DynamicManifestTraceEventData">
            <summary>
            This class is only used to pretty-print the manifest event itself.   It is pretty special purpose
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventParserState">
            <summary>
            DynamicTraceEventParserState represents the state of a  DynamicTraceEventParser that needs to be
            serialized to a log file.  It does NOT include information about what events are chosen but DOES contain
            any other necessary information that came from the ETL data file.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest">
            <summary>
            A ProviderManifest represents the XML manifest associated with the provider.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Read a ProviderManifest from a stream
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.#ctor(System.String)">
            <summary>
            Read a ProviderManifest from a file. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.ValidateManifest">
            <summary>
            Normally ProviderManifest will fail silently if there is a problem with the manifest.  If
            you want to see this error you can all this method to force it explicitly  It will
            throw if there is a problem parsing the manifest.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.WriteToStream(System.IO.Stream)">
            <summary>
            Writes the manifest to 'outputStream' (as UTF8 XML text)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.WriteToFile(System.String)">
            <summary>
            Writes the manifest to a file 'filePath' (as a UTF8 XML)
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.ISDynamic">
            <summary>
             Set if this manifest came from the ETL data stream file.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.Name">
            <summary>
            The name of the ETW provider
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.Guid">
            <summary>
            The GUID that uniquey identifies the ETW provider
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.Version">
             <summary>
             The version is defined as the sum of all the version numbers of event version numbers + the number of events defined. 
             This has the property that if you follow correct versioning protocol (all versions for a linear sequence where a new  
             versions is only modifies is predecessor by adding new events or INCREASING the version numbers of existing events) 
             then the version number defined below will always strictly increase.   
            
             It turns out that .NET Core removed some events from the TplEtwProvider.   To allow removal of truly old events
             we also add 100* the largest event ID defined to the version number.  That way if you add new events, even if you
             removes some (less than 100) it will consider your 'better'.   
             </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.Id">
            <summary>
            This is an arbitrary id given when the Manifest is created that
            identifies where the manifest came from (e.g. a file name or an event etc). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.BetterThan(Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest)">
            <summary>
            Returns true if the current manifest is better to use than 'otherManifest'   A manifest is
            better if it has a larger version number OR, they have the same version number and it is
            physically larger (we assume what happened is people added more properties but did not
            update the version field appropriately).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.Manifest">
            <summary>
            Retrieve manifest as one big string.  Mostly for debugging
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.ManifestReader">
            <summary>
            Retrieve the manifest as XML
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.ToString">
            <summary>
            For debugging
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.ParseProviderEvents(System.Func{Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Boolean)">
            <summary>
            Call 'callback the the parsed templates for this provider.  If 'callback' returns RejectProvider, bail early
            Note that the DynamicTraceEventData passed to the delegate needs to be cloned if you use subscribe to it.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.GetTypeForManifestTypeName(System.String)">
            <summary>
            Returns the .NET type corresponding to the manifest type 'manifestTypeName'
            Returns null if it could not be found. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ProviderManifest.Init">
            <summary>
            Initialize the provider.  This means to advance the instance variable 'reader' until it it is at the 'provider' node
            in the XML.   It also has the side effect of setting the name and guid.  The rest waits until events are registered. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords">
            <summary>
             Keywords are passed to TraceEventSession.EnableProvider to enable particular sets of
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GC">
            <summary>
            Logging when garbage collections and finalization happen. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCHandle">
            <summary>
            Events when GC handles are set or destroyed.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Loader">
            <summary>
            Logging when modules actually get loaded and unloaded. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Jit">
            <summary>
            Logging when Just in time (JIT) compilation occurs. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.NGen">
            <summary>
            Logging when precompiled native (NGEN) images are loaded.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.StartEnumeration">
            <summary>
            Indicates that on attach or module load , a rundown of all existing methods should be done
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.StopEnumeration">
            <summary>
            Indicates that on detach or process shutdown, a rundown of all existing methods should be done
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Security">
            <summary>
            Events associated with validating security restrictions.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.AppDomainResourceManagement">
            <summary>
            Events for logging resource consumption on an app-domain level granularity
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.JitTracing">
            <summary>
            Logging of the internal workings of the Just In Time compiler.  This is fairly verbose.  
            It details decisions about interesting optimization (like inlining and tail call) 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Interop">
            <summary>
            Log information about code thunks that transition between managed and unmanaged code. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Contention">
            <summary>
            Log when lock contention occurs.  (Monitor.Enters actually blocks)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Exception">
            <summary>
            Log exception processing.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Threading">
            <summary>
            Log events associated with the threadpool, and other threading events.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.JittedMethodILToNativeMap">
            <summary>
            Dump the native to IL mapping of any method that is JIT compiled.  (V4.5 runtimes and above).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.OverrideAndSuppressNGenEvents">
            <summary>
            If enabled will suppress the rundown of NGEN events on V4.0 runtime (has no effect on Pre-V4.0 runtimes).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Type">
            <summary>
            Enables the 'BulkType' event
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCHeapDump">
            <summary>
            Enables the events associated with dumping the GC heap
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCSampledObjectAllocationHigh">
            <summary>
            Enables allocation sampling with the 'fast'.  Sample to limit to 100 allocations per second per type.  
            This is good for most detailed performance investigations.   Note that this DOES update the allocation
            path to be slower and only works if the process start with this on. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCHeapSurvivalAndMovement">
            <summary>
            Enables events associate with object movement or survival with each GC.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCHeapCollect">
            <summary>
            Triggers a GC.  Can pass a 64 bit value that will be logged with the GC Start event so you know which GC you actually triggered.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCHeapAndTypeNames">
            <summary>
            Indicates that you want type names looked up and put into the events (not just meta-data tokens).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCSampledObjectAllocationLow">
            <summary>
            Enables allocation sampling with the 'slow' rate, Sample to limit to 5 allocations per second per type.  
            This is reasonable for monitoring.    Note that this DOES update the allocation path to be slower
            and only works if the process start with this on.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCAllObjectAllocation">
            <summary>
            Turns on capturing the stack and type of object allocation made by the .NET Runtime.   This is only
            supported after V4.5.3 (Late 2014)   This can be very verbose and you should seriously using  GCSampledObjectAllocationHigh
            instead (and GCSampledObjectAllocationLow for production scenarios).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.SupressNGen">
            <summary>
            This suppresses NGEN events on V4.0 (where you have NGEN PDBs), but not on V2.0 (which does not know about this 
            bit and also does not have NGEN PDBS).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.PerfTrack">
            <summary>
            TODO document
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Stack">
            <summary>
            Also log the stack trace of events for which this is valuable.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.ThreadTransfer">
            <summary>
            This allows tracing work item transfer events (thread pool enqueue/dequeue/ioenqueue/iodequeue/a.o.)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Debugger">
            <summary>
            .NET Debugger events
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Monitoring">
            <summary>
            Events intended for monitoring on an ongoing basis.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Codesymbols">
            <summary>
            Events that will dump PDBs of dynamically generated assemblies to the ETW stream.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Compilation">
            <summary>
            Events that provide information about compilation.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.CompilationDiagnostic">
            <summary>
            Diagnostic events for diagnosing compilation and pre-compilation features.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.MethodDiagnostic">
            <summary>
            Diagnostic events for capturing token information for events that express MethodID
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.TypeDiagnostic">
            <summary>
            Diagnostic events for diagnosing issues involving the type loader.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.Default">
            <summary>
            Recommend default flags (good compromise on verbosity).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.JITSymbols">
            <summary>
            What is needed to get symbols for JIT compiled code.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.Keywords.GCHeapSnapshot">
            <summary>
            This provides the flags commonly needed to take a heap .NET Heap snapshot with ETW.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ClrTraceEventParser.State">
            <summary>
            Fetch the state object associated with this parser and cast it to
            the ClrTraceEventParserState type.   This state object contains any
            information that you need from one event to another to decode events.
            (typically ID->Name tables).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCHeapStatsTraceData.Depth">
            <summary>
            Note that this field is derived from the TotalPromotedSize* fields.  If nothing was promoted, it is possible
            that this could give a number that is smaller than what GC/Start or GC/Stop would indicate.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkTypeTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned BulkTypeValues 
            points the the data in GCBulkRootEdgeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkTypeValues">
            <summary>
            This structure just POINTS at the data in the BulkTypeTraceData.  It can only be used as long as
            the BulkTypeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkTypeValues.TypeID">
            <summary>
            On the desktop this is the Method Table Pointer
            In project N this is the pointer to the EE Type
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkTypeValues.ModuleID">
            <summary>
            For Desktop this is the Module*
            For project N it is image base for the module that the type lives in?
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkTypeValues.TypeNameID">
            <summary>
            On desktop this is the Meta-data token?
            On project N it is the RVA of the typeID
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkTypeValues.TypeName">
            <summary>
            Note that this method returns the type name with generic parameters in .NET Runtime
            syntax   e.g. System.WeakReference`1[System.Diagnostics.Tracing.EtwSession]
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootEdgeTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned GCBulkRootEdgeValues
            points the the data in GCBulkRootEdgeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootEdgeValues">
            <summary>
            This structure just POINTS at the data in the GCBulkEdgeTraceData.  It can only be used as long as
            the GCBulkEdgeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootConditionalWeakTableElementEdgeTraceData.Values(System.Int32)">
            <summary>
            Returns the range at the given zero-based index (index less than Count).   The returned GCBulkRootConditionalWeakTableElementEdgeValues 
            points the the data in GCBulkRootConditionalWeakTableElementEdgeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootConditionalWeakTableElementEdgeValues">
            <summary>
            This structure just POINTS at the data in the GCBulkRootConditionalWeakTableElementEdgeTraceData.  It can only be used as long as
            the GCBulkRootConditionalWeakTableElementEdgeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkNodeTraceData.Values(System.Int32)">
            <summary>
            Returns the node at the given zero-based index (idx less than Count).   The returned GCBulkNodeNodes 
            points the the data in GCBulkNodeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkNodeTraceData.UnsafeNodes(System.Int32,Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkNodeUnsafeNodes*)">
            <summary>
            This unsafe interface may go away.   Use the 'Nodes(idx)' instead 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkNodeValues">
            <summary>
            This structure just POINTS at the data in the GCBulkNodeTraceData.  It can only be used as long as
            the GCBulkNodeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkEdgeTraceData.Values(System.Int32)">
            <summary>
            Returns the 'idx' th edge.  
            The returned GCBulkEdgeEdges cannot live beyond the TraceEvent that it comes from.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkEdgeValues">
            <summary>
            This structure just POINTS at the data in the GCBulkNodeTraceData.  It can only be used as long as
            the GCBulkNodeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkSurvivingObjectRangesTraceData.Values(System.Int32)">
            <summary>
            Returns the range at the given zero-based index (index less than Count).   The returned GCBulkSurvivingObjectRangesValues 
            points the the data in GCBulkSurvivingObjectRangesTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkSurvivingObjectRangesValues">
            <summary>
            This structure just POINTS at the data in the GCBulkEdgeTraceData.  It can only be used as long as
            the GCBulkEdgeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkMovedObjectRangesTraceData.Values(System.Int32)">
            <summary>
            Returns the range at the given zero-based index (index less than Count).   The returned GCBulkSurvivingObjectRangesValues 
            points the the data in GCBulkSurvivingObjectRangesTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkMovedObjectRangesValues">
            <summary>
            This structure just POINTS at the data in the GCBulkEdgeTraceData.  It can only be used as long as
            the GCBulkEdgeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens">
            <summary>
            We keep Heap history for every Generation in 'Gens' 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.gc_heap_expand_mechanism">
            <summary>
            Taken from gcrecords.h, used to differentiate heap expansion and compaction reasons
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryTraceData">
            <summary>
            Version 0, PreciseVersion 0.1: Silverlight (x86)
            0:041> dt -r2 coreclr!WKS::gc_history_per_heap
               +0x000 gen_data         : [5] WKS::gc_generation_data
                  +0x000 size_before      : Uint4B/8B       : [0 - 40), [40 - 80), [80 - 120), [120 - 160), [160 - 200)
                  +0x004 size_after       : Uint4B/8B
                  +0x008 current_size     : Uint4B/8B
                  +0x00c previous_size    : Uint4B/8B
                  +0x010 fragmentation    : Uint4B/8B
                  +0x014 in               : Uint4B/8B
                  +0x018 out              : Uint4B/8B
                  +0x01c new_allocation   : Uint4B/8B
                  +0x020 surv             : Uint4B/8B
                  +0x024 growth           : Uint4B/8B
               +0x0c8 mem_pressure        : Uint4B      : 200
               +0x0cc mechanisms          : [2] Uint4B  : 204 (expand), 208 (compact)
               +0x0d4 gen_condemn_reasons : Uint4B      : 212
               +0x0d8 heap_index          : Uint4B      : 216
             
               clrInstanceId              : byte        : 220
            
            Version 0, PreciseVersion 0.2: .NET 4.0
            0:000> dt -r2 clr!WKS::gc_history_per_heap
               +0x000 gen_data         : [5] WKS::gc_generation_data
                  +0x000 size_before      : Uint4B/8B      : [0 - 40), [40 - 80), [80 - 120), [120 - 160), [160 - 200)
                  +0x004 size_after       : Uint4B/8B
                  +0x008 current_size     : Uint4B/8B
                  +0x00c previous_size    : Uint4B/8B
                  +0x010 fragmentation    : Uint4B/8B
                  +0x014 in               : Uint4B/8B
                  +0x018 out              : Uint4B/8B
                  +0x01c new_allocation   : Uint4B/8B
                  +0x020 surv             : Uint4B/8B
                  +0x024 growth           : Uint4B/8B
                +0x0c8 mem_pressure     : Uint4B        : 200
                +0x0cc mechanisms       : [3] Uint4B    : 204 (expand), 208 (compact), 212 (concurrent_compact)
               +0x0d8 gen_condemn_reasons : Uint4B      : 216
               +0x0dc heap_index       : Uint4B         : 220
               
               clrInstanceId              : byte        : 224
            
            vm\gcrecord.h
            Etw_GCDataPerHeapSpecial(...)
            ...
                EventDataDescCreate(EventData[0], gc_data_per_heap, datasize);
                EventDataDescCreate(EventData[1], ClrInstanceId, sizeof(ClrInstanceId));
            
            Version 1: ???
            
            Version 2, PreciseVersion 2.1: .NET 4.5 (x86)
            0:000> dt -r2 WKS::gc_history_per_heap
             clr!WKS::gc_history_per_heap
            +0x000 gen_data         : [5] WKS::gc_generation_data
               +0x000 size_before      : Uint4B/8B         : [0 - 40), [40 - 80), [80 - 120), [120 - 160), [160 - 200)
               +0x004 free_list_space_before : Uint4B/8B
               +0x008 free_obj_space_before : Uint4B/8B
               +0x00c size_after       : Uint4B/8B
               +0x010 free_list_space_after : Uint4B/8B
               +0x014 free_obj_space_after : Uint4B/8B
               +0x018 in               : Uint4B/8B
               +0x01c out              : Uint4B/8B
               +0x020 new_allocation   : Uint4B/8B
               +0x024 surv             : Uint4B/8B
            +0x0c8 gen_to_condemn_reasons : WKS::gen_to_condemn_tuning
               +0x000 condemn_reasons_gen : Uint4B          : 200
               +0x004 condemn_reasons_condition : Uint4B    : 204
            +0x0d0 mem_pressure     : Uint4B                : 208
            +0x0d4 mechanisms       : [2] Uint4B            : 212 (expand), 216 (compact)
            +0x0dc heap_index       : Uint4B                : 220
            
            vm\gcrecord.h
            Etw_GCDataPerHeapSpecial(...)
            ...
                EventDataDescCreate(EventData[0], gc_data_per_heap, datasize);
                EventDataDescCreate(EventData[1], ClrInstanceId, sizeof(ClrInstanceId));
            
            Version 2, PreciseVersion 2.2: .NET 4.5.2 (x86)
            0:000> dt -r2 WKS::gc_history_per_heap
             clr!WKS::gc_history_per_heap
            +0x000 gen_data         : [5] WKS::gc_generation_data
               +0x000 size_before      : Uint4B/8B          : [0 - 40), [40 - 80), [80 - 120), [120 - 160), [160 - 200)
               +0x004 free_list_space_before : Uint4B/8B
               +0x008 free_obj_space_before : Uint4B/8B
               +0x00c size_after       : Uint4B/8B
               +0x010 free_list_space_after : Uint4B/8B
               +0x014 free_obj_space_after : Uint4B/8B
               +0x018 in               : Uint4B/8B
               +0x01c out              : Uint4B/8B
               +0x020 new_allocation   : Uint4B/8B
               +0x024 surv             : Uint4B/8B
            +0x0c8 gen_to_condemn_reasons : WKS::gen_to_condemn_tuning
               +0x000 condemn_reasons_gen : Uint4B          : 200
               +0x004 condemn_reasons_condition : Uint4B    : 204
            +0x0d0 mem_pressure     : Uint4B                : 208
            +0x0d4 mechanisms       : [2] Uint4B            : 212 (expand), 216 (compact)
            +0x0dc heap_index       : Uint4B                : 220
            +0x0e0 extra_gen0_committed : Uint8B            : 224
            
            vm\gcrecord.h
            Etw_GCDataPerHeapSpecial(...)
            ...
                EventDataDescCreate(EventData[0], gc_data_per_heap, datasize);
                EventDataDescCreate(EventData[1], ClrInstanceId, sizeof(ClrInstanceId));
            
            Version 3: .NET 4.6 (x86)
            0:000> dt -r2 WKS::gc_history_per_heap
            clr!WKS::gc_history_per_heap
               +0x000 gen_data         : [4]                                
                WKS::gc_generation_data                                     
                  +0x000 size_before      : Uint4B/8B                          
                  +0x004 free_list_space_before : Uint4B/8B                    
                  +0x008 free_obj_space_before : Uint4B/8B                     
                  +0x00c size_after       : Uint4B/8B                          
                  +0x010 free_list_space_after : Uint4B/8B
                  +0x014 free_obj_space_after : Uint4B/8B
                  +0x018 in               : Uint4B/8B
                  +0x01c pinned_surv      : Uint4B/8B
                  +0x020 npinned_surv     : Uint4B/8B
                  +0x024 new_allocation   : Uint4B/8B
               +0x0a0 maxgen_size_info : WKS::maxgen_size_increase          
                  +0x000 free_list_allocated : Uint4B/8B                       
                  +0x004 free_list_rejected : Uint4B/8B                        
                  +0x008 end_seg_allocated : Uint4B/8B                         
                  +0x00c condemned_allocated : Uint4B/8B                       
                  +0x010 pinned_allocated : Uint4B/8B                          
                  +0x014 pinned_allocated_advance : Uint4B/8B                  
                  +0x018 running_free_list_efficiency : Uint4B/8B              
               +0x0bc gen_to_condemn_reasons : WKS::gen_to_condemn_tuning   
                  +0x000 condemn_reasons_gen : Uint4B                       
                  +0x004 condemn_reasons_condition : Uint4B                 
               +0x0c4 mechanisms       : [2] Uint4B                         
               +0x0cc machanism_bits   : Uint4B                             
               +0x0d0 heap_index       : Uint4B                             
               +0x0d4 extra_gen0_committed : Uint4B/8B                         
            
            pal\src\eventprovider\lttng\eventprovdotnetruntime.cpp
            FireEtXplatGCPerHeapHistory_V3(...)
            
                 tracepoint(
                    DotNETRuntime,
                    GCPerHeapHistory_V3,                      x86 offsets
                    ClrInstanceID,                          : 0
                    (const size_t) FreeListAllocated,       : 2
                    (const size_t) FreeListRejected,        : 6
                    (const size_t) EndOfSegAllocated,       : 10
                    (const size_t) CondemnedAllocated,      : 14
                    (const size_t) PinnedAllocated,         : 18
                    (const size_t) PinnedAllocatedAdvance,  : 22
                    RunningFreeListEfficiency,              : 26
                    CondemnReasons0,                        : 30
                    CondemnReasons1                         : 34
                    );
                tracepoint(
                    DotNETRuntime,
                    GCPerHeapHistory_V3_1,
                    CompactMechanisms,                      : 38
                    ExpandMechanisms,                       : 42
                    HeapIndex,                              : 46
                    (const size_t) ExtraGen0Commit,         : 50
                    Count,                                  : 54 (number of WKS::gc_generation_data's)
                    Arg15_Struct_Len_,                      : ?? not really sent
                    (const int*) Arg15_Struct_Pointer_      : [58 - 98), ...
                    );
            
            Version 3 is now setup to allow "add to the end" scenarios
            
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryTraceData.CondemnReasons0">
            <summary>
            Returns the condemned generation number
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryTraceData.CondemnReasons1">
            <summary>
            Returns the condemned condition
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryTraceData.GenData(Microsoft.Diagnostics.Tracing.Parsers.Clr.Gens)">
            <summary>
            genNumber is a number from 0 to maxGenData-1.  These are for generation 0, 1, 2, 3 = Large Object Heap
            genNumber = 4 is that second pass for Gen 0.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData">
            <summary>
            Version 0: Silverlight (x86), .NET 4.0
            [5] WKS::gc_generation_data
               +0x000 size_before      : Uint4B/8B
               +0x004 size_after       : Uint4B/8B
               +0x008 current_size     : Uint4B/8B
               +0x00c previous_size    : Uint4B/8B
               +0x010 fragmentation    : Uint4B/8B
               +0x014 in               : Uint4B/8B
               +0x018 out              : Uint4B/8B
               +0x01c new_allocation   : Uint4B/8B
               +0x020 surv             : Uint4B/8B
               +0x024 growth           : Uint4B/8B
               
            Version 1: ???
            
            Version 2, PreciseVersion 2.1: .NET 4.5 (x86), .NET 4.5.2 (x86)
             [5] WKS::gc_generation_data
               +0x000 size_before            : Uint4B/8B
               +0x004 free_list_space_before : Uint4B/8B
               +0x008 free_obj_space_before  : Uint4B/8B
               +0x00c size_after             : Uint4B/8B
               +0x010 free_list_space_after  : Uint4B/8B
               +0x014 free_obj_space_after   : Uint4B/8B
               +0x018 in                     : Uint4B/8B
               +0x01c out                    : Uint4B/8B
               +0x020 new_allocation         : Uint4B/8B
               +0x024 surv                   : Uint4B/8B
            
            Version 3: .NET 4.6 (x86)
            [4] WKS::gc_generation_data                                     
               +0x000 size_before            : Uint4B/8B                          
               +0x004 free_list_space_before : Uint4B/8B                    
               +0x008 free_obj_space_before  : Uint4B/8B                     
               +0x00c size_after             : Uint4B/8B                          
               +0x010 free_list_space_after  : Uint4B/8B
               +0x014 free_obj_space_after   : Uint4B/8B
               +0x018 in                     : Uint4B/8B
               +0x01c pinned_surv            : Uint4B/8B
               +0x020 npinned_surv           : Uint4B/8B
               +0x024 new_allocation         : Uint4B/8B
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.SizeBefore">
            <summary>
            Size of the generation before the GC, includes fragmentation
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.SizeAfter">
            <summary>
            Size of the generation after GC.  Includes fragmentation
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.ObjSpaceBefore">
            <summary>
            Size occupied by objects at the beginning of the GC, discounting fragmentation. 
            Only exits on 4.5 RC and beyond.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.Fragmentation">
            <summary>
            This is the fragmenation at the end of the GC.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.ObjSizeAfter">
            <summary>
            Size occupied by objects, discounting fragmentation.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.FreeListSpaceBefore">
            <summary>
            This is the free list space (ie, what's threaded onto the free list) at the beginning of the GC.
            Only exits on 4.5 RC and beyond.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.FreeObjSpaceBefore">
            <summary>
            This is the free obj space (ie, what's free but not threaded onto the free list) at the beginning of the GC.
            Only exits on 4.5 RC and beyond.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.FreeListSpaceAfter">
            <summary>
            This is the free list space (ie, what's threaded onto the free list) at the end of the GC.
            Only exits on 4.5 Beta and beyond.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.FreeObjSpaceAfter">
            <summary>
            This is the free obj space (ie, what's free but not threaded onto the free list) at the end of the GC.
            Only exits on 4.5 Beta and beyond.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.In">
            <summary>
            This is the amount that came into this generation on this GC
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.Out">
            <summary>
            This is the number of bytes survived in this generation.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.Budget">
            <summary>
            This is the new budget for the generation
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCPerHeapHistoryGenData.SurvRate">
            <summary>
            This is the survival rate
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCGlobalHeapHistoryTraceData">
            <summary>
            Version 0: ???
            
            Version 1: Silverlight (x86), .NET 4.0, .NET 4.5, .NET 4.5.2
            VM\gc.cpp
            0:041> dt -r3 WKS::gc_history_global
            coreclr!WKS::gc_history_global
               +0x000 final_youngest_desired : Uint4B/8B
               +0x004 num_heaps        : Uint4B
               +0x008 condemned_generation : Int4B
               +0x00c gen0_reduction_count : Int4B
               +0x010 reason           : 
                reason_alloc_soh = 0n0
                reason_induced = 0n1
                reason_lowmemory = 0n2
                reason_empty = 0n3
                reason_alloc_loh = 0n4
                reason_oos_soh = 0n5
                reason_oos_loh = 0n6
                reason_induced_noforce = 0n7
                reason_gcstress = 0n8
                reason_max = 0n9
               +0x014 global_mechanims_p : Uint4B
              
            FireEtwGCGlobalHeapHistory_V1(gc_data_global.final_youngest_desired, // upcast on 32bit to __int64
                                     gc_data_global.num_heaps,
                                     gc_data_global.condemned_generation,
                                     gc_data_global.gen0_reduction_count,
                                     gc_data_global.reason,
                                     gc_data_global.global_mechanims_p,
                                     GetClrInstanceId());
            Version 2: .NET 4.6
            clr!WKS::gc_history_global
               +0x000 final_youngest_desired : Uint4B/8B
               +0x004 num_heaps        : Uint4B
               +0x008 condemned_generation : Int4B
               +0x00c gen0_reduction_count : Int4B
               +0x010 reason           : 
                reason_alloc_soh = 0n0
                reason_induced = 0n1
                reason_lowmemory = 0n2
                reason_empty = 0n3
                reason_alloc_loh = 0n4
                reason_oos_soh = 0n5
                reason_oos_loh = 0n6
                reason_induced_noforce = 0n7
                reason_gcstress = 0n8
                reason_lowmemory_blocking = 0n9
                reason_induced_compacting = 0n10
                reason_lowmemory_host = 0n11
                reason_max = 0n12
               +0x014 pause_mode       : Int4B
               +0x018 mem_pressure     : Uint4B
               +0x01c global_mechanims_p : Uint4B
            
            FireEtwGCGlobalHeapHistory_V2(gc_data_global.final_youngest_desired, // upcast on 32bit to __int64
                                     gc_data_global.num_heaps,
                                     gc_data_global.condemned_generation,
                                     gc_data_global.gen0_reduction_count,
                                     gc_data_global.reason,
                                     gc_data_global.global_mechanims_p,
                                     GetClrInstanceId());
                                     gc_data_global.pause_mode, 
                                     gc_data_global.mem_pressure);
                                     
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.FinalizeObjectTraceData.TypeName">
            <summary>
            Gets the full type name including generic parameters in runtime syntax
            For example System.WeakReference`1[System.Diagnostics.Tracing.EtwSession]
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootCCWTraceData.Values(System.Int32)">
            <summary>
            Returns the CCW at the given zero-based index (index less than Count).   The returned GCBulkRootCCWValues 
            points the the data in GCBulkRootCCWTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootCCWTraceData.ValueSize">
            <summary>
            Computes the size of one GCBulkRootCCWValues structure.  
            TODO FIX NOW Can rip out and make a constant 44 after 6/2014
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootCCWValues">
            <summary>
            This structure just POINTS at the data in the GCBulkRootCCWTraceData.  It can only be used as long as
            the GCBulkRootCCWTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRCWTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned GCBulkRCWValues 
            points the the data in GCBulkRCWTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRCWValues">
            <summary>
            This structure just POINTS at the data in the GCBulkRCWTraceData.  It can only be used as long as
            the GCBulkRCWTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootStaticVarTraceData.Values(System.Int32)">
            <summary>
            Returns 'idx'th static root.   
            The returned GCBulkRootStaticVarStatics cannot live beyond the TraceEvent that it comes from.  
            The implementation is highly tuned for sequential access.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.GCBulkRootStaticVarValues">
            <summary>
            This structure just POINTS at the data in the GCBulkRootStaticVarTraceData.  It can only be used as long as
            the GCBulkRootStaticVarTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrStackWalkTraceData.InstructionPointer(System.Int32)">
            <summary>
            Fetches the instruction pointer of a eventToStack frame 0 is the deepest frame, and the maximum should
            be a thread offset routine (if you get a complete eventToStack).  
            </summary>
            <param name="index">The index of the frame to fetch.  0 is the CPU EIP, 1 is the Caller of that
            routine ...</param>
            <returns>The instruction pointer of the specified frame.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrStackWalkTraceData.InstructionPointers">
            <summary>
            Access to the instruction pointers as a unsafe memory blob
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Clr.ModuleLoadUnloadTraceData.ModuleILFileName">
            <summary>
            This is simply the file name part of the ModuleILPath.  It is a convenience method. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrRundownTraceEventParser.Keywords.Threading">
            <summary>
            Log events associated with the threadpool, and other threading events.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrRundownTraceEventParser.Keywords.JittedMethodILToNativeMap">
            <summary>
            Dump the native to IL mapping of any method that is JIT compiled.  (V4.5 runtimes and above).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrRundownTraceEventParser.Keywords.SupressNGen">
            <summary>
            This suppresses NGEN events on V4.0 (where you have NGEN PDBs), but not on V2.0 (which does not know about this 
            bit and also does not have NGEN PDBS).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrRundownTraceEventParser.Keywords.PerfTrack">
            <summary>
            TODO document
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrRundownTraceEventParser.Keywords.CodeSymbolsRundown">
            <summary>
            Dump PDBs for dynamically generated modules.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrRundownTraceEventParser.Keywords.Compilation">
            <summary>
            Events that provide information about compilation.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Clr.ClrTraceEventParserState">
            <summary>
            ClrTraceEventParserState holds all information that is shared among all events that is
            needed to decode Clr events.   This class is registered with the source so that it will be
            persisted.  Things in here include
            
                * TypeID to TypeName mapping, 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.JSDumpHeap.BulkNodeTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned BulkNodeValues 
            points the the data in BulkNodeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.JSDumpHeap.BulkNodeValues">
            <summary>
            This structure just POINTS at the data in the BulkNodeTraceData.  It can only be used as long as
            the BulkNodeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.JSDumpHeap.BulkAttributeTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned BulkAttributeValues 
            points the the data in BulkAttributeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.JSDumpHeap.BulkAttributeValues">
            <summary>
            This structure just POINTS at the data in the BulkAttributeTraceData.  It can only be used as long as
            the BulkAttributeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.JSDumpHeap.BulkEdgeTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned BulkEdgeValues 
            points the the data in BulkEdgeTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.JSDumpHeap.BulkEdgeValues">
            <summary>
            This structure just POINTS at the data in the BulkNodeTraceData.  It can only be used as long as
            the BulkNodeTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser">
            <summary>
            The KernelTraceEventParser is a class that knows how to decode the 'standard' kernel events.
            It exposes an event for each event of interest that users can subscribe to.
            
            see TraceEventParser for more 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.KernelSessionName">
            <summary>
            The special name for the Kernel session
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords">
            <summary>
            This is passed to TraceEventSession.EnableKernelProvider to enable particular sets of
            events.  See http://msdn.microsoft.com/en-us/library/aa363784(VS.85).aspx for more information on them 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.None">
            <summary>
            Logs nothing
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.DiskFileIO">
            <summary>
            Logs the mapping of file IDs to actual (kernel) file names. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.DiskIO">
            <summary>
            Loads the completion of Physical disk activity. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ImageLoad">
            <summary>
            Logs native modules loads (LoadLibrary), and unloads
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.MemoryHardFaults">
            <summary>
            Logs all page faults that must fetch the data from the disk (hard faults)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.NetworkTCPIP">
            <summary>
            Logs TCP/IP network send and receive events. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Process">
            <summary>
            Logs process starts and stops.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ProcessCounters">
            <summary>
            Logs process performance counters (TODO When?) (Vista+ only)
            see KernelTraceEventParser.ProcessPerfCtr, ProcessPerfCtrTraceData
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Profile">
            <summary>
            Sampled based profiling (every msec) (Vista+ only) (expect 1K events per proc per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Thread">
            <summary>
            Logs threads starts and stops
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ContextSwitch">
            <summary>
            log thread context switches (Vista only) (can be > 10K events per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.DiskIOInit">
            <summary>
            log Disk operations (Vista+ only)
            Generally not TOO volumous (typically less than 1K per second) (Stacks associated with this)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Dispatcher">
            <summary>
            Thread Dispatcher (ReadyThread) (Vista+ only) (can be > 10K events per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.FileIO">
            <summary>
            log file FileOperationEnd (has status code) when they complete (even ones that do not actually
            cause Disk I/O).  (Vista+ only)
            Generally not TOO volumous (typically less than 1K per second) (No stacks associated with these)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.FileIOInit">
            <summary>
            log the start of the File I/O operation as well as the end. (Vista+ only)
            Generally not TOO volumous (typically less than 1K per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Memory">
            <summary>
            Logs all page faults (hard or soft)
            Can be pretty volumous (> 1K per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Registry">
            <summary>
            Logs activity to the windows registry. 
            Can be pretty volumous (> 1K per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.SystemCall">
            <summary>
            log calls to the OS (Vista+ only)
            This is VERY volumous (can be > 100K events per second)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.VirtualAlloc">
            <summary>
            Log Virtual Alloc calls and VirtualFree.   (Vista+ Only)
            Generally not TOO volumous (typically less than 1K per second)
            </summary> 
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.VAMap">
            <summary>
            Log mapping of files into memory (Win8 and above Only)
            Generally low volume.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.AdvancedLocalProcedureCalls">
            <summary>
            Logs Advanced Local Procedure call events. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.DeferedProcedureCalls">
            <summary>
            log defered procedure calls (an Kernel mechanism for having work done asynchronously) (Vista+ only)
            </summary> 
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Driver">
            <summary>
            Device Driver logging (Vista+ only)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Interrupt">
            <summary>
            log hardware interrupts. (Vista+ only)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.SplitIO">
            <summary>
            Disk I/O that was split (eg because of mirroring requirements) (Vista+ only)
            </summary> 
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Default">
            <summary>
            Good default kernel flags.  (TODO more detail)
            </summary>  
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Verbose">
            <summary>
            These events are too verbose for normal use, but this give you a quick way of turing on 'interesting' events
            This does not include SystemCall because it is 'too verbose'
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ThreadTime">
            <summary>
            Use this if you care about blocked time.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.OS">
            <summary>
            You mostly don't care about these unless you are dealing with OS internals.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.All">
            <summary>
            All legal kernel events
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.NonContainer">
            <summary>
            These are the kernel events that are not allowed in containers.  Can be subtracted out.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.PMCProfile">
            <summary>
            Turn on PMC (Precise Machine Counter) events.   Only Win 8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ReferenceSet">
            <summary>
            Kernel reference set events (like XPERF ReferenceSet).   Fully works only on Win 8.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.ThreadPriority">
            <summary>
            Events when thread priorities change.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.IOQueue">
            <summary>
            Events when queuing and dequeuing from the I/O completion ports.    
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords.Handle">
            <summary>
            Handle creation and closing (for handle leaks) 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.NonOSKeywords">
            <summary>
            These keywords can't be passed to the OS, they are defined by KernelTraceEventParser
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ParserTrackingOptions">
            <summary>
            What his parser should track by default.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.KernelPathToUserPathMapper">
            <summary>
            Defines how kernel paths are converted to user paths. Setting it overrides the default path conversion mechanism.
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ProcessStartGroup">
            <summary>
            Registers both ProcessStart and ProcessDCStart
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ProcessEndGroup">
            <summary>
            Registers both ProcessEnd and ProcessDCStop
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ThreadStartGroup">
            <summary>
            Registers both ThreadStart and ThreadDCStart
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ThreadEndGroup">
            <summary>
            Registers both ThreadEnd and ThreadDCStop
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ImageLoadGroup">
            <summary>
            Registers both ImageLoad and ImageDCStart
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.ImageUnloadGroup">
            <summary>
            Registers both ImageUnload and ImageDCStop
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.MemoryMemInfo">
            <summary>
            Rasied every 0.5s with memory metrics of the current machine.
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.SysConfigVolumeMapping">
            <summary>
            File names in ETW are the Kernel names, which need to be mapped to the drive specification users see. 
            This event indicates this mapping. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParserState">
            <summary>
            KernelTraceEventParserState holds all information that is shared among all events that is
            needed to decode kernel events.   This class is registered with the source so that it will be
            persisted.  Things in here include
            
                * FileID to FileName mapping, 
                * ThreadID to ProcessID mapping
                * Kernel file name to user file name mapping 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParserState.FileIDToName(System.UInt64,System.UInt64,System.Int64)">
            <summary>
            If you have a file object (per-open-file) in addition to a fileKey, try using both 
            to look up the file name.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParserState.threadIDtoProcessIDRundown">
            <summary>
            This is for the circular buffer case.  In that case we may not have thread starts (and thus we don't
            have entries in threadIDtoProcessID).   Because HistoryTable finds the FIRST entry GREATER than the
            given threadID we NEGATE all times before we place it in this table.
            
            Also, because circular buffering is not the common case, we only add entries to this table if needed
            (if we could not find the thread ID using threadIDtoProcessID).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.KernelToUserDriveMapping">
            <summary>
            Keeps track of the mapping from kernel names to file system names (drives)  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.KernelToUserDriveMapping.#ctor">
            <summary>
            Create a new KernelToUserDriveMapping that can look up kernel names for drives and map them to windows drive letters. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.KernelToUserDriveMapping.Item(System.String)">
            <summary>
            Returns the string representing the windows drive letter for the kernel drive name 'kernelName'
            </summary>
            <param name="kernelName"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.EventTraceHeaderTraceData.UTCOffsetMinutes">
            <summary>
            This is the number of minutes between the local time where the data was collected and UTC time. 
            It does NOT take Daylight savings time into account.   
            It is positive if your time zone is WEST of Greenwich.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.ThreadTraceData.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that StartAddr and Win32StartAddr are a code addresses that needs symbolic information
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.CSwitchTraceData.NewThreadID">
            <summary>
            We report a context switch from from the new thread.  Thus NewThreadID == ThreadID.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.DiskIOTraceData.Irp">
            <summary>
            The I/O Response Packet address.  This represents the 'identity' of this particular I/O
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.DiskIOTraceData.HighResResponseTime">
            <summary>
            This is the time since the I/O was initiated, in source.PerfFreq (QPC) ticks.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.DiskIOTraceData.DiskServiceTimeMSec">
            <summary>
            This is the actual time the disk spent servicing this IO.   Same as elapsed time for real time providers.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.DiskIOTraceData.ElapsedTimeMSec">
            <summary>
            The time since the I/O was initiated.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.DiskIOFlushBuffersTraceData.HighResResponseTime">
            <summary>
            This is the time since the I/O was initiated, in source.PerfFreq (QPC) ticks.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.DiskIOFlushBuffersTraceData.ElapsedTimeMSec">
            <summary>
            The time since the I/O was initiated.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.FileIONameTraceData.FileKey">
            <summary>
            This is a handle that represents a file NAME (not an open file).   
            In the MSDN does this field is called FileObject.  However in other events FileObject is something
            returned from Create file and is different.  Events have have both (and some do) use FileKey.  Thus
            I use FileKey uniformly to avoid confusion.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.FileIOCreateTraceData.CreateOptions">
            <summary>
            See the Windows CreateFile API CreateOptions for this 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.FileIOCreateTraceData.CreateDisposition">
            <summary>
            See Windows CreateFile API CreateDisposition for this.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.FileIOCreateTraceData.FileAttributes">
            <summary>
            See Windows CreateFile API ShareMode parameter
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.FileIOCreateTraceData.ShareAccess">
            <summary>
            See windows CreateFile API ShareMode parameter
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.CreateDisposition">
            <summary>
            See Windows CreateFile function CreateDispostion parameter.
            The enum written to the ETW trace is the Disposition parameter passed to IoCreateFileSpecifyDeviceObjectHint.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.CreateOptions">
            <summary>
            See Windows CreateFile function FlagsAndAttributes parameter. 
            TODO FIX NOW: these have not been validated yet.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.FileIODirEnumTraceData.FileObject">
            <summary>
            The FileObject is the object for the Directory (used by CreateFile to open and passed to Close to close)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.FileIODirEnumTraceData.FileKey">
            <summary>
            The FileKey is the object that represents the name of the directory.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.ImageLoadTraceData.BuildTime">
            <summary>
            This is the TimeDateStamp converted to a DateTime
            TODO: daylight savings time seems to mess this up.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryPageFaultTraceData.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that ProgramCounter is a code address that needs symbolic information
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryHardFaultTraceData.ElapsedTimeMSec">
            <summary>
            The time spent during the page fault.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryPageAccessTraceData.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that the Address is a code address that needs symbolic information
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryProcessMemInfoTraceData">
            <summary>
            This event is emitted by the Microsoft-Windows-Kernel-Memory with Keyword 0x40  KERNEL_MEM_KEYWORD_MEMINFO_EX every .5 seconds
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryProcessMemInfoTraceData.Values(System.Int32)">
            <summary>
            Returns the edge at the given zero-based index (index less than Count).   The returned MemoryProcessMemInfoValues 
            points the the data in MemoryProcessMemInfoTraceData so it cannot live beyond that lifetime.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryProcessMemInfoTraceData.PayloadValue(System.Int32)">
            <summary>
            The fields after 'Count' are the first value in the array of working sets.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryProcessMemInfoValues">
            <summary>
            This structure just POINTS at the data in the MemoryProcessMemInfoTraceData.  It can only be used as long as
            the MemoryProcessMemInfoTraceData is alive which (unless you cloned it) is only for the lifetime of the callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemInfoTraceData.PayloadValue(System.Int32)">
            <summary>
            The fields after 'Count' are the first value in the array of working sets.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData.ExecutingDPC">
            <summary>
            Are we currently executing a Deferred Procedure Call (a mechanism the kernel uses to
            'steal' a thread to run its own work).  If this is true, the CPU time is really 
            not logically related to the process (it is kernel time).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData.ExecutingISR">
            <summary>
            Are we currently executing a Interrupt Service Routine?   Like ExecutingDPC if this
            is true the thread is really doing Kernel work, not work for the process.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData.NonProcess">
            <summary>
            NonProcess is true if ExecutingDPC or ExecutingISR is true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData.Priority">
            <summary>
            The thread's current priority (higher is more likely to run).   A normal thread with a normal base 
            priority is 8.   
            see http://msdn.microsoft.com/en-us/library/windows/desktop/ms685100(v=vs.85).aspx for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData.Rank">
            <summary>
            Your scheduling If the thread is not part of a scheduling group, this is 0 (see callout.c) 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that the Address is a code address that needs symbolic information
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.PMCCounterProfTraceData">
            <summary>
            PMC (Precise Machine Counter) events are fired when a CPU counter trips.  The the ProfileSource identifies
            which counter it is.   The PerfInfoCollectionStart events will tell you the count that was configured to trip
            the event.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.PMCCounterProfTraceData.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that Address is a code address that needs symbolic information
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SysCallEnterTraceData.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            Indicate that the Address is a code address that needs symbolic information
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData">
            <summary>
            Collects the call callStacks for some other event.
            
            (TODO: always for the event that preceded it on the same thread)?  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData.EventTimeStampQPC">
            <summary>
            The timestamp of the event which caused this stack walk using QueryPerformaceCounter
            cycles as the tick.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData.EventTimeStampRelativeMSec">
            <summary>
            Converts this to a time relative to the start of the trace in msec. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData.FrameCount">
            <summary>
            The total number of eventToStack frames collected.  The Windows OS currently has a maximum of 96 frames. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData.InstructionPointer(System.Int32)">
            <summary>
            Fetches the instruction pointer of a eventToStack frame 0 is the deepest frame, and the maximum should
            be a thread offset routine (if you get a complete stack).  
            </summary>
            <param name="index">The index of the frame to fetch.  0 is the CPU EIP, 1 is the Caller of that
            routine ...</param>
            <returns>The instruction pointer of the specified frame.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData.InstructionPointers">
            <summary>
            Access to the instruction pointers as a unsafe memory blob
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkStackTraceData.FixupData">
            <summary>
            StackWalkTraceData does not set Thread and process ID fields properly.  if that.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkRefTraceData">
            <summary>
            To save space, stack walks in Win8 can be complressed.  The stack walk event only has a 
            reference to a stack Key which is then looked up by StackWalkDefTraceData. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkRefTraceData.EventTimeStampQPC">
            <summary>
            The timestamp of the event which caused this stack walk using QueryPerformaceCounter
            cycles as the tick.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkRefTraceData.EventTimeStampRelativeMSec">
            <summary>
            Converts this to a time relative to the start of the trace in msec. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkRefTraceData.StackKey">
            <summary>
            Returns a key that can be used to look up the stack in KeyDelete or KeyRundown events 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkRefTraceData.FixupData">
            <summary>
            StackWalkTraceData does not set Thread and process ID fields properly.  if that.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkDefTraceData">
            <summary>
            This event defines a stack and gives it a unique id (the StackKey), which StackWalkRefTraceData can point at.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkDefTraceData.StackKey">
            <summary>
            Returns a key that can be used to look up the stack in KeyDelete or KeyRundown events 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkDefTraceData.FrameCount">
            <summary>
            The total number of eventToStack frames collected.  The Windows OS currently has a maximum of 96 frames. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkDefTraceData.InstructionPointer(System.Int32)">
            <summary>
            Fetches the instruction pointer of a eventToStack frame 0 is the deepest frame, and the maximum should
            be a thread offset routine (if you get a complete complete).  
            </summary>
            <param name="index">The index of the frame to fetch.  0 is the CPU EIP, 1 is the Caller of that
            routine ...</param>
            <returns>The instruction pointer of the specified frame.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkDefTraceData.InstructionPointers">
            <summary>
            Access to the instruction pointers as a unsafe memory blob
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SystemPathsTraceData.SystemDirectory">
            <summary>
            e.g. c:\windows\system32
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Kernel.SystemPathsTraceData.SystemWindowsDirectory">
            <summary>
            .e.g c:\windows
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.MicrosoftWindowsNDISPacketCapture.PacketFragmentArgs.AppendPrintable(System.Byte*,System.Byte*,System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Sees if up to 'max' bytes of frag-fragend is a printable string and if so prints it to 'sb' with 
            'prefix' before it.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser">
            <summary>
            Kernel traces have information about images that are loaded, however they don't have enough information
            in the events themselves to unambigously look up PDBs without looking at the data inside the images.
            This means that symbols can't be resolved unless you are on the same machine on which you gathered the data.
            
            XPERF solves this problem by adding new 'synthetic' events that it creates by looking at the trace and then
            opening each DLL mentioned and extracting the information needed to look PDBS up on a symbol server (this 
            includes the PE file's TimeDateStamp as well as a PDB Guid, and 'pdbAge' that can be found in the DLLs header.
            
            These new events are added when XPERF runs the 'merge' command (or -d flag is passed).  It is also exposed 
            through the KernelTraceControl.dll!CreateMergedTraceFile API.   
            
            SymbolTraceEventParser is a parser for extra events.   
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser.ImageIDDbgID_RSDS">
            <summary>
             The DbgIDRSDS event is added by XPERF for every Image load.  It contains the 'PDB signature' for the DLL, 
             which is enough to unambiguously look the image's PDB up on a symbol server.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser.ImageID">
            <summary>
            Every DLL has a Timestamp in the PE file itself that indicates when it is built.  This event dumps this timestamp.
            This timestamp is used to be as the 'signature' of the image and is used as a key to find the symbols, however 
            this has mostly be superseded by the DbgID/RSDS event. 
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser.ImageIDFileVersion">
            <summary>
            The FileVersion event contains information from the file version resource that most DLLs have that indicated
            detailed information about the exact version of the DLL.  (What is in the File->Properties->Version property
            page)
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser.ImageIDNone">
            <summary>
            I don't really care about this one, but I need a definition in order to exclude it because it
            has the same timestamp as a imageLoad event, and two events with the same timestamp confuse the 
            association between a stack and the event for the stack.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser.MetaDataEventInfo">
            <summary>
            This event has a TRACE_EVENT_INFO as its payload, and allows you to decode an event
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.Parsers.SymbolTraceEventParser.MetaDataEventMapInfo">
            <summary>
            The event describes a Map (bitmap or ValueMap), and has a payload as follows   
            
                GUID            ProviderId;  
                EVENT_MAP_INFO EventMapInfo;  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatXmlTraceData.Xml">
            <summary>
            The value of the one string payload property.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatXmlTraceData.#ctor(System.Action{Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatXmlTraceData},System.Int32,System.Int32,System.String,System.Guid,System.Int32,System.String,System.Guid,System.String)">
            <summary>
            Construct a TraceEvent template which has one string payload field with the given metadata and action
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatXmlTraceData.ToXml(System.Text.StringBuilder)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatXmlTraceData.PayloadNames">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatXmlTraceData.PayloadValue(System.Int32)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatXmlTraceData.Dispatch">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.Symbol.WinSatXmlTraceData.Target">
            <summary>
            override
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser">
            <summary>
            RegisteredTraceEventParser uses the standard windows provider database (TDH, what gets registered with wevtutil)
            to find the names of events and fields of the events).   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.#ctor(Microsoft.Diagnostics.Tracing.TraceEventSource,System.Boolean)">
            <summary>
            Create a new RegisteredTraceEventParser and attach it to the given TraceEventSource
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.GetManifestForRegisteredProvider(System.String)">
            <summary>
            Given a provider name that has been registered with the operating system, get
            a string representing the ETW manifest for that provider.    Note that this
            manifest is not as rich as the original source manifest because some information
            is not actually compiled into the binary manifest that is registered with the OS.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.GetManifestForRegisteredProvider(System.Guid)">
            <summary>
            Given a provider GUID that has been registered with the operating system, get
            a string representing the ETW manifest for that provider.    Note that this
            manifest is not as rich as the original source manifest because some information
            is not actually compiled into the binary manifest that is registered with the OS.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.GetKeywordStr(System.Collections.Generic.SortedDictionary{System.UInt64,System.String},System.UInt64)">
            <summary>
            Generates a space separated list of set of keywords 'keywordSet' using the table 'keywords'
            It will generate new keyword names if needed and add them to 'keywords' if they are not present.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TaskInfo">
            <summary>
            Class used to accumulate information about Tasks in the implementation of GetManifestForRegisteredProvider
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TryLookupWorker(Microsoft.Diagnostics.Tracing.TraceEvent,System.Collections.Generic.Dictionary{Microsoft.Diagnostics.Tracing.Parsers.MapKey,System.Collections.Generic.IDictionary{System.Int64,System.String}})">
            <summary>
            Try to look up 'unknonwEvent using TDH or the TraceLogging mechanism.   if 'mapTable' is non-null it will be used
            look up the string names for fields that have bitsets or enumerated values.   This is only need for the KernelTraceControl
            case where the map information is logged as special events and can't be looked up with TDH APIs.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TdhEventParser">
            <summary>
            TdhEventParser takes the Trace Diagnostics Helper (TDH) TRACE_EVENT_INFO structure and
            (passed as a byte*) and converts it to a DynamicTraceEventData which which 
            can be used to parse events of that type.   You first create TdhEventParser and then
            call ParseEventMetaData to do the parsing.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TdhEventParser.#ctor(System.Byte*,Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_RECORD*,System.Collections.Generic.Dictionary{Microsoft.Diagnostics.Tracing.Parsers.MapKey,System.Collections.Generic.IDictionary{System.Int64,System.String}})">
            <summary>
            Creates a new parser from the TRACE_EVENT_INFO held in 'buffer'.  Use
            ParseEventMetaData to then parse it into a DynamicTraceEventData structure.
             EventRecord can be null and mapTable if present allow the parser to resolve maps (enums), and can be null.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TdhEventParser.ParseEventMetaData">
            <summary>
            Actually performs the parsing of the TRACE_EVENT_INFO passed in the constructor
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.RegisteredTraceEventParser.TdhEventParser.ParseFields(System.Int32,System.Int32)">
            <summary>
            Parses at most 'maxFields' fields starting at the current position.  
            Will return the parse fields in 'payloadNamesRet' and 'payloadFetchesRet'
            Will return true if successful, false means an error occurred.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser">
            <summary>
            ExternalTraceEventParser is an abstract class that acts as a parser for any 'External' resolution
            This include the TDH (RegisteredTraceEventParser) as well as the WPPTraceEventParser.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser.#ctor(Microsoft.Diagnostics.Tracing.TraceEventSource,System.Boolean)">
            <summary>
            Create a new ExternalTraceEventParser and attach it to the given TraceEventSource
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser.IsStatic">
            <summary>
            Override.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser.GetProviderName">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser.HasDefinitionForTemplate(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Returns true if the RegisteredTraceEventParser would return 'template' in EnumerateTemplates
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser.EnumerateTemplates(System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Action{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            override
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParser.OnNewEventDefintion(Microsoft.Diagnostics.Tracing.TraceEvent,System.Boolean)">
            <summary>
            Register 'template' so that if there are any subscriptions to template they get registered with the source.    
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.MapKey">
            <summary>
            Used to look up Enums (provider x enumName);  Very boring class.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParserState">
            <summary>
            TDHDynamicTraceEventParserState represents the state of a  TDHDynamicTraceEventParser that needs to be
            serialized to a log file.  It does NOT include information about what events are chosen but DOES contain
            any other necessary information that came from the ETL data file or the OS TDH APIs.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParserState.TraceEventComparer">
            <summary>
            This defines what it means to be the same event.   For manifest events it means provider and event ID
            for classic, it means that taskGuid and opcode match.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParserState.ToStream(FastSerialization.Serializer)">
            <summary>
            Implements IFastSerializable interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.ExternalTraceEventParserState.FromStream(FastSerialization.Deserializer)">
            <summary>
            Implements IFastSerializable interface
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Parsers.WppTraceEventParser">
            <summary>
            This parser knows how to decode Windows Software Trace Preprocessor (WPP) events.  In order to decode
            the events it needs access to the TMF files that describe the events (these are created from the PDB at 
            build time). 
            <br/>
            You will generally use this for the 'FormattedMessage' property of the event.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.WppTraceEventParser.#ctor(Microsoft.Diagnostics.Tracing.TraceEventSource,System.String)">
            <summary>
            Construct a new WPPTraceEventParser that is attached to 'source'.   Once you do this the source
            will understand WPP events. In particular you can subscribe to the  Wpp.All event to get the
            stream of WPP events in the source. For WppTraceEventParser to function, it needs the TMF
            files for the events it will decode. You should pass the directory to find these TMF files 
            in 'TMFDirectory'.  Each file should have the form of a GUID.tmf.   
            </summary>
            <param name="source"></param>
            <param name="TMFDirectory"></param>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource">
            <summary>
            ETWReloggerTraceEventSource is designed to be able to write ETW files using an existing ETW input stream (either a file, files or real time session) as a basis. 
            The relogger capabilities only exist on Windows 8 OSes and beyond.  
            
            The right way to think about this class is that it is just like ETWTraceEventSource, but it also has a output file associated with it, and WriteEvent APIs that
            can be used to either copy events from the event stream (the common case), or inject new events (high level stats).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.#ctor(System.String,System.String)">
            <summary>
            Create an ETWReloggerTraceEventSource that can takes its input from the family of etl files inputFileName
            and can write them to the ETL file outputFileName (.kernel*.etl, .user*.etl .clr*.etl)
            
            This is a shortcut for  ETWReloggerTraceEventSource(inputFileName, TraceEventSourceType.MergeAll, outputFileStream)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.#ctor(System.String,Microsoft.Diagnostics.Tracing.TraceEventSourceType,System.String)">
            <summary>
            Create an ETWReloggerTraceEventSource that can takes its input from a variety of sources (either a single file,
            a set of files, or a real time ETW session (based on 'type'), and can write these events to a new ETW output
            file 'outputFileName. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.OutputUsesCompressedFormat">
            <summary>
            The output file can use a compressed form or not.  Compressed forms can only be read on Win8 and beyond.   Defaults to true.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.WriteEvent(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Writes an event from the input stream to the output stream of events. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.ConnectEventSource(System.Diagnostics.Tracing.EventSource)">
            <summary>
            Connect the given EventSource so any events logged from it will go to the output stream of events.   
            Once connected, you may only write events from this EventSource while processing the input stream
            (that is during the callback of an input stream event), because the context for the EventSource event
            (e.g. timestamp, proesssID, threadID ...) will be derived from the current event being processed by
            the input stream.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.WriteEvent(System.Guid,TraceReloggerLib._EVENT_DESCRIPTOR@,Microsoft.Diagnostics.Tracing.TraceEvent,System.Object[])">
            <summary>
            Writes an event that did not exist previously into the data stream, The context data (time, process, thread, activity, comes from 'an existing event') 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.WriteEvent(System.Guid,TraceReloggerLib._EVENT_DESCRIPTOR@,System.DateTime,System.Int32,System.Int32,System.Int32,System.Guid,System.Object[])">
            <summary>
            Writes an event that did not exist previously into the data stream, The context data (time, process, thread, activity, comes from 'an existing event') is given explicitly
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.EventsLost">
            <summary>
            implementing TraceEventDispatcher
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.Process">
            <summary>
            implementing TraceEventDispatcher
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.Dispose(System.Boolean)">
            <summary>
            Implements TraceEventDispatcher.Dispose
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.StopProcessing">
            <summary>
            Implements TraceEventDispatcher.StopProcessing
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.ReloggerEventListener">
            <summary>
            This is used by the ConnectEventSource to route events from the EventSource to the relogger. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWReloggerTraceEventSource.ReloggerCallbacks">
            <summary>
            This is the class the Win32 APIs call back on.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWTraceEventSource">
            <summary>
            A ETWTraceEventSource represents the stream of events that was collected from a
            TraceEventSession (eg the ETL moduleFile, or the live session event stream). Like all
            TraceEventSource, it logically represents a stream of TraceEvent s. Like all
            TraceEventDispathers it supports a callback model where Parsers attach themselves to this
            sources, and user callbacks defined on the parsers are called when the 'Process' method is called.
            
            * See also TraceEventDispatcher
            * See also TraceEvent
            * See also #ETWTraceEventSourceInternals
            * See also #ETWTraceEventSourceFields
            </summary>    
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.#ctor(System.String)">
            <summary>
            Open a ETW event trace moduleFile (ETL moduleFile) for processing.  
            </summary>
            <param name="fileName">The ETL data moduleFile to open</param>` 
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.#ctor(System.String,Microsoft.Diagnostics.Tracing.TraceEventSourceType)">
            <summary>
            Open a ETW event source for processing.  This can either be a moduleFile or a real time ETW session
            </summary>
            <param name="fileOrSessionName">
            If type == ModuleFile this is the name of the moduleFile to open.
            If type == Session this is the name of real time session to open.</param>
            <param name="type"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.#ctor(System.Collections.Generic.IEnumerable{System.String},Microsoft.Diagnostics.Tracing.TraceEventSourceType)">
            <summary>
            Open multiple etl files as one trace for processing.
            </summary>
            <param name="fileNames"></param>
            <param name="type">If type == MergeAll, call Initialize.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Process all the files in 'fileNames' in order (that is all the events in the first
            file are processed, then the second ...).   Intended for parsing the 'Multi-File' collection mode. 
            </summary>
            <param name="fileNames">The list of files path names to process (in that order)</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.Process">
            <summary>
            Processes all the events in the data source, issuing callbacks that were subscribed to.  See
            #Introduction for more
            </summary>
            <returns>false If StopProcesing was called</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ReprocessEvent(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Reprocess a pre-constructed event which this processor has presumably created. Helpful to re-examine
            "unknown" events, perhaps after a manifest has been received from the ETW stream.
            Note when queuing events to reprocess you must <see cref="M:Microsoft.Diagnostics.Tracing.TraceEvent.Clone">Clone</see> them first
            or certain internal data may no longer be available and you may receive memory access violations.
            </summary>
            <param name="ev">Event to re-process.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.LogFileName">
            <summary> 
            The log moduleFile that is being processed (if present)
            TODO: what does this do for Real time sessions?
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.SessionName">
            <summary>
            The name of the session that generated the data. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.Size">
            <summary>
            The size of the log, will return 0 if it does not know. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.EventsLost">
            <summary>
            returns the number of events that have been lost in this session.    Note that this value is NOT updated
            for real time sessions (it is a snapshot).  Instead you need to use the TraceEventSession.EventsLost property. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.CanReset">
            <summary>
            Returns true if the Process can be called multiple times (if the Data source is from a
            moduleFile, not a real time stream.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.SynchronizeClock">
            <summary>
            This routine is only useful/valid for real-time sessions.  
            
            TraceEvent.TimeStamp internally is stored using a high resolution clock called the Query Performance Counter (QPC).
            This clock is INDEPENDENT of the system clock used by DateTime.   These two clocks are synchronized to within 2 msec at 
            session startup but they can drift from there (typically 2msec / min == 3 seconds / day).   Thus if you have long
            running real time session it becomes problematic to compare the timestamps with those in another session or something
            timestamped with the system clock.   SynchronizeClock will synchronize the TraceEvent.Timestamp clock with the system
            clock again.   If you do this right before you start another session, then the two sessions will be within 2 msec of
            each other, and their timestamps will correlate.     Doing it periodically (e.g. hourly), will keep things reasonably close.  
            
            TODO: we can achieve perfect synchronization by exposing the QPC tick sync point so we could read the sync point 
            from one session and set that exact sync point for another session.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ModuleSymbolOptions">
            <summary>
            Options that can be passed to GetModulesNeedingSymbols
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ModuleSymbolOptions.OnlyNGENImages">
            <summary>
            This is the default, where only NGEN images are included (since these are the only images whose PDBS typically
            need to be resolved aggressively AT COLLECTION TIME)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ModuleSymbolOptions.IncludeUnmanagedModules">
            <summary>
            If set, this option indicates that non-NGEN images should also be included in the list of returned modules
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ModuleSymbolOptions.IncludeModulesWithOutSamples">
            <summary>
            Normally only modules what have a CPU or stack sample are included in the list of assemblies (thus you don't 
            unnecessarily have to generate NGEN PDBS for modules that will never be looked up).  However if there are 
            events that have addresses that need resolving that this routine does not recognise, this option can be
            set to insure that any module that was event LOADED is included.   This is inefficient, but guaranteed to
            be complete
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.GetModulesNeedingSymbols(System.String,Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ModuleSymbolOptions)">
            <summary>
            Given an ETL file, returns a list of the full paths to DLLs that were loaded in the trace that need symbolic 
            information (PDBs) so that the stack traces and CPU samples can be properly resolved.   By default this only
            returns NGEN images since these are the ones that need to be resolved and generated at collection time.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.ImageData">
            <summary>
            Image data is a trivial record for image data, where it is keyed by the base address, processID and name.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.GetOSPointerSize">
            <summary>
            Returns the size of pointer (8 or 4) for the operating system (not necessarily the process) 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.QPCTime">
            <summary>
            This is a little helper class that maps QueryPerformanceCounter (QPC) ticks to DateTime.  There is an error of
            a few msec, but as long as every one uses the same one, we probably don't care.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.Dispose(System.Boolean)">
            <summary>
            see Dispose pattern
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.Finalize">
            <summary>
            see Dispose pattern
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ETWTraceEventSource.lockObj">
            <summary>
            Used by real time TraceLog on Windows7.   
            If we have several real time sources we have them coming in on several threads, but we want the illusion that they
            are one source (thus being processed one at a time).  Thus we want a lock that is taken on every dispatch.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventSourceType">
            <summary>
            The kinds of data sources that can be opened (see ETWTraceEventSource)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventSourceType.MergeAll">
            <summary>
            Look for any files like *.etl or *.*.etl (the later holds things like *.kernel.etl or *.clrRundown.etl ...)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventSourceType.FileOnly">
            <summary>
            Look for a ETL moduleFile *.etl as the event data source 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventSourceType.Session">
            <summary>
            Use a real time session as the event data source.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EventPipe.EventCache.Flush">
            <summary>
            After all events have been parsed we could have some straglers that weren't
            earlier than any sorted event. Sort and dispatch those now.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EventPipe.ClrThreadStackWalkTraceData.InstructionPointer(System.Int32)">
            <summary>
            Fetches the instruction pointer of a eventToStack frame 0 is the deepest frame, and the maximum should
            be a thread offset routine (if you get a complete eventToStack).  
            </summary>
            <param name="index">The index of the frame to fetch.  0 is the CPU EIP, 1 is the Caller of that
            routine ...</param>
            <returns>The instruction pointer of the specified frame.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.EventPipe.ClrThreadStackWalkTraceData.InstructionPointers">
            <summary>
            Access to the instruction pointers as a unsafe memory blob
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventPipeEventSource">
             <summary>
             EventPipeEventSource knows how to decode EventPipe (generated by the .NET core runtime).
             Please see <see href="https://github.com/Microsoft/perfview/blob/master/src/TraceEvent/EventPipe/EventPipeFormat.md" />for details on the file format.
            
             By conventions files of such a format are given the .netperf suffix and are logically
             very much like a ETL file in that they have a header that indicate things about
             the trace as a whole, and a list of events.    Like more modern ETL files the
             file as a whole is self-describing.    Some of the events are 'MetaData' events
             that indicate the provider name, event name, and payload field names and types.
             Ordinary events then point at these meta-data event so that logically all
             events have a name some basic information (process, thread, timestamp, activity
             ID) and user defined field names and values of various types.
             </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.EventPipeEventSource.Version">
            <summary>
            This is the version number reader and writer (although we don't don't have a writer at the moment)
            It MUST be updated (as well as MinimumReaderVersion), if breaking changes have been made.
            If your changes are forward compatible (old readers can still read the new format) you
            don't have to update the version number but it is useful to do so (while keeping MinimumReaderVersion unchanged)
            so that readers can quickly determine what new content is available.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.EventPipeEventSource.MinimumReaderVersion">
            <summary>
            This field is only used for writers, and this code does not have writers so it is not used.
            It should be set to Version unless changes since the last version are forward compatible
            (old readers can still read this format), in which case this should be unchanged.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.EventPipeEventSource.MinimumVersionCanRead">
            <summary>
            This is the smallest version that the deserializer here can read.   Currently
            we are careful about backward compat so our deserializer can read anything that
            has ever been produced.   We may change this when we believe old writers basically
            no longer exist (and we can remove that support code).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EventPipeEventSource.ParseEventParameters(Microsoft.Diagnostics.Tracing.Parsers.DynamicTraceEventData,Microsoft.Diagnostics.Tracing.EventPipeEventMetaDataHeader,FastSerialization.PinnedStreamReader,FastSerialization.StreamLabel,Microsoft.Diagnostics.Tracing.NetTraceFieldLayoutVersion)">
            <summary>
            Given the EventPipe metaData header and a stream pointing at the serialized meta-data for the parameters for the
            event, create a new  DynamicTraceEventData that knows how to parse that event.
            ReaderForParameters.Current is advanced past the parameter information.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventPipeBlock">
            <summary>
            The Nettrace format is divided up into various blocks - this is a base class that handles the common
            aspects for all of them.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventPipeEventBlock">
            <summary>
            An EVentPipeEventBlock represents a block of events.   It basically only has
            one field, which is the size in bytes of the block.  But when its FromStream
            is called, it will perform the callbacks for the events (thus deserializing
            it performs dispatch).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventPipeMetadataBlock">
            <summary>
            A block of metadata carrying events. These 'events' aren't dispatched by EventPipeEventSource - they carry
            the metadata that allows the payloads of non-metadata events to be decoded.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventPipeSequencePointBlock">
            <summary>
            An EventPipeSequencePointBlock represents a stream divider that contains
            updates for all thread event sequence numbers, indicates that all queued
            events can be sorted and dispatched, and that all cached events/stacks can
            be flushed.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventPipeStackBlock">
            <summary>
            An EventPipeStackBlock represents a block of interned stacks. Events refer
            to stacks by an id.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventPipeEventMetaDataHeader">
             <summary>
             Private utility class.
            
             An EventPipeEventMetaDataHeader holds the information that can be shared among all
             instances of an EventPipe event from a particular provider.   Thus it contains
             things like the event name, provider, It however does NOT contain the data
             about the event parameters (the names of the fields and their types), That is
             why this is a meta-data header and not all the meta-data.
            
             This class has two main functions
                1. The constructor takes a PinnedStreamReader and decodes the serialized metadata
                   so you can access the data conveniently (but it does not decode the parameter info)
                2. It remembers a EVENT_RECORD structure (from ETW) that contains this data)
                   and has a function GetEventRecordForEventData which converts from a
                   EventPipeEventHeader (the raw serialized data) to a EVENT_RECORD (which
                   is what TraceEvent needs to look up the event an pass it up the stack.
             </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EventPipeEventMetaDataHeader.#ctor(FastSerialization.PinnedStreamReader,System.Int32,Microsoft.Diagnostics.Tracing.EventPipeMetaDataVersion,System.Int32,System.Int32,System.Int32,System.String)">
             <summary>
             Creates a new MetaData instance from the serialized data at the current position of 'reader'
             of length 'length'.   This typically points at the PAYLOAD AREA of a meta-data events)
             'fileFormatVersionNumber' is the version number of the file as a whole
             (since that affects the parsing of this data) and 'processID' is the process ID for the
             whole stream (since it needs to be put into the EVENT_RECORD.
            
             When this constructor returns the reader has read up to the serialized information about
             the parameters.  We do this because this code does not know the best representation for
             this parameter information and so it just lets other code handle it.
             </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EventPipeEventMetaDataHeader.GetEventRecordForEventData(Microsoft.Diagnostics.Tracing.EventPipeEventHeader@)">
            <summary>
            Given a EventPipeEventHeader takes a EventPipeEventHeader that is specific to an event, copies it
            on top of the static information in its EVENT_RECORD which is specialized meta-data
            and returns a pointer to it.  Thus this makes the EventPipe look like an ETW provider from
            the point of view of the upper level TraceEvent logic.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.EventPipeEventMetaDataHeader.MetaDataId">
            <summary>
            This is a number that is unique to this meta-data blob.  It is expected to be a small integer
            that starts at 1 (since 0 is reserved) and increases from there (thus an array can be used).
            It is what is matched up with EventPipeEventHeader.MetaDataId
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EventPipeEventMetaDataHeader.ReadNetTraceMetadata(FastSerialization.PinnedStreamReader)">
            <summary>
            Reads the meta data for information specific to one event.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventPipeEventHeader">
             <summary>
             Private utility class.
            
             At the start of every event from an EventPipe is a header that contains
             common fields like its size, threadID timestamp etc.  EventPipeEventHeader
             is the layout of this.  Events have two variable sized parts: the user
             defined fields, and the stack.   EventPipEventHeader knows how to
             decode these pieces (but provides no semantics for it.
            
             It is not a public type, but used in low level parsing of EventPipeEventSource.
             </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EventPipeEventHeader.GetTotalEventSize(System.Byte*,System.Int32)">
            <summary>
            Size of the event header + stack + payload (includes EventSize field itself)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EventPipeEventHeader.GetHeaderSize(System.Int32)">
            <summary>
            Header Size is defined to be the number of bytes before the Payload bytes.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.CallTree">
            <summary>
            SampleInfos of a set of stackSource by eventToStack.  This represents the entire call tree.   You create an empty one in using
            the default constructor and use 'AddSample' to add stackSource to it.   You traverse it by 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.#ctor(Microsoft.Diagnostics.Tracing.Stacks.ScalingPolicyKind)">
            <summary>
            Creates an empty call tree, indicating the scaling policy of the metric.   You populate it by assigning a StackSOurce to the tree.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.StackSource">
            <summary>
            A CallTree is generated from a StackSource.  Setting the StackSource causes the tree to become populated.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.PercentageBasis">
            <summary>
            When calculating percentages, the PercentageBasis do we use as 100%.  By default we use the
            Inclusive time for the root, but that can be changed here.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.Root">
            <summary>
            Returns the root node of the call tree.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.NodeIndexLimit">
            <summary>
            An upper bound for the node indexes in the call tree.  (All indexes
            are strictly less than this number)   Thus ASSSUMING YOU DON'T ADD
            NEW NODES, an array of this size can be used to index the nodes (and 
            thus lookup nodes by index or to store additional information about a node).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.CallerCallee(System.String)">
            <summary>
            Get a CallerCalleeNode for the nodes in the call tree named 'nodeName'
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.ByID">
            <summary>
            Returns a list of nodes that have statistics rolled up by treeNode by ID.  It is not
            sorted by anything in particular.   Note that ID is not quite the same thing as the 
            name.  You can have two nodes that have different IDs but the same Name.  These 
            will show up as two distinct entries in the resulting list.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.ByIDSortedExclusiveMetric">
            <summary>
            Returns the list returned by the ByID property sorted by exclusive metric.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.FoldNodesUnder(System.Single,System.Boolean)">
            <summary>
            If there are any nodes that have strictly less than to 'minInclusiveMetric'
            then remove the node, placing its samples into its parent (thus the parent's
            exclusive metric goes up).  
            
            If useWholeTraceMetric is true, nodes are only folded if their inclusive metric
            OVER THE WHOLE TRACE is less than 'minInclusiveMetric'.  If false, then a node
            is folded if THAT NODE has less than the 'minInclusiveMetric'  
            
            Thus if 'useWholeTraceMetric' == false then after calling this routine no
            node will have less than minInclusiveMetric.  
            
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.Sort(System.Collections.Generic.IComparer{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode})">
            <summary>
            Cause the children of each CallTreeNode in the CallTree to be sorted (accending) based on comparer
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.SortInclusiveMetricDecending">
            <summary>
            Sorting by InclusiveMetric Decending is so common, provide a shortcut.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.ScalingPolicy">
            <summary>
            When converting the InclusiveMetricByTime to a InclusiveMetricByTimeString you have to decide 
            how to scale the samples to the digits displayed in the string.  This enum indicates this policy
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.TimeHistogramController">
            <summary>
            The nodes in the calltree have histograms in time, all of these histograms share a controller that
            contains sharable information.   This propertly returns that TimeHistogramController
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.ScenarioHistogram">
            <summary>
            The nodes in the calltree have histograms indexed by scenario (which is user defiend), 
            all of these histograms share a controller that contains sharable information.   
            This propertly returns that ScenarioHistogramController
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTree.DisableParallelism">
            <summary>
            Turns off logic for computing call trees in parallel.   Safer but slower.  
            </summary>
            <remarks>
            <para>This is off by default following indications of race conditions.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.FreeMemory">
            <summary>
            Break all links in the call tree to free as much memory as possible.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.ToXml(System.IO.TextWriter)">
            <summary>
            Write an XML representtaion of the CallTree to 'writer'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.ToString">
            <summary>
            An XML representtaion of the CallTree (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTree.AccumulateSumByID(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode,System.Collections.Generic.Dictionary{System.Int32,Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase},Microsoft.Diagnostics.Tracing.Stacks.RecursionGuard)">
            <summary>
            Traverse the subtree of 'treeNode' into the m_sumByID dictionary.   We don't want to
            double-count inclusive times, so we have to keep track of all callers currently on the
            stack and we only add inclusive times for nodes that are not already on the stack.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.ScalingPolicyKind">
            <summary>
            ScalingPolicyKind represents the desired way to scale the metric in the samples.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.ScalingPolicyKind.ScaleToData">
            <summary>
            This is the default.  In this policy, 100% is chosen so that the histogram is scaled as best it can.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.ScalingPolicyKind.TimeMetric">
            <summary>
            It assumes that the metric represents time 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeIndex">
            <summary>
            Represents a unique ID for a node in a call tree.  Can be used to look up a call tree node easily.  
            It is a dense value (from 0 up to a maximum).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeIndex.Invalid">
            <summary>
            An Invalid Node Index.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase">
            <summary>
            A  CallTreeNodeBase is the inforation in a CallTreeNode without parent or child relationships.  
            ByName nodes and Caller-Callee nodes need this because they either don't have or need different 
            parent-child relationships. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.Index">
            <summary>
            Returns a unique small, dense number (suitable for looking up in an array) that represents 
            this call tree node (unlike the ID, which more like the name of the frame of the node), so you
            can have many nodes with the same name, but only one with the same index.    See CallTree.GetNodeIndexLimit.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.#ctor(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase)">
            <summary>
            Create a CallTreeNodeBase (a CallTreeNode without children) which is a copy of another one.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.Name">
            <summary>
            The Frame name that this tree node represents.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.DisplayName">
            <summary>
            Currently the same as Name, but could contain additional info.  
            Suitable for display but not for programmatic comparison.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ID">
             <summary>
             The ID represents a most fine grained uniqueness associated with this node.   It can represent
             a method, but for sources that support 'goto source' functionality these IDs actually represent
             particular lines (or more precisely program counter locations), within the method.    Thus it is 
             very likely that there are call tree nodes that have the same name but different IDs.  
             
             This can be StackSourceFrameIndex.Invalid for Caller-callee nodes (which have names, but no useful ID) 
            
             If ID != Invalid, and the IDs are the same then the names are guaranteed to be the same.  
             </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveMetric">
            <summary>
            The sum of the metric of all samples that are in this node or any child of this node (recursively)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.AverageInclusiveMetric">
            <summary>
            The average metric of all samples that are in this node or any child of this node (recursively).
            This is simply InclusiveMetric / InclusiveCount.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ExclusiveMetric">
            <summary>
            The sum of the metric of all samples that are in this node 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ExclusiveFoldedMetric">
            <summary>
            The sum of the metric of all samples in this node that are there because they were folded (inlined).   It is always less than or equal to ExclusiveMetric.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveCount">
            <summary>
            The sum of the count of all samples that are in this node or any child of this node (recursively)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ExclusiveCount">
            <summary>
            The sum of the count of all samples that are in this node 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ExclusiveFoldedCount">
            <summary>
            The sum of the count of all samples in this node that are there because they were folded (inlined).   It is always less than or equal to ExclusiveCount.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveMetricPercent">
            <summary>
            The inclusive metric, normalized to the total metric for the entire tree.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ExclusiveMetricPercent">
            <summary>
            The exclusive metric, normalized to the total metric for the entire tree.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ExclusiveFoldedMetricPercent">
            <summary>
            The exclusive folded metric, normalized to the total metric for the entire tree.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.FirstTimeRelativeMSec">
            <summary>
            The time of the first sample for this node or any of its children (recursively)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.FirstTimeRelMSec">
            <summary>
            The time of the first sample for this node or any of its children (recursively)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.LastTimeRelativeMSec">
            <summary>
            The time of the last sample for this node or any of its children (recursively)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.LastTimeRelMSec">
            <summary>
            The time of the last sample for this node or any of its children (recursively)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.DurationMSec">
            <summary>
            The difference between the first and last sample (in MSec).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.CallTree">
            <summary>
            The call tree that contains this node.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveMetricByTime">
            <summary>
            Returns the histogram that groups of samples associated with this node or any of its children by time buckets
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveMetricByTimeString">
            <summary>
            Returns a string that represents the InclusiveMetricByTime Histogram by using character for every bucket (like PerfView)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveMetricByScenario">
            <summary>
            Returns the histogram that groups of samples associated with this node or any of its children by scenario buckets
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.InclusiveMetricByScenarioString">
            <summary>
            Returns a string that represents the InclusiveMetricByScenario Histogram by using character for every bucket (like PerfView)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.GetSamples(System.Boolean,System.Func{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex,System.Boolean})">
            <summary>
            Returns all the original stack samples in this node.  If exclusive==true then just he
            sample exclusively in this node are returned, otherwise it is the inclusive samples.   
            
            If the original stack source that was used to create this CodeTreeNode was a FilterStackSource
            then that filtering is removed in the returned Samples.  
            
            Returns the total number of samples (the number of times 'callback' is called)
            
            If the callback returns false, the iteration over samples stops. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.GetTrees(System.Action{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode})">
            <summary>
            While 'GetSamples' can return all the samples in the tree, this is a relatively
            inefficient way of representing the samples.   Instead you can return a list of
            trees whose samples represent all the samples.   This is what GetTrees does.
            It calls 'callback' on a set of trees that taken as a whole have all the samples
            in 'node'.  
            
            Note you ave to be careful when using this for inclusive summation of byname nodes because 
            you will get trees that 'overlap' (bname nodes might refer into the 'middle' of another
            call tree).   This can be avoided pretty easily by simply stopping inclusive traversal 
            whenever a tree node with that ID occurs (see GetSamples for an example). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ToXmlAttribs(System.IO.TextWriter)">
            <summary>
            Returns a string representing the set of XML attributes that can be added to another XML element.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.ToString">
            <summary>
            An XML representation of the CallTreeNodeBase (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.FreeMemory">
            <summary>
            The GUI sadly holds on to Call things in the model in its cache, and call tree nodes have linkes to whole
            call tree.  To avoid the GUI cache from holding on to the ENTIRE MODEL, we neuter the nodes when we are
            done with them so that even if they are pointed to by the GUI cache it does not hold onto most of the 
            (dead) model.    FreeMemory does this neutering.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.CombineByIdSamples(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Combines the 'this' node with 'otherNode'.   If 'newOnStack' is true, then the inclusive
            metrics are also updated.  
            
            Note that I DON'T accumulate other.m_samples into this.m_samples.   This is because we want to share
            samples as much a possible.  Thus nodes remember their samples by pointing at other call trees
            and you fetch the samples by an inclusive walk of the tree.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase.GetSamplesForTreeNode(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode,System.Boolean,System.Func{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex,System.Boolean},Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex)">
            <summary>
            To avoid double-counting for byname nodes, with we can be told to exclude any children with a particular ID 
            (the ID of the ByName node itself) if are doing the inclusive case.   The goal is to count every reachable
            tree exactly once.  We do this by conceptually 'marking' each node with ID at the top level (when they are 
            enumerated as children of the Byname node), and thus any node with that excludeChildrenWithID is conceptually
            marked if you encounter it as a child in the tree itself (so you should exclude it).  The result is that 
            every node is visited exactly once (without the expense of having a 'visited' bit).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode">
            <summary>
            Represents a single treeNode in a CallTree 
            
            Each node keeps all the sample with the same path to the root.  
            Each node also remembers its parent (caller) and children (callees).
            The nodes also keeps the IDs of all its samples (so no information
            is lost, just sorted by stack).   You get at this through the
            CallTreeNodeBase.GetSamples method.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.Caller">
            <summary>
            The caller (parent) of this node
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.Callees">
            <summary>
            The nodes this node calls (its children). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.IsLeaf">
            <summary>
            Returns true if Callees is empty.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.AllCallees">
            <summary>
            AllCallees is an extension of CallTreesNodes to support graphs (e.g. memory heaps).   
            It always starts with the 'normal' Callees, however in addition if we are
            displaying a Graph, it will also children that were 'pruned' when the graph was 
            transformed into a tree.  (by using StackSource.GetRefs).   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.HasChildren">
            <summary>
            Returns true if AllCallees is non-empty.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.IsGraphNode">
            <summary>
            Returns true if the call trees came from a graph (thus AllCallees may be strictly larger than Callees)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.ToXml(System.IO.TextWriter,System.String)">
            <summary>
            Writes an XML representation of the call tree Node  it 'writer'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.ToString">
            <summary>
            Returns an XML representation of the call tree Node (for debugging);
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.GetBrokenStackCount">
            <summary>
            Adds up the counts of all nodes called 'BROKEN' nodes in a particular tree node
            
            This is a utility function.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.IndentString(System.Boolean)">
            <summary>
            Creates a string that has spaces | and + signs that represent the indentation level 
            for the tree node.  (Called from XAML)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.FreeMemory(System.Collections.Generic.Stack{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase})">
            <summary>
            Implements CallTreeNodesBase interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.SortAll(System.Collections.Generic.IComparer{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode},Microsoft.Diagnostics.Tracing.Stacks.RecursionGuard)">
            <summary>
            Sort the childre of every node in the te
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.GetCallees">
            <summary>
            Some calltrees already fill in their children, others do so lazily, in which case they 
            override this method.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode.FoldNodesUnder(System.Single,System.Collections.Generic.Dictionary{System.Int32,Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase})">
            <summary>
            Fold away any nodes having less than 'minInclusiveMetric'.  If 'sumByID' is non-null then the 
            only nodes that have a less then the minInclusiveMetric for the whole trace are folded. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode">
            <summary>
            A CallerCalleeNode gives statistics that focus on a NAME.  (unlike calltrees that use ID)
            It takes all stackSource that have callStacks that include that treeNode and compute the metrics for
            all the callers and all the callees for that treeNode.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.#ctor(System.String,Microsoft.Diagnostics.Tracing.Stacks.CallTree)">
            <summary>
            Given a complete call tree, and a Name within that call tree to focus on, create a
            CallerCalleeNode that represents the single Caller-Callee view for that treeNode. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.Callers">
            <summary>
            The list of CallTreeNodeBase nodes that called the method represented by this CallerCalleeNode
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.Callees">
            <summary>
            The list of CallTreeNodeBase nodes that where called by the method represented by this CallerCalleeNode
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.ToXml(System.IO.TextWriter,System.String)">
            <summary>
            wrtites an XML representation of the call tree Node  it 'writer'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.ToString">
            <summary>
            Returns an XML representation of the CallerCalleeNode (for debugging);
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.FreeMemory(System.Collections.Generic.Stack{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase})">
            <summary>
            Implements CallTreeNodesBase interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.AccumulateSamplesForNode(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode,System.Int32,Microsoft.Diagnostics.Tracing.Stacks.RecursionGuard)">
            <summary>
            A caller callee view is a summation which centers around one 'focus' node which is represented by the CallerCalleeNode.
            This node has a caller and callee list, and these nodes (as well as the CallerCalleNode itself) represent the aggregation
            over the entire tree.
            
            AccumulateSamplesForNode is the routine that takes a part of a aggregated call tree (represented by 'treeNode' and adds
            in the statistics for that call tree into the CallerCalleeNode aggregations (and its caller and callee lists).  
            
            'recursionsCount' is the number of times the focus node name has occurred in the path from 'treeNode' to the root.   In 
            addition to setting the CallerCalleeNode aggregation, it also returns a 'weightedSummary' inclusive aggregation 
            FOR JUST treeNode (the CallerCalleNode is an aggregation over the entire call tree accumulated so far).  
            
            The key problem for this routine to avoid is double counting of inclusive samples in the face of recursive functions. 
            Thus all samples are weighted by the recursion count before being included in 'weightedSummaryRet (as well as in
            the CallerCalleeNode and its Callers and Callees).    
            
            An important optimization is the ability to NOT create (but rather reuse) CallTreeNodes when returning weightedSummaryRet.
            To accomplish this the weightedSummaryScaleRet is needed.  To get the correct numerical value for weightedSummaryRet, you 
            actually have to scale values by weightedSummaryScaleRet before use.   This allows us to represent weights of 0 (subtree has 
            no calls to the focus node), or cases where the subtree is completely uniform in its weighting (the subtree does not contain
            any additional focus nodes), by simply returning the tree node itself and scaling it by the recursion count).  
            
            isUniformRet is set to false if anyplace in 'treeNode' does not have the scaling factor weightedSummaryScaleRet.  This
            means the the caller cannot simply scale 'treeNode' by a weight to get weightedSummaryRet.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CallerCalleeNode.Find(System.Collections.Generic.Dictionary{System.String,Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase}@,System.String)">
            <summary>
            Find the Caller-Callee treeNode in 'elems' with name 'frameName'.  Always succeeds because it
            creates one if necessary. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode">
            <summary>
            AggregateCallTreeNode supports a multi-level caller-callee view.   
            
            It does this by allow you to take any 'focus' node (typically a byname node)
            and compute a tree of its callers and a tree of its callees.   You do this
            by passing the node of interested to either the 'CallerTree' or 'CalleeTrees'.
            
            The AggregateCallTreeNode remembers if if is a caller or callee node and its
            'Callees' method returns the children (which may in fact be Callers). 
            
            What is nice about 'AggregateCallTreeNode is that it is lazy, and you only 
            form the part of the tree you actually explore.     A classic 'caller-callee' 
            view is simply the caller and callee trees only explored to depth 1.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.CallerTree(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase)">
            <summary>
            Given any node (typically a byName node, but it works on any node), Create a 
            tree rooted at 'node' that represents the callers of that node.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.CalleeTree(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase)">
            <summary>
            Given any node (typically a byName node, but it works on any node), Create a 
            tree rooted at 'node' that represents the callees of that node.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.GetTrees(System.Action{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode})">
            <summary>
            Calls 'callback' for each distinct call tree in this node.  Note that the same
            trees can overlap (in the case of recursive functions), so you need a mechanism
            for visiting a tree only once.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.ToString">
            <summary>
            Returns an XML representation of the AggregateCallTreeNode (for debugging);
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.FreeMemory(System.Collections.Generic.Stack{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNodeBase})">
            <summary>
            Implementation of CallTreeNodeBase interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.GetCallees">
            <summary>
            Implementation of CallTreeNode interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.MergeCaller(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode,System.Collections.Generic.List{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode},System.Int32)">
            <summary>
            See m_callerOffset and MergeCallee for more.
            
            The 'this' node is a AggregateCallTree representing the 'callers' nodes.  Like 
            MergeCallee the aggregate node represents a list of CallTreeNodes.   However unlike
            MergeCallee, the list of CallTreeNodes each represent a sample (a complete call stack)
            and 'callerOffset' indicates how far 'up' that stack is the node of interest.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.MergeCallee(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode,System.Collections.Generic.List{Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode})">
            <summary>
            An aggregateCallTreeNode is exactly that, the sum of several callTrees
            (each of which represent a number of individual samples).    Thus we had to 
            take each sample (which is 'treenode' and merge it into the aggregate.
            We do this one at a time.   Thus we call MergeCallee for each calltree 
            in our list and we find the 'callees' of each of those nodes, and create 
            aggregates for the children (which is in calleeList).   
            
            This routine is not recursive and does not touch most of the tree but
            it does call SubtractOutTrees which is recursive and may look at a lot
            of the tree (although we try to minimize this)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.SubtractOutTrees(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode,Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode)">
            <summary>
            Traverse 'treeCallee' and subtract out the inclusive time for any tree that matches 'idToExclude' from the node 'statsRet'.
            This is needed in AggregateCallTrees because the same trees from the focus node are in the list to aggregate, but are also
            in the subtree's in various places (and thus are counted twice).   We solve this by walking this subtree (in this routine)
            and subtracting out any nodes that match 'idToExclude'.   
            
            As an optimization this routine also sets the m_recursion bit 'statsRet' if anywhere in 'treeCallee' we do find an id to 
            exclude.  That way in a common case (where there is no instances of 'idToExclude') we don't have to actualy walk the
            tree the second time (we simply know that there is no adjustment necessary.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.m_trees">
            <summary>
            An AggregateCallTree remembers all its samples by maintaining a list of call trees 
            that actually contain the samples that the Aggregate represents.  m_trees hold this.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.AggregateCallTreeNode.m_callerOffset">
            <summary>
            AggregateCallTreeNode can represent either a 'callers' tree or a 'callees' tree.   For 
            the 'callers' tree case the node represented by the aggregate does NOT have same ID as
            the tree in the m_trees list.   Instead the aggregate is some node 'up the chain' toward 
            the caller.  m_callerOffset keeps track of this (it is the same number for all elements 
            in m_trees).   
            
            For callee nodes, this number is not needed.   Thus we use a illegal value (-1) to 
            represent that fact that the node is a callee node rather than a caller node.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Formats.ChromiumStackSourceWriter.WriteStackViewAsJson(Microsoft.Diagnostics.Tracing.Stacks.StackSource,System.String,System.Boolean)">
            <summary>
            exports provided StackSource to a Chromium Trace File format 
            schema: https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Formats.SpeedScopeStackSourceWriter.WriteStackViewAsJson(Microsoft.Diagnostics.Tracing.Stacks.StackSource,System.String)">
            <summary>
            exports provided StackSource to a https://www.speedscope.app/ format 
            schema: https://www.speedscope.app/file-format-schema.json
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Formats.SpeedScopeStackSourceWriter.WriteToFile(System.Collections.Generic.IReadOnlyDictionary{System.String,System.Collections.Generic.IReadOnlyList{Microsoft.Diagnostics.Tracing.Stacks.StackSourceWriterHelper.ProfileEvent}},System.Collections.Generic.IReadOnlyList{System.String},System.IO.TextWriter,System.String)">
            <summary>
            writes pre-calculated data to SpeedScope format
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.Histogram">
            <summary>
            A Histogram is logically an array of floating point values.  Often they
            represent frequency, but it can be some other metric.  The X axis can 
            represent different things (time, scenario).  It is the HisogramContoller
            which understands what the X axis is.   Histograms know their HistogramController
            but not the reverse.  
            
            Often Histograms are sparse (most array elements are zero), so the represnetation
            is designed to optimzed for this case (an array of non-zero index, value pairs). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.#ctor(Microsoft.Diagnostics.Tracing.Stacks.HistogramController)">
            <summary>
            Create a new histogram.  Every histogram needs a controller but these controllers 
            can be shared among many histograms.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.AddSample(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            Add a sample to this histogram.
            </summary>
            <param name="sample">The sample to add.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.AddMetric(System.Single,System.Int32)">
            <summary>
            Add an amount to a bucket in this histogram.
            </summary>
            <param name="metric">The amount to add to the bucket.</param>
            <param name="bucket">The bucket to add to.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.AddScaled(Microsoft.Diagnostics.Tracing.Stacks.Histogram,System.Double)">
            <summary>
            Computes this = this + histogram * weight in place (this is updated).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.Histogram.Count">
            <summary>
            The number of buckets in this histogram.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.Histogram.Controller">
            <summary>
            The <see cref="T:Microsoft.Diagnostics.Tracing.Stacks.HistogramController"/> that controls this histogram.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.Histogram.Item(System.Int32)">
            <summary>
            Get the metric contained in a bucket.
            </summary>
            <param name="index">The bucket to retrieve.</param>
            <returns>The metric contained in that bucket.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.Clone">
            <summary>
            Make a copy of this histogram.
            </summary>
            <returns>An independent copy of this histogram.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.ToString">
            <summary>
            A string representation (for debugging)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.#ctor(Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Create a histogram that is a copy of another histogram.
            </summary>
            <param name="other">The histogram to copy.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.GetEnumerator">
            <summary>
            Implementes IEnumerable interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Implementes IEnumerable interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.GetEnumerable">
            <summary>
            Get an IEnumerable that can be used to enumerate the metrics stored in the buckets of this Histogram.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.Histogram.m_controller">
            <summary>
            The controller for this histogram.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.HistogramController">
             <summary>
             A Histogram is conceputually an array of floating point values.   A Histogram Controller
             contains all the information besides the values themselves need to understand the array
             of floating point value.   There are a lot of Histograms, however they all tend to share
             the same histogram controller.   Thus Histograms know their Histogram controller, but not
             the reverse.  
             
             Thus HistogramContoller is a abstract class (we have one for time, and one for scenarios).  
            
             HistogramControllers are responsible for:
             
             - Adding a sample to the histogram for a node (see <see cref="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.AddSample(Microsoft.Diagnostics.Tracing.Stacks.Histogram,Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)"/>)
             - Converting a histogram to its string representation see (<see cref="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.GetDisplayString(Microsoft.Diagnostics.Tracing.Stacks.Histogram)"/>)
             - Managing the size and scale of histograms and their corresponding display strings
             </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.Scale">
            <summary>
            The scale factor for histograms controlled by this HistogramController.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.BucketCount">
            <summary>
            The number of buckets in each histogram controlled by this HistogramController.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.CharacterCount">
            <summary>
            The number of characters in the display string for histograms controlled by this HistogramController.
            Buckets are a logial concept, where CharacterCount is a visual concept (how many you can see on the 
            screen right now).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.Tree">
            <summary>
            The CallTree managed by this HistogramController.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.InvalidateScale">
            <summary>
            Force recalculation of the scale parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.AddSample(Microsoft.Diagnostics.Tracing.Stacks.Histogram,Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            Add a sample to the histogram for a node.
            </summary>
            <param name="histogram">The histogram to add this sample to. Must be controlled by this HistogramController.</param>
            <param name="sample">The sample to add.</param>
            <remarks>
            Overriding classes are responsible for extracting the metric, scaling the metric,
            determining the appropriate bucket or buckets, and adding the metric to the histogram using <see cref="M:Microsoft.Diagnostics.Tracing.Stacks.Histogram.AddMetric(System.Single,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.GetInfoForCharacterRange(Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Gets human-readable information about a range of histogram characters.
            </summary>
            <param name="start">The start character index (inclusive).</param>
            <param name="end">The end character index (exclusive).</param>
            <param name="histogram">The histogram.</param>
            <returns>A string containing information about the contents of that character range.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.GetDisplayString(Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Convert a histogram into its display string.
            </summary>
            <param name="histogram">The histogram to convert to a string.</param>
            <returns>A string suitable for GUI display.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.HistogramString(System.Collections.Generic.IEnumerable{System.Single},System.Int32,System.Double,System.Int32)">
            <summary>
            A utility function that turns an array of floats into a ASCII character graph.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.HistogramString(System.Single[],System.Double,System.Int32)">
            <summary>
            A utility function that turns an array of floats into a ASCII character graph.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.#ctor(Microsoft.Diagnostics.Tracing.Stacks.CallTree)">
            <summary>
            Initialize a new HistogramController.
            </summary>
            <param name="tree">The CallTree that this HistogramController controls.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.CalculateScale">
            <summary>
            Calculate the scale factor for this histogram.
            </summary>
            <returns>The scale factor for this histogram.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.CalculateAverageScale(Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Calculates an average scale factor for a histogram.
            </summary>
            <param name="hist">The root histogram to calculate against.</param>
            <returns>A scale factor that will normalize the maximum value to 200%.</returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.HistogramController.m_scale">
            <summary>
            The scale parameter. 0.0 if uncalculated.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex">
            <summary>
            An enum representing a displayed histogram bucket (one character in a histogram string).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex.Invalid">
            <summary>
            A HistogramCharacterIndex can be used to represent error conditions 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController">
            <summary>
            A <see cref="T:Microsoft.Diagnostics.Tracing.Stacks.HistogramController"/> that groups histograms by scenarios.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.#ctor(Microsoft.Diagnostics.Tracing.Stacks.CallTree,System.Int32[],System.Int32,System.String[])">
            <summary>
            Initialize a new ScenarioHistogramController.
            </summary>
            <param name="tree">The CallTree to manage.</param>
            <param name="scenarios">An ordered array of scenario IDs to display.</param>
            <param name="totalScenarios">The total number of possible scenarios that can be supplied by the underlying StackSource.
            This number might be larger than the highest number in <paramref name="scenarios"/>.</param>
            <param name="scenarioNames">The names of the scenarios (for UI use).</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.GetScenariosForCharacterIndex(Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex)">
            <summary>
            Get a list of scenarios contained in a given bucket.
            </summary>
            <param name="bucket">The bucket to look up.</param>
            <returns>The scenarios contained in that bucket.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.GetScenariosForCharacterRange(Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex)">
            <summary>
            Get a list of scenarios contained in a given bucket range.
            </summary>
            <param name="start">The start of the bucket range (inclusive).</param>
            <param name="end">The end of the bucket range (exclusive).</param>
            <returns>The scenarios contained in that range of buckets.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.AddSample(Microsoft.Diagnostics.Tracing.Stacks.Histogram,Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            Add a sample to a histogram controlled by this HistogramController.
            </summary>
            <param name="histogram">The histogram to add the sample to.</param>
            <param name="sample">The sample to add.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.GetNameForScenario(System.Int32)">
            <summary>
            Get the human-readable name for a scenario.
            </summary>
            <param name="scenario">The ID of the scenario to look up.</param>
            <returns>The human-readable name for that scenario.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.GetInfoForCharacterRange(Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Get the human-readable names for all scenarios contained in a range of histogram characters.
            </summary>
            <param name="start">The (inclusive) start index of the range.</param>
            <param name="end">The (exclusive) end index of the range.</param>
            <param name="histogram">The histogram.</param>
            <returns>A comma-separated list of scenario names contained in that range.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.GetDisplayString(Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Convert a histogram into a string suitable for UI display.
            </summary>
            <param name="histogram">The histogram to convert.</param>
            <returns>A string representing the histogram that is suitable for UI display.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.CalculateScale">
            <summary>
            Calculate the scale factor for all histograms controlled by this ScenarioHistogramController.
            </summary>
            <returns>
            In the current implementation, returns a scale that normalizes 100% to half of the maximum value at the root.
            </returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.m_characterFromScenario">
            <summary>
            An array mapping each scenario to a bucket.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.m_scenariosFromCharacter">
            <summary>
            An array mapping each bucket to a list of scenarios.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.ScenarioHistogramController.m_scenarioNames">
            <summary>
            An array mapping each scenario to its name.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController">
            <summary>
            A HistogramController holds all the information to understand the buckets of a histogram
            (basically everything except the array of metrics itself.   For time this is the
            start and end time  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.#ctor(Microsoft.Diagnostics.Tracing.Stacks.CallTree,System.Double,System.Double)">
            <summary>
            Create a new TimeHistogramController.
            </summary>
            <param name="tree">The CallTree to control with this controller.</param>
            <param name="start">The start time of the histogram.</param>
            <param name="end">The end time of the histogram.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.Start">
            <summary>
            The start time of the histogram.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.End">
            <summary>
            The end time of the histogram.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.GetStartTimeForBucket(Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex)">
            <summary>
            Gets the start time for the histogram bucket represented by a character.
            </summary>
            <param name="bucket">The index of the character to look up.</param>
            <returns>The start time of the bucket represented by the character.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.BucketDuration">
            <summary>
            The duration of time represented by each bucket.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.CalculateScale">
            <summary>
            Implements HistogramController interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.AddSample(Microsoft.Diagnostics.Tracing.Stacks.Histogram,Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            Implements HistogramController interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.GetInfoForCharacterRange(Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.HistogramCharacterIndex,Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Implements HistogramController interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TimeHistogramController.GetDisplayString(Microsoft.Diagnostics.Tracing.Stacks.Histogram)">
            <summary>
            Implements HistogramController interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.LinuxPerfScriptStackSourceSample.CpuNumber">
            <summary>
             The CpuNumber the sample occurred on
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.LinuxPerfScriptStackSourceSample.#ctor(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample,System.Int32)">
            <summary>
            Copy a LinuxPerfScriptStackSourceSample from 'template'
            </summary>
            <param name="template"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.LinuxPerfScriptStackSourceSample.#ctor(Microsoft.Diagnostics.Tracing.Stacks.LinuxPerfScriptStackSourceSample)">
            <summary>
            Copy a LinuxPerfScriptStackSourceSample from 'template'
            </summary>
            <param name="template"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.LinuxPerfScriptStackSourceSample.ToString">
            <summary>
            Gets a LinuxPerfScriptStackSourceSample
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.RecursionGuardConfiguration.MaxResets">
            <summary>
            The number of times to trampoline to a new thread before assuming infinite recursion and failing the operation.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.RecursionGuard">
            <summary>
            This structure provides a clean API for a lightweight recursion stack guard to prevent StackOverflow exceptions
            We do ultimately do a stack-overflow to prevent infinite recursion, but it is now under our
            control and much larger than you may get on any one thread stack.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.RecursionGuard.SingleThreadRecursionLimit">
            <summary>
            For recursive methods that need to process deep stacks, this constant defines the limit for recursion within
            a single thread. After reaching this limit, methods need to trampoline to a new thread before continuing to
            recurse.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.RecursionGuard.Depth">
            <summary>
            The amount of recursion we have currently done.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.RecursionGuard.Entry">
            <summary>
            Gets the recursion guard for entering a recursive method.
            </summary>
            <remarks>
            This is equivalent to the default <see cref="T:Microsoft.Diagnostics.Tracing.Stacks.RecursionGuard"/> value.
            </remarks>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.RecursionGuard.Recurse">
            <summary>
            Gets an updated recursion guard for recursing into a method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.RecursionGuard.ResetOnNewThread">
            <summary>
            Gets an updated recursion guard for continuing execution on a new thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.RecursionGuard.RequiresNewThread">
            <summary>
            Gets a value indicating whether the current operation has exceeded the recursion depth for a single thread,
            and needs to continue executing on a new thread.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSource">
            <summary>
            A stack source is a logically a list of StackSourceSamples.  Each sample has a metric and stack (hence the name StackSource)
            The stacks are represented as indexes that the  StackSourceStacks base class can resolve into frame names and stack chains.  
            The result is very efficient (no string processing) way of processing the conceptual list of stack samples.  
            </summary>    
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.ProduceSamples(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Call 'callback' on every sample in the StackSource.   Will be done linearly and only
            one callback will be active simultaneously.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Call 'callback' on every sample in the StackSource.   Will be done linearly and only
            one callback will be active simultaneously.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.SamplesImmutable">
            <summary>
            If this is overridden to return true, then during the 'Foeach' callback you can save references
            to the samples you are given because they will not be overridden by the stack source.  If this is
            false you must make a copy of the sample if you with to remember it.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.ParallelForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample},System.Int32)">
            <summary>
            Also called 'callback' on every sample in the StackSource however there may be more than
            one callback running simultaneously.    Thus 'callback' must be thread-safe and the order
            of the samples should not matter.   If desiredParallelism == 0 (the default) then the 
            implementation will choose a good value of parallelism. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.BaseStackSource">
            <summary>
            If this stack source is a source that simply groups another source, get the base source.  It will return
            itself if there is no base source.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.GetSampleByIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex)">
            <summary>
            If this source supports fetching the samples by index, this is how you get it.  Like ForEach the sample that
            is returned is not allowed to be modified.   Also the returned sample will become invalid the next time GetSampleIndex
            is called (we reuse the StackSourceSample on each call)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.SampleIndexLimit">
            <summary>
            Returns the limit on stack samples indexes (all index are strictly less than this).  Returns 0 if unknown.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.SampleTimeRelativeMSecLimit">
            <summary>
            Returns a time which is greater than or equal the timestamp of any sample in the StackSource.   Returns 0 if unknown.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.ScenarioCount">
            <summary>
            In addition to Time and Metric a sample can have a Scneario number associated with it.   ScenarioCount 
            returns the number of such scnearios.   Returning 0 implies no scenario support.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.SamplingRate">
            <summary>
            StackSources can optionally support a sampling rate.   If the source supports it it will return
            non-null for the current sampling rate (1 if it is doing nothing).    Sampling is a way of speeding
            things up.  If you sample at a rate of 10, it means that only one out of every 10 samples is actually
            produced by 'ForEach'.   Note that it is expected that when the sampling rate is set the 
            source will correspondingly adjust the CountMultiplier, so that the total will look like no sampling
            is occurring 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSource.IsGraphSource">
            <summary>
            If each 'callstack' is really a node in a graph (like MemoryGraphStackSource)
            Then return true.  If this returns true 'GetRefs' works. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.GetReferences(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex,Microsoft.Diagnostics.Tracing.Stacks.RefDirection,System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex})">
            <summary>
            Only used if IsGraphSource==true.   If 'direction' is 'From' Calls 'callback' for node that is referred to FROM nodeIndex.
            If 'direction' is 'To' then it calls 'callback' for every node that refers TO nodeIndex.  This API returns references 
            that are not necessarily a tree (they can for DAGs or have cycles).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.Dump(System.String)">
            <summary>
            Dump the stack source to a file as XML.   Used for debugging.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSource.Dump(System.IO.TextWriter)">
            <summary>
            Dump the stack source to a TextWriter as XML.   Used for debugging.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.RefDirection">
            <summary>
            RefDirection represents the direction of the references in a heap graph.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.RefDirection.From">
            <summary>
            Indicates that you are interested in referneces FROM the node of interest
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.RefDirection.To">
            <summary>
            Indicates that you are interested in referneces TO the node of interest
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks">
            <summary>
            Samples have stacks (lists of frames, each frame contains a name) associated with them.  This interface allows you to get 
            at this information.  We don't use normal objects to represent these but rather give each stack (and frame) a unique
            (dense) index.   This has a number of advantages over using objects to represent the stack.
            
                * Indexes are very serialization friendly, and this data will be presisted.  Thus indexes are the natural form for data on disk. 
                * It allows the data to be read from the serialized format (disk) lazily in a very straightfoward fashion, keeping only the
                    hottest elements in memory.  
                * Users of this API can associate additional data with the call stacks or frames trivially and efficiently simply by
                    having an array indexed by the stack or frame index.   
                    
            So effectively a StackSourceStacks is simply a set of 'Get' methods that allow you to look up information given a Stack or
            frame index.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Given a call stack, return the call stack of the caller.   This function can return StackSourceCallStackIndex.Discard
            which means that this sample should be discarded.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            For efficiency, m_frames are assumed have a integer ID instead of a string name that
            is unique to the frame.  Note that it is expected that GetFrameIndex(x) == GetFrameId(y) 
            then GetFrameName(x) == GetFrameName(y).   The converse does NOT have to be true (you 
            can reused the same name for distinct m_frames, however this can be confusing to your
            users, so be careful.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.GetNumberOfFoldedFrames(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            FilterStackSources can combine more than one frame into a given frame.  It is useful to know
            how many times this happened.   Returning 0 means no combining happened.  This metric does
            not include grouping, but only folding.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Get the frame name from the FrameIndex.   If 'verboseName' is true then full module path is included.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.CallStackIndexLimit">
            <summary>
            all StackSourceCallStackIndex are guaranteed to be less than this.  Allocate an array of this size to associate side information
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.CallFrameIndexLimit">
            <summary>
            all StackSourceFrameIndex are guaranteed to be less than this.  Allocate an array of this size to associate side information
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.OnlyManagedCodeStacks">
            <summary>
            True if it only has managed code stacks. Otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.StackDepth(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Computes the depth (number of callers), associated with callStackIndex.  This routine is O(n) and mostly useful for debugging.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.ToString(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample,System.Text.StringBuilder)">
            <summary>
            Returns an XML string representation of a 'sample'.  For debugging. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks.ToString(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Returns an XML string representation of a 'callStackIndex'.  For debugging. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample">
            <summary>
            StackSourceSample represents a single sample that has a stack.   It has a number of predefined data items associate with it
            including a stack, a metric and a time as well as other optional fields.  Note that all its properties are read-write.  
            It is basically a named tuple. 
            
            StackSource.ProductSamples push these.  
            
            In general StackSourceSample are NOT immutable but expected to be overwritted frequently.  Thus you need to copy 
            the sample if you want to keep a reference to it.      
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.StackIndex">
            <summary>
            The Stack associated with the sample 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.Metric">
            <summary>
            The metric (cost) associated with the sample 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.SampleIndex">
            <summary>
            If the source supports fetching samples by some ID, then SampleIndex returns this ID for the sample and 
            GetSampleByIndex is the API that converts this index into a sample again.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.TimeRelativeMSec">
            <summary>
            The time associated with the sample.  (can be left 0)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.Count">
            <summary>
            Normally the count of a sample is 1, however when you take a statistical sample, and you also have 
            other constraints (like you do when you are going a sample of heap memory),  you may need to have the
            count adjusted to something else.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.Scenario">
            <summary>
            A scenario is simply a integer that represents some group the sample belongs to. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.ToString">
            <summary>
            Returns an XML string representing the sample
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.ToString(Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks)">
            <summary>
            Returns an XML string representing the sample, howevever this one can actually expand the stack because it is given the source
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.#ctor(Microsoft.Diagnostics.Tracing.Stacks.StackSource)">
            <summary>
            Create a StackSourceSample which is associated with 'source'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample.#ctor(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            Copy a StackSourceSample from 'template'
            </summary>
            <param name="template"></param>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex">
            <summary>
            Identifies a particular sample from the sample source, it allows 3rd parties to attach additional
            information to the sample by creating an array indexed by sampleIndex.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex.Invalid">
            <summary>
            Returned when no appropriate Sample exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex">
            <summary>
            An opaque handle that are 1-1 with a complete call stack
            
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex.Start">
            <summary>
            The first real call stack index (after the pseudo-ones before this)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex.Invalid">
            <summary>
            Returned when no appropriate CallStack exists.   (Top of stack)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex">
            <summary>
            Identifies a particular frame within a stack   It represents a particular instruction pointer (IP) location 
            in the code or a group of such locations.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Root">
            <summary>
            Pseduo-node representing the root of all stacks
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Broken">
            <summary>
            Pseduo-frame that represents the caller of all broken stacks. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Unknown">
            <summary>
            Unknown what to do (Must be before the 'special ones below')  // Non negative represents normal m_frames (e.g. names of methods)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Overhead">
            <summary>
             Profiling overhead (rundown)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Start">
            <summary>
            The first real call stack index (after the pseudo-ones before this)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Invalid">
            <summary>
            Should not happen (uninitialized) (also means completely folded away)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Discard">
            <summary>
            Sample has been filtered out (useful for filtering stack sources)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceModuleIndex">
            <summary>
            A StackSourceModuleIndex uniquely identifies a module to the stack source.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceModuleIndex.Start">
            <summary>
            Start is where 'ordinary' module indexes start. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceModuleIndex.Invalid">
            <summary>
            Invalid is a module index that is never used and can be used to signal error conditions. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource">
            <summary>
            This stack source takes another and copies out all its events.   This allows you to 'replay' the source 
            efficiently when the original source only does this inefficiently.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.#ctor">
            <summary>
            Create a CopyStackSource that has no samples in it.  It can never have samples so it is only useful as a placeholder.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.#ctor(Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks)">
            <summary>
            Create a CopyStackSource that you can add samples which use indexes that 'sourceStacks' can decode.   All samples
            added to the stack source must only refer to this StackSourceStacks
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.AddSample(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            Add a sample to stack source.  it will clone 'sample' so sample can be overwritten after this method returns.  
            It is an error if 'sample' does not used the StackSourceStacks passed to the CopyStackSource at construction. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.Clone(Microsoft.Diagnostics.Tracing.Stacks.StackSource)">
            <summary>
            Create a clone of the given stack soruce.  
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.SourceStacks">
            <summary>
            Returns the StackSourceStacks that can interpret indexes for this stack source.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.GetSampleByIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.SampleIndexLimit">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.SampleTimeRelativeMSecLimit">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.SamplesImmutable">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.CallStackIndexLimit">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.CopyStackSource.CallFrameIndexLimit">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource">
            <summary>
            Like CopyStackSource InternStackSource copies the samples. however unlike CopyStackSource
            InternStackSource copies all the information in the stacks too (mapping stack indexes to names)
            Thus it never refers to the original source again).   It also interns the stacks making for 
            an efficient representation of the data.   This is useful when the original source is expensive 
            to iterate over.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.Diff(Microsoft.Diagnostics.Tracing.Stacks.StackSource,Microsoft.Diagnostics.Tracing.Stacks.StackSource)">
            <summary>
            Compute the difference between two sources of stacks.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.Diff(Microsoft.Diagnostics.Tracing.Stacks.StackSource,Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks,Microsoft.Diagnostics.Tracing.Stacks.StackSource,Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks)">
            <summary>
            Compute only the delta of source from the baseline.  This variation allows you to specify
            the unfiltered names (the sourceStacks and baselineStacks) but otherwise keep the filtering.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.#ctor(Microsoft.Diagnostics.Tracing.Stacks.StackSource,Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks)">
            <summary>
            Create a new stack source that can create things out of nothing.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.#ctor">
            <summary>
            Create a new InternStackSource
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.Interner">
            <summary>
            Returns the Interner, which is the class that holds the name->index mappings that that every
            name has a unique index.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.CallStackIndexLimit">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.CallFrameIndexLimit">
            <summary>
            Implementation of the StackSource interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.InternStackSource.InternFullStackFromSource(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceStacks,System.Int32)">
            <summary>
            InternFullStackFromSource will take a call stack 'baseCallStackIndex' from the source 'source' and completely copy it into
            the intern stack source (interning along the way of course).   Logically baseCallStackIndex has NOTHING to do with any of the
            call stack indexes in the intern stack source.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner">
            <summary>
            StackSourceInterner is a helper class that knows how to intern module, frame and call stacks. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.#ctor(System.Int32,System.Int32,System.Int32,Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceModuleIndex)">
            <summary>
            Create a new StackSourceInterner.  Optionally supply estimates on how many items you need and where the frame, callstack and module indexes start.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.DoneInterning">
            <summary>
            As an optimization, if you are done adding new nodes, then you can call this routine can abandon
            some tables only needed during the interning phase.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.CallStackStartIndex">
            <summary>
            The CallStackStartIndex value passed to the constructor
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.FrameStartIndex">
            <summary>
            The FrameStartIndex value passed to the constructor
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Given a StackSourceCallStackIndex return the StackSourceCallStackIndex of the caller
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Given a StackSourceCallStackIndex return the StackSourceFrameIndex for the Frame associated
            with the top call stack
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Get a name from a frame index.  If the frame index is a 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.GetModuleIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex)">
            <summary>
            Given a StackSourceFrameIndex return the StackSourceModuleIndex associated with the frame 
            </summary>
            <param name="frameIndex"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.FrameNameLookup">
            <summary>
            If you intern frames as derived frames, when GetFrameName is called the interner needs to know
            how to look up the derived frame from its index.  This is the function that is called.  
            
            It is called with the frame index and a boolean which indicates whether the full path of the module 
            should be specified, and returns the frame string. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.ModuleIntern(System.String)">
            <summary>
            Lookup or create a StackSourceModuleIndex for moduleName
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.FrameIntern(System.String,Microsoft.Diagnostics.Tracing.Stacks.StackSourceModuleIndex)">
            <summary>
            Lookup or create a StackSourceFrameIndex for frame with the name frameName and the module identified by moduleIndex
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.FrameIntern(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.String)">
            <summary>
            You can also create frames out of other frames using this method.  Given an existing frame, and
            a suffix 'frameSuffix' 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.CallStackIntern(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Lookup or create a StackSourceCallStackIndex for a call stack with the frame identified frameIndex and caller identified by callerIndex
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.FrameCount">
            <summary>
            The current number of unique frames that have been interned so far
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.CallStackCount">
            <summary>
            The current number of unique call stacks that have been interned so far
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1">
            <summary>
            A specialized hash table for interning.
            It loosely follows the implementation of <see cref="T:System.Collections.Generic.Dictionary`2"/> but with
            several key allowances for known usage patterns:
            1. We don't store the hashcode on each entry on the assumption that values can be compared
               as quickly as recomputing hash codes. The downside to that is that the hash codes must
               be recomputed whenever the map is resized, but that is very cheap.
            2. We supply a single <see cref="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Intern(`0)"/> method (instead of a TryGetValue
               followed by an Add) so that a hashcode computation is saved in the case of a "miss".
            3. We don't support removal. This means we don't need to keep track of a free list and neither
               do we need sentinel values. This also allows us to use all 32 bits of the hash-code (where
               <see cref="T:System.Collections.Generic.Dictionary`2"/> uses only 31 bits, reserving -1 to indicate a freed
               entry. The only sentinel value is in the <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1._buckets"/> array to indicate a free
               bucket.
            4. We return an index (of the interned item) to the caller which can be used for constant-time
               look-up in the table via <see cref="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Item(System.Int32)"/>.
            5. To free up memory, the caller can call <see cref="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.DoneInterning"/>. The entries themselves
               are stored separately from the indexing parts of the table so that the latter can be dropped
               easily.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.#ctor(System.Int32)">
            <summary>
            Construct the intern map
            </summary>
            <param name="initialCapacity">The estimated capacity of the map.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Count">
            <summary>
            Count of interned values.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Item(System.Int32)">
            <summary>
            Access an element by index.
            </summary>
            <param name="index">The zero-based index of the desired entry.</param>
            <returns>The entry at the requested index.</returns>
            <remarks>For performance, in Release mode we do no range checking on <paramref name="index"/>, so it is possible to
            access an entry beyond <see cref="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Count"/> but prior to the maximum capacity of the array.</remarks>
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="index"/> was less than zero or greater than the capacity.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Intern(`0)">
            <summary>
            Intern a value. If the same value has been seen before
            then this returns the index of the previously seen entry. If not, a new entry
            is added and this returns the index of the newly added entry.
            </summary>
            <param name="value">The candidate value.</param>
            <returns>The index of the interned entry.</returns>
            <exception cref="T:System.NullReferenceException">This routine was called after calling <see cref="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.DoneInterning"/>.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.DoneInterning">
            <summary>
            As an optimization, if you are done calling <see cref="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Intern(`0)"/>, then you can call this
            to free up some memory.
            </summary>
            <remarks>After calling this, you can still call <see cref="P:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Item(System.Int32)"/>. However, if you try to
            call <see cref="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Intern(`0)"/> you will get a <see cref="T:System.NullReferenceException"/>.</remarks>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Bucket">
            <summary>
            Elements representing the structure of the hash table. The structure is
            a collection of singly linked lists, one list per 'bucket' where a
            bucket number is selected by taking the hash code of an incoming item
            and mapping it onto the <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1._buckets"/> array (see <see cref="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.BucketNumberFromValue(`0)"/>).
            </summary>
            <remarks>
            Caution: For a given <see cref="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Bucket"/>, <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Bucket._head"/> and
            <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Bucket._next"/> are UNRELATED to each other. Logically, you can
            think of <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Bucket._next"/> as being part of a value in the
            <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1._entries"/> table. (We don't actually do that in order to
            support <see cref="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.DoneInterning"/> efficiently.)
            To find the next element in the linked list, you should NOT simply
            look at <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Bucket._next"/>. Instead, you should first look up the
            <see cref="T:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Bucket"/> in the <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1._buckets"/> array indexed by
            <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Bucket._head"/> and look at the <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Bucket._next"/> field of that.
            </remarks>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Bucket._head">
            <summary>
            Index into the <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1._entries"/> array of the head item in the linked list or
            -1 to indicate an empty bucket.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1.Bucket._next">
            <summary>
            Index into the <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceInterner.InternTable`1._buckets"/> array of the next item in the linked list or
            -1 to indicate that this is the last item.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceWriterHelper.GetSortedSamplesPerThread(Microsoft.Diagnostics.Tracing.Stacks.StackSource)">
            <summary>
            we want to identify the thread for every sample to prevent from 
            overlaping of samples for the concurrent code so we group the samples by Threads
            this method also sorts the samples by relative time (ascending)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceWriterHelper.GetProfileEvents(Microsoft.Diagnostics.Tracing.Stacks.StackSource,System.Collections.Generic.IReadOnlyList{Microsoft.Diagnostics.Tracing.Stacks.StackSourceWriterHelper.Sample},System.Collections.Generic.Dictionary{System.String,System.Int32},System.Collections.Generic.Dictionary{System.Int32,Microsoft.Diagnostics.Tracing.Stacks.StackSourceWriterHelper.FrameInfo})">
            <summary>
            all the samples that we have are leafs (last sample in the call stack)
            this method walks the stack up to the beginning and merges the samples and outputs them in proper order
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.StackSourceWriterHelper.AreNotContinuous(Microsoft.Diagnostics.Tracing.Stacks.StackSourceWriterHelper.Sample,Microsoft.Diagnostics.Tracing.Stacks.StackSourceWriterHelper.Sample)">
            <summary>
            this method checks if both samples do NOT belong to the same profile event
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource">
            <summary>
            TraceEventStackSource is an implementation of a StackSource for ETW information (TraceLog)
            It takes a TraceEvents (which is a list of TraceEvents you get get from a TraceLog) and 
            implements that StackSource protocol for them.  (thus any code needing a StackSource 
            can then work on it.  
            
            The key to the implementation is how StackSourceFrameIndex and StackSourceCallStackIndex 
            (part of the StackSource protocol) are mapped to the Indexes in TraceLog.   Here is
            the mapping.
            
            TraceEventStackSource create the following meaning for the StackSourceCallStackIndex
            
            * The call stacks ID consists of the following ranges concatenated together. 
                * a small set of fixed Pseudo stacks (Start marks the end of these)
                * CallStackIndex
                * ThreadIndex
                * ProcessIndex
                * BrokenStacks (One per thread)
                * Stacks for CPU samples without explicit stacks (we make 1 element stacks out of them)
                    
            TraceEventStackSource create the following meaning for the StackSourceFrameIndex
            
            The frame ID consists of the following ranges concatenated together. 
                * a small fixed number of Pseudo frame (Broken, and Unknown)
                * MaxCodeAddressIndex - something with a TraceCodeAddress. 
                * ThreadIndex         - ETW stacks don't have a thread or process node, so we add them.
                * ProcessIndex
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceEvents)">
            <summary>
            Creates a new TraceEventStackSource given a list of events 'events' from a TraceLog
            </summary>
            <param name="events"></param>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.TraceLog">
            <summary>
            Returns the TraceLog file that is associated with this stack source.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.ShowUnknownAddresses">
            <summary>
            Normally addresses without symbolic names are listed as ?, however sometimes it is useful 
            to see the actual address as a hexadecimal number.  Setting this will do that.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.ShowOptimizationTiers">
            <summary>
            Displays the optimization tier of each code version executed for the method.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.LookupWarmSymbols(System.Int32,Microsoft.Diagnostics.Symbols.SymbolReader,Microsoft.Diagnostics.Tracing.Stacks.StackSource,System.Predicate{Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile})">
            <summary>
            Looks up symbols for all modules that have an inclusive count >= minCount. 
            stackSource, if given, can be used to be the filter.  If null, 'this' is used.
            If stackSource is given, it needs to use the same indexes for frames as 'this'.
            shouldLoadSymbols, if given, can be used to filter the modules.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetFrameCodeAddress(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex)">
            <summary>
            Given a frame index, return the corresponding code address for it.  This is useful for looking up line number information. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.SampleTimeRelativeMSecLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetSourceLine(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,Microsoft.Diagnostics.Symbols.SymbolReader)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.CallStackIndexLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.CallFrameIndexLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetModulesForStack(Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.ModuleList[],Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Returns a list of modules for the stack 'stackIdx'.  It also updates the interning table stackModuleLists, so 
            that the entry cooresponding to stackIdx remembers the answer.  This can speed up processing a lot since many
            stacks have the same prefixes to root.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.ModuleList">
            <summary>
            A ModuleList is a linked list of modules.  It is only used in GetModulesForStack and LookupWarmSymbols
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.m_pseudoStacksTable">
            <summary>
            This maps pseudo-stacks to their index (thus it is the inverse of m_pseudoStack; 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.TraceEventStackSource.GetPseudoStack(Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex,Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a thread and a call stack that does not have a stack, make up a pseudo stack for it consisting of the code address, 
            the broken node, the thread and process.   Will return -1 if it can't allocate another Pseudo-stack.
            </summary> 
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource">
            <summary>
            Like a TraceEventStackSource a MutableTraceEventStackSource allows you incorporate the stacks associated with
            a TraceEvent as a sample in the StackSource.   However in addition it allows you to create new frames for these
            stacks on the fly as well as add samples that did not exist in the original TraceEvent stream.   This gives you
            a lot of flexibility to add additional data to the original stream of TraceEvents.   
            
            Like TraceEventStackSource MutableTraceEventStackSource supports the GetFrameCodeAddress() method that  allows
            you to map from the StackSourceFrameIndex back its TraceLog code address (that lets you get at the source code and
            line number for that frame).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            Create a new MutableTraceEventStackSource that can represent stacks coming from any events in the given TraceLog with a stack.  
            You use the 'AddSample' and 'DoneAddingSamples' to specify exactly which stacks you want in your source.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.AddSample(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample)">
            <summary>
            After creating a MultableTraceEventStackSource, you add the samples you want using this AddSample API (you can reuse 'sample' 
            used as an argument to this routine.   It makes a copy.  The samples do NOT need to be added in time order (the MultableTraceEventStackSource
            will sort them).   When you done DoneAddingSamples must be called before using the
            the MutableTraceEventStackSource as a stack source.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.DoneAddingSamples">
            <summary>
            After calling 'AddSample' to add the samples that should belong to the source, DoneAddingSamples() should be called to
            to complete the construction of the stack source.   Only then can the reading API associated with the stack source be called. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.Interner">
            <summary>
            The Interner is the class that allows you to make new indexes out of strings and other bits.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetCallStackForProcess(Microsoft.Diagnostics.Tracing.Etlx.TraceProcess)">
            <summary>
            Returns a StackSourceCallStackIndex representing just one entry that represents the process 'process'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetCallStackForThread(Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Returns a StackSourceCallStackIndex representing just two entries that represent 'thread' which has a parent of its process.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetCallStackThread(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Returns a StackSourceCallStackIndex representing the call stack from the TraceLog represented by the CallStackIndex 'callStackIndex'.  
            If that stack is invalid, use 'thread' to at least return a call stack for the thread.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetCallStack(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Returns a StackSourceCallStackIndex representing the call stack from the TraceLog represented by the CallStackIndex 'callStackIndex'.  
            Use the TraceEvent 'data' to find the stack if callStackIndex is invalid.  
            TODO data should be removed (or callstack derived from it) 
            </summary>  
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.CallStackMap">
            <summary>
            A very simple IDictionary-like interface for remembering values in GetCallStack()
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.CallStackMap.Get(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Fetches an value given a key
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.CallStackMap.Put(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Sets a key-value pair
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetCallStack(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.CallStackMap)">
            <summary>
            Find the StackSourceCallStackIndex for the TraceEvent call stack index 'callStackIndex' which has a top of its 
            stack (above the stack, where the thread and process would normally go) as 'top'.  If callStackMap is non-null 
            it is used as an interning table for CallStackIndex -> StackSourceCallStackIndex.  This can speed up the 
            transformation dramatically.   It will still work if it is null.  
            </summary>
            
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Create a frame name from a TraceLog code address.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetModuleIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.GetSampleByIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex)">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.SampleIndexLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.SamplesImmutable">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.CallFrameIndexLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.CallStackIndexLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.SampleTimeRelativeMSecLimit">
            <summary>
            Implementation of StackSource protocol. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.m_Interner">
            <summary>
            private
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource.m_emptyModuleIdx">
            <summary>
            private
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.EventCount">
            <summary>
            Gets an estimated total number of samples created - not thread safe.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.SkipPreamble(Microsoft.Diagnostics.Tracing.Utilities.FastStream)">
            <summary>
            Tries to skip the byte order marks at the beginning of the given fast stream.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.ParseSkippingPreamble(System.String)">
            <summary>
            Parses the given Linux sample data, returning one sample at a time, and
            automatically skips the BOM at the beginning of files.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.Parse(Microsoft.Diagnostics.Tracing.Utilities.FastStream)">
            <summary>
            Parse the given Linux sample data, returning one sample at a time, does not try to
            skip through the BOM.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.Pattern">
            <summary>
            Regex string pattern for filtering events.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.MaxSamples">
            <summary>
            The amount of samples the parser takes.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.SetSymbolFile(System.IO.Compression.ZipArchive)">
            <summary>
            Uses the archive as a resource for symbol resolution when parsing Linux samples.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.SetSymbolFile(System.String)">
            <summary>
            Uses the path to open an archive with symbol files that are then used for symbol resolution when
            parsing Linux samples.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.GetSymbolFromMicrosoftMap(System.String,System.String)">
            <summary>
            Parses a Microsoft symbol as shown on the Linux sample. "entireSymbol" represents the module contract between
            the memory address and the dll path on the Linux sample.
            "mapFileLocation" is the path to the dll given by the Linux sample.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.ParseSymbolFile(System.IO.Stream,Microsoft.Diagnostics.Tracing.StackSources.Mapper)">
            <summary>
            Given a stream with the symbols, this function parses the stream and stores the contents in the given mapper
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.ParsePerfInfoFile(System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Collections.Generic.Dictionary{System.String,System.UInt64})">
            <summary>
            Given a stream that contains PerfInfo commands, parses the stream and stores data in the given dictionary.
            Key: somedll.ni.dll		Value: {some guid}
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.GetFileName(System.String)">
            <summary>
            Can't use Path.GetFileName because it fails on illegal Linux file characters.  
            Can remove when this changes. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.FindEndOfProcessCommand(Microsoft.Diagnostics.Tracing.Utilities.FastStream)">
             <summary>
             This routine should be called at the start of a line after you have skipped whitespace.
             
             Logically a line starts with PROCESS_COMMAND PID/TID [CPU] TIME: 
             
             However PROCESS_COMMAND is unfortunately free form, including the fact hat it can have / or numbers in it.   
             For example here is a real PROCESS_COMMAND examples (rs:action 13 qu) or  (kworker/1:3)
             Thus it gets tricky to know when the command stops and the PID/TID starts.
             
             We use the following regular expression to determine the end of the command
             
                   \s*\d+/\d        OR
                   ^\d+/\d          THIS PATTERN IS NEEDED BECAUSE THE PROCESS_COMMAND MAY BE EMPTY.  
            
             This routine peeks forward looking for this pattern, and returns either the index to the start of it or -1 if not found.  
             </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StackSources.EventKind">
            <summary>
            Defines the kind of an event for easy casting.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.StackSources.EventKind.Cpu">
            <summary>
            Represents an event that uses the cpu, and does not do anything special
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.StackSources.EventKind.Scheduler">
            <summary>
            Represents an event that may context switch
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.StackSources.EventKind.ThreadExit">
            <summary>
            Represents a thread exit event.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StackSources.SchedulerEvent">
            <summary>
            A sample that has extra properties to hold scheduled events.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StackSources.SchedulerEvent.Switch">
            <summary>
            The details of the context switch.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StackSources.ScheduleSwitch">
            <summary>
            Stores all relevant information retrieved by a context switch stack frame
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StackSources.ThreadExitEvent.Exit">
            <summary>
            The details of the context switch.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StackSources.ThreadExit">
            <summary>
            Stores all relevant information retrieved by a thread exit.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StackSources.LinuxEvent">
            <summary>
            A generic Linux event, all Linux events contain these properties.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.StackSources.FrameKind.StackFrame">
            <summary>
            An actual stack frame from the simpling data
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.StackSources.FrameKind.ProcessFrame">
            <summary>
            A stack frame that represents the process of the sample
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.StackSources.FrameKind.ThreadFrame">
            <summary>
            A stack frame that represents the thread of the sample
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.StackSources.FrameKind.BlockedCPUFrame">
            <summary>
            A stack frame that represents either blocked time or cpu time
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StackSources.Frame">
            <summary>
            A way to define different types of frames with different names on PerfView.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StackSources.StackFrame">
            <summary>
            Defines a single stack frame on a linux sample.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StackSources.ProcessFrame">
            <summary>
            Represents the name of the process.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StackSources.ThreadFrame">
            <summary>
            Represents the name of the thread and its ID.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StackSources.BlockedCPUFrame">
            <summary>
            A visual frame that represents whether or not a call stack was blocked or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StackSources.BlockedCPUFrame.SubKind">
            <summary>
            Represents whether the stack frame is BLOCKED_TIME or CPU_TIME
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptStackSource.CreateSampleFor(Microsoft.Diagnostics.Tracing.StackSources.LinuxEvent,Microsoft.Diagnostics.Tracing.StackSources.BlockedTimeAnalyzer)">
            <summary>
            Given a Linux event gotten from the trace, make its corresponding sample for the stack source.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StackSources.LinuxPerfScriptStackSource.AddSamples(System.Collections.Generic.IEnumerable{Microsoft.Diagnostics.Tracing.Stacks.LinuxPerfScriptStackSourceSample})">
            <summary>
            Takes collection of samples, sorts them by time and then stores them.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StackSources.BlockedTimeAnalyzer">
            <summary>
            Analyzes blocked time 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventSource">
            <summary>
            TraceEventSource is an abstract base class that represents the output of a ETW session (e.g. a ETL file 
            or ETLX file or a real time stream).   This base class is NOT responsible for actually processing
            the events, but contains methods for properties associated with the session
            like its start and end time, filename, and characteristics of the machine it was collected on.
            <para>This class has two main subclasses:</para>
            <para>* <see cref="T:Microsoft.Diagnostics.Tracing.TraceEventDispatcher"/> which implements a 'push' (callback) model and is the only mode for ETL files.  
            ETWTraceEventSource is the most interesting subclass of TraceEventDispatcher.</para>
            <para>* see TraceLog which implements both a 'push' (callback) as well as pull (foreach) model but only works on ETLX files.</para>
            <para>This is the end.</para>
            <para>The normal user pattern is to create a TraceEventSource, create TraceEventParsers attached to the TraceEventSource, and then subscribe
            event callbacks using the TraceEventParsers</para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.Clr">
            <summary>
            For convenience, we provide a property returns a ClrTraceEventParser that knows 
            how to parse all the Common Language Runtime (CLR .NET) events into callbacks.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.Kernel">
            <summary>
            For convenience, we provide a property returns a KernelTraceEventParser that knows 
            how to parse all the Kernel events into callbacks.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.Dynamic">
            <summary>
            For convenience, we provide a property returns a DynamicTraceEventParser that knows 
            how to parse all event providers that dynamically log their schemas into the event streams.
            In particular, it knows how to parse any events from a System.Diagnostics.Tracing.EventSources. 
            
            Note that the DynamicTraceEventParser has subsumed the functionality of RegisteredTraceEventParser
            so any registered providers are also looked up here.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.Registered">
            <summary>
            For convenience, we provide a property returns a RegisteredTraceEventParser that knows 
            how to parse all providers that are registered with the operating system.
            
            Because the DynamicTraceEventParser has will parse all providers that that RegisteredTraceEventParser
            will parse, this function is obsolete, you should use Dynamic instead.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.SessionStartTime">
            <summary>
            The time when session started logging. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.SessionEndTime">
            <summary>
            The time that the session stopped logging.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.SessionEndTimeRelativeMSec">
            <summary>
            The Session End time expressed as milliseconds from the start of the session
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.SessionDuration">
            <summary>
            The difference between SessionEndTime and SessionStartTime;
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.Size">
            <summary>
            The size of the trace, if it is known.  Will return 0 if it is not known.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.PointerSize">
            <summary>
            Returns the size of a pointer on the machine where events were collected (4 for 32 bit or 8 for 64 bit)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.EventsLost">
            <summary>
            The number of events that were dropped (e.g. because the incoming event rate was too fast)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.NumberOfProcessors">
            <summary>
            The number of processors on the machine doing the logging. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.CpuSpeedMHz">
            <summary>
            Cpu speed of the machine doing the logging. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.OSVersion">
            <summary>
            The version of the windows operating system on the machine doing the logging.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.IsRealTime">
            <summary>
            Returns true if this is a real time session.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.DataLifetimeMsec">
            <summary>
            Time based threshold for how long data should be retained 
            by accumulates that are processing this TraceEventSource.
            A value of 0, the default, indicates an infinite accumulation.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.DataLifetimeEnabled">
            <summary>
            Check if a DataLifetime model is enabled
            </summary>
            <returns>True - lifetime tracking is enabled</returns>
            <returns>False - lifetime tracking is not enabled</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.Dispose">
            <summary>
            Closes any files and cleans up any resources associated with this TraceEventSource
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.UserData">
            <summary>
            TraceEventSource supports attaching arbitrary user data to the source.  This property returns a key-value bag of these attached values.  
            <para>
            One convention that has been established is that TraceEventParsers that need additional state to parse their events should
            store them in UserData under the key 'parsers\(ParserName)' 
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.Dispose(System.Boolean)">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventSource.QPCFreq">
            <summary>
            This is the high frequency tick clock on the processor (what QueryPerformanceCounter uses).  
            You should not need 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.QPCTimeToRelMSec(System.Int64)">
            <summary>
            Converts the Query Performance Counter (QPC) ticks to a number of milliseconds from the start of the trace.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.RelativeMSecToQPC(System.Double)">
            <summary>
            Converts a Relative MSec time to the Query Performance Counter (QPC) ticks 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.UTCDateTimeToQPC(System.DateTime)">
            <summary>
            Converts a DateTime to the Query Performance Counter (QPC) ticks 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.QPCTimeToDateTimeUTC(System.Int64)">
            <summary>
            Converts the Query Performance Counter (QPC) ticks to a DateTime  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventSource.LastChanceGetThreadID(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Some events (like HardFault) do not have a thread ID or a process ID, but they MIGHT have a Stack
            If they do try to get the ThreadID for the event from that.  Return -1 if not successful.   
            This is intended to be overridden by the TraceLog class that has this additional information. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEvent">
            <summary>
            TraceEvent an abstract class represents the data from one event in the stream of events in a TraceEventSource.   
            The TraceEvent class has all the properties of an event that are common to all ETW events, including TimeStamp
            ProviderGuid, ProcessID etc.   Subclasses of TraceEvent then extend this abstract class to include properties
            specific to a particular payload.   
            <para>
            An important architectural point is that TraceEvent classes are aggressively reused by default.   The TraceEvent that is
            passed to any TraceEventParser callback or in a foreach is ONLY valid for the duration for that callback (or one
            iteration of the foreach).  If you need save a copy of the event data, you must call the Clone() method to make
            a copy.   The IObservable interfaces (TraceEventParser.Observe* methods) however implicitly call Clone() so you
            do not have to call Clone() when processing with IObservables (but these are slower).  
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ProviderGuid">
            <summary>
            The GUID that uniquely identifies the Provider for this event.  This can return Guid.Empty for classic (Pre-VISTA) ETW providers.  
            </summary>        
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.TaskGuid">
            <summary>
            Unique GUID for Pre-VISTA ETW providers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ProviderName">
            <summary>
            The name of the provider associated with the event.  It may be of the form Provider(GUID) or UnknownProvider in some cases but is never null.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.EventName">
            <summary>
            A name for the event.  This is simply the concatenation of the task and opcode names (separated by a /).  If the 
            event has no opcode, then the event name is just the task name.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ID">
            <summary>
            Returns the provider-specific integer value that uniquely identifies event within the scope of
            the provider. (Returns 0 for classic (Pre-VISTA) ETW providers).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Task">
            <summary>
            Events for a given provider can be given a group identifier (integer) called a Task that indicates the
            broad area within the provider that the event pertains to (for example the Kernel provider has
            Tasks for Process, Threads, etc).   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.TaskName">
            <summary>
            The human readable name for the event's task (group of related events) (eg. process, thread,
            image, GC, ...).  May return a string Task(GUID) or Task(TASK_NUM) if no good symbolic name is
            available.  It never returns null.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Opcode">
            <summary>
            An opcode is a numeric identifier (integer) that identifies the particular event within the group of events 
            identified by the event's task.  Often events have opcode 'Info' (0), which is the default.   This value
            is interpreted as having no-opcode (the task is sufficient to identify the event).
            <para>
            Generally the most useful opcodes are the Start and Stop opcodes which are used to indicate the beginning and the
            end of a interval of time.   Many tools will match up start and stop opcodes automatically and compute durations.  
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.OpcodeName">
            <summary>
            Returns the human-readable string name for the Opcode property. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Level">
            <summary>
            The verbosity of the event (Fatal, Error, ..., Info, Verbose)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Version">
            <summary>
            The version number for this event.  The only compatible change to an event is to add new properties at the end.
            When this is done the version numbers is incremented.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Keywords">
            <summary>
            ETW Event providers can specify a 64 bit bitfield called 'keywords' that define provider-specific groups of 
            events which can be enabled and disabled independently.   
            Each event is given a keywords mask that identifies which groups the event belongs to.   This property returns this mask.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Channel">
            <summary>
            A Channel is a identifier (integer) that defines an 'audience' for the event (admin, operational, ...).   
            Channels are only used for Windows Event Log integration.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.TimeStamp">
            <summary>
            The time of the event. You may find TimeStampRelativeMSec more convenient.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.TimeStampRelativeMSec">
            <summary>
            Returns a double representing the number of milliseconds since the beginning of the session.     
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ThreadID">
            <summary>
            The thread ID for the thread that logged the event
            <para>This field may return -1 for some events when the thread ID is not known.</para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ProcessID">
            <summary>
            The process ID of the process which logged the event. 
            <para>This field may return -1 for some events when the process ID is not known.</para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ProcessName">
            <summary>
            Returns a short name for the process. This the image file name (without the path or extension),
            or if that is not present, then the string 'Process(XXXX)' 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ProcessorNumber">
            <summary>
            The processor Number (from 0 to TraceEventSource.NumberOfProcessors) that logged this event. 
            event. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.PointerSize">
            <summary>
            Get the size of a pointer associated with process that logged the event (thus it is 4 for a 32 bit process). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ActivityID">
            <summary>
            Conceptually every ETW event can be given a ActivityID (GUID) that uniquely identifies the logical
            work being carried out (the activity).  This property returns this GUID.   Can return Guid.Empty
            if the thread logging the event has no activity ID associated with it.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.RelatedActivityID">
            <summary>
            ETW supports the ability to take events with another GUID called the related activity that is either
            causes or is caused by the current activity.   This property returns that GUID (or Guid.Empty if the
            event has not related activity.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.FormattedMessage">
            <summary>
            Event Providers can define a 'message' for each event that are meant for human consumption.   
            FormattedMessage returns this string with the values of the payload filled in at the appropriate places.
            <para>It will return null if the event provider did not define a 'message'  for this event</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetFormattedMessage(System.IFormatProvider)">
            <summary>
            Creates and returns the value of the 'message' for the event with payload values substituted.
            Payload values are formatted using the given formatProvider. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.EventIndex">
            <summary>
            An EventIndex is a integer that is guaranteed to be unique for this event over the entire log.  Its
            primary purpose is to act as a key that allows side tables to be built up that allow value added
            processing to 'attach' additional data to this particular event unambiguously.  
            <para>This property is only set for ETLX file.  For ETL or real time streams it returns 0</para>
            <para>EventIndex is currently a 4 byte quantity.  This does limit this property to 4Gig of events</para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Source">
            <summary>
            The TraceEventSource associated with this event.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.IsClassicProvider">
            <summary>
            Returns true if this event is from a Classic (Pre-VISTA) provider
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.ContainerID">
            <summary>
            The ID of the container that emitted the event, if available.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.PayloadNames">
            <summary>
            Returns the names of all the manifest declared field names for the event.    May be empty if the manifest is not available.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.PayloadValue(System.Int32)">
            <summary>
            Given an index from 0 to PayloadNames.Length-1, return the value for that payload item as an object (boxed if necessary).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.PayloadString(System.Int32,System.IFormatProvider)">
            <summary>
            PayloadString is like PayloadValue(index).ToString(), however it can do a better job in some cases.  In particular
            if the payload is a enumeration or a bitfield and the manifest defined the enumeration values, then it will print the string name
            of the enumeration value instead of the integer value.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.PayloadIndex(System.String)">
            <summary>
            Returns the index in 'PayloadNames for field 'propertyName'.  Returns something less than 0 if not found. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.PayloadByName(System.String)">
            <summary>
            PayloadByName fetches the value of a payload property by the name of the property. 
            <para>It will return null if propertyName is not found.</para>
            <para>This method is not intended to be used in performance critical code.</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.PayloadStringByName(System.String,System.IFormatProvider)">
            <summary>
            PayloadStringByName functions the same as PayloadByName, but uses PayloadString instead of PayloadValue. 
            <para>It will return null if propertyName is not found.</para>
            <para>This method is not intended to be used in performance critical code.</para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.EventDataLength">
            <summary>
            The size of the event-specific data payload.  (see EventData)
            <para>Normally this property is not used because some TraceEventParser has built a subclass of
            TraceEvent that parses the payload</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.EventData">
            <summary>
            Returns an array of bytes representing the event-specific payload associated with the event.  
            <para>Normally this method is not used because some TraceEventParser has built a subclass of
            TraceEvent that parses the payload</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.EventData(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the event data and puts it in 'targetBuffer' at 'targetStartIndex' and returns the resulting buffer.
            If 'targetBuffer is null, it will allocate a buffer of the correct size. 
            <para>Normally this method is not used because some TraceEventParser has built a subclass of
            TraceEvent that parses the payload</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Clone">
            <summary>
            The events passed to the callback functions only last as long as the callback, so if you need to
            keep the information around after that you need to copy it.   This method makes that copy.
            <para>This method is more expensive than copy out all the event data from the TraceEvent instance
            to a type of your construction.</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.ToString">
            <summary>
            Pretty print the event.  It uses XML syntax.. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.ToString(System.IFormatProvider)">
            <summary>
            Pretty print the event using XML syntax, formatting data using the supplied IFormatProvider
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.ToXml(System.Text.StringBuilder)">
            <summary>
            Write an XML representation to the stringBuilder sb and return it.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.ToXml(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>
            Writes an XML representation of the event to a StringBuilder sb, formatting data using the passed format provider. 
            Returns the StringBuilder.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Dump(System.Boolean,System.Boolean)">
            <summary>
            Dumps a very verbose description of the event, including a dump of they payload bytes. It is in
            XML format. This is very useful in debugging (put it in a watch window) when parsers are not
            interpreting payloads properly.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEvent.EventTypeUserData">
            <summary>
            EventTypeUserData is a field users get to use to attach their own data on a per-event-type basis.    
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.DataStart">
            <summary>
            Returns the raw IntPtr pointer to the data blob associated with the event.  This is the way the
            subclasses of TraceEvent get at the data to display it in a efficient (but unsafe) manner.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.#ctor(System.Int32,System.Int32,System.String,System.Guid,System.Int32,System.String,System.Guid,System.String)">
            <summary>
            Create a template with the given event meta-data.  Used by TraceParserGen.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.SkipUTF8String(System.Int32)">
            <summary>
            Skip UTF8 string starting at 'offset' bytes into the payload blob.
            </summary>  
            <returns>Offset just after the string</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.SkipUnicodeString(System.Int32)">
            <summary>
            Skip Unicode string starting at 'offset' bytes into the payload blob.
            </summary>  
            <returns>Offset just after the string</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.SkipUnicodeString(System.Int32,System.Int32)">
            <summary>
            Skip 'stringCount' Unicode strings starting at 'offset' bytes into the payload blob.
            </summary>  
            <returns>Offset just after the last string</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.SkipSID(System.Int32)">
            <summary>
            Skip a Security ID (SID) starting at 'offset' bytes into the payload blob.
            </summary>  
            <returns>Offset just after the Security ID</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.HostOffset(System.Int32,System.Int32)">
            <summary>
            Trivial helper that allows you to get the Offset of a field independent of 32 vs 64 bit pointer size.
            </summary>
            <param name="offset">The Offset as it would be on a 32 bit system</param>
            <param name="numPointers">The number of pointer-sized fields that came before this field.
            </param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.HostSizePtr(System.Int32)">
            <summary>
            Computes the size of 'numPointers' pointers on the machine where the event was collected.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetUTF8StringAt(System.Int32)">
            <summary>
            Given an Offset to a null terminated ASCII string in an event blob, return the string that is
            held there.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetFixedAnsiStringAt(System.Int32,System.Int32)">
            <summary>
            Returns the string represented by a fixed length ASCII string starting at 'offset' of length 'charCount'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetFixedUnicodeStringAt(System.Int32,System.Int32)">
            <summary>
            Given an Offset to a fixed sized string at 'offset', whose buffer size is 'charCount'
            Returns the string value.  A null in the string will terminate the string before the
            end of the buffer. 
            </summary>        
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetIPAddrV6At(System.Int32)">
            <summary>
            Returns the encoding of a Version 6 IP address that has been serialized at 'offset' in the payload bytes.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetGuidAt(System.Int32)">
            <summary>
            Returns the GUID serialized at 'offset' in the payload bytes. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetDateTimeAt(System.Int32)">
            <summary>
            Get the DateTime that serialized (as a windows FILETIME) at 'offset' in the payload bytes. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetUnicodeStringAt(System.Int32)">
            <summary>
            Given an Offset to a null terminated Unicode string in an payload bytes, return the string that is
            held there.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetByteArrayAt(System.Int32,System.Int32)">
            <summary>
            Give an offset to a byte array of size 'size' in the payload bytes, return a byte[] that contains
            those bytes.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetByteAt(System.Int32)">
            <summary>
            Returns a byte value that was serialized at 'offset' in the payload bytes
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetInt16At(System.Int32)">
            <summary>
            Returns a short value that was serialized at 'offset' in the payload bytes
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetInt32At(System.Int32)">
            <summary>
            Returns an int value that was serialized at 'offset' in the payload bytes
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetInt64At(System.Int32)">
            <summary>
            Returns a long value that was serialized at 'offset' in the payload bytes
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetIntPtrAt(System.Int32)">
            <summary>
            Get something that is machine word sized for the provider that collected the data, but is an
            integer (and not an address)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetAddressAt(System.Int32)">
            <summary>
            Gets something that is pointer sized for the provider that collected the data.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetSingleAt(System.Int32)">
            <summary>
            Returns an int float (single) that was serialized at 'offset' in the payload bytes
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.GetDoubleAt(System.Int32)">
            <summary>
            Returns an int double precision floating point value that was serialized at 'offset' in the payload bytes
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttrib(System.Text.StringBuilder,System.String,System.String)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttrib(System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttrib(System.Text.StringBuilder,System.String,System.Int64)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttribHex(System.Text.StringBuilder,System.String,System.UInt64)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttribHex(System.Text.StringBuilder,System.String,System.Int64)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttribHex(System.Text.StringBuilder,System.String,System.UInt32)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttribHex(System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.XmlAttrib(System.Text.StringBuilder,System.String,System.Object)">
            <summary>
            Write the XML attribute 'attribName' with value 'value' to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Prefix(System.Text.StringBuilder)">
            <summary>
            Prints a standard prefix for a event (includes the time of the event, the process ID and the
            thread ID.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.ThreadIDforStacks">
            <summary>
            Because we want the ThreadID to be the ID of the CREATED thread, and the stack 
            associated with the event is the parentThreadID 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.Target">
            <summary>
            Returns (or sets) the delegate associated with this event.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.SetState(System.Object)">
            <summary>
            If this TraceEvent belongs to a parser that needs state, then this callback will set the state.  
            Parsers with state are reasonably rare, the main examples are KernelTraceEventParser and ClrTraceEventParser.    
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.TimeStampQPC">
            <summary>
            Returns the Timestamp for the event using Query Performance Counter (QPC) ticks.   
            The start time for the QPC tick counter is arbitrary and the units  also vary.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.LogCodeAddresses(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64,System.Boolean})">
            <summary>
            A standard way for events to are that certain addresses are addresses in code and ideally have
            symbolic information associated with them.  Returns true if successful.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEvent.IsEventWriteString">
            <summary>
            Was this written with the windows EventWriteString API? (see also EventDataAsString)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Compare(Microsoft.Diagnostics.Tracing.EventIndex,Microsoft.Diagnostics.Tracing.EventIndex)">
            <summary>
            Used for binary searching of event IDs.    Abstracts the size (currently a int, could go to long) 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Matches(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Returns true if the two traceEvents have the same identity.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Finalize">
            <summary>
            Normally TraceEvent does not have unmanaged data, but if you call 'Clone' it will.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.DumpArray(System.Byte[],System.Int32)">
            <summary>
            For debugging. dumps an array.   If you specify a size of 0 (the default) it dumps the whole array.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.EventDataAsString">
            <summary>
             If the event data looks like a unicode string, then return it.  This is heuristic.  (See also IsEventWriteString)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Dispatch">
            <summary>
            Each TraceEvent items knows where it should Dispatch to.
            ETWTraceEventSource.Dispatch calls this function to go to the right placed. By default we
            do nothing. Typically a subclass just dispatches to another callback that passes itself to a
            type-specific event callback.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.Validate">
            <summary>
            This is a DEBUG-ONLY routine that allows a routine to do consistency checking in a debug build.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEvent.DebugValidate">
            <summary>
            Validate that the events is not trash.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEvent.next">
            <summary>
            TraceEvent knows where to dispatch to. To support many subscriptions to the same event we chain
            them.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEvent.payloadNames">
            <summary>
            The array of names for each property in the payload (in order).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventID">
            <summary>
            Individual event providers can supply many different types of events.  These are distinguished from each
            other by a TraceEventID, which is just a 16 bit number.  Its meaning is provider-specific.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventID.Illegal">
            <summary>
            Illegal is a EventID that is not used by a normal event.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventChannel">
            <summary>
            Providers can define different audiences or Channels for an event (eg Admin, Developer ...).
            It is only used for Windows Event log support.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventChannel.Default">
            <summary>
            The default channel.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventOpcode">
            <summary>
            There are certain classes of events (like start and stop) which are common across a broad variety of
            event providers for which it is useful to treat uniformly (for example, determining the elapsed time
            between a start and stop event).  To facilitate this, event can have opcode which defines these
            common operations.  Below are the standard ones but providers can define additional ones.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Info">
            <summary>
            Generic opcode that does not have specific semantics associated with it. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Start">
            <summary>
            The entity (process, thread, ...) is starting
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Stop">
            <summary>
            The entity (process, thread, ...) is stoping (ending)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.DataCollectionStart">
            <summary>
            The entity (process, thread, ...) did not terminate before data collection ended, so indicate
            this at data collection termination time.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.DataCollectionStop">
            <summary>
            The entity (process, thread, ...) did not terminate before data collection ended, so indicate
            this at data collection termination time. This is mostly for 'flight recorder' scenarios where
            you only have the 'tail' of the data and would like to know about everything that existed. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Extension">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Reply">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Resume">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Suspend">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventOpcode.Transfer">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventLevel">
            <summary>
            Indicates to a provider whether verbose events should be logged.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventLevel.Always">
            <summary>
            Always log the event (It also can mean that the provider decides the verbosity)  You probably should not use it....
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventLevel.Critical">
            <summary>
            Events that indicate critical conditions
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventLevel.Error">
            <summary>
            Events that indicate error conditions
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventLevel.Warning">
            <summary>
            Events that indicate warning conditions
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventLevel.Informational">
            <summary>
            Events that indicate information
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventLevel.Verbose">
            <summary>
            Events that verbose information
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventKeyword">
            <summary>
            ETW defines the concept of a Keyword, which is a 64 bit bitfield. Each bit in the bitfield
            represents some provider defined 'area' that is useful for filtering. When processing the events, it
            is then possible to filter based on whether various bits in the bitfield are set.  There are some
            standard keywords, but most are provider specific. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventKeyword.None">
            <summary>
            No event groups (keywords) selected
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventKeyword.All">
            <summary>
            All event groups (keywords) selected
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventTask">
            <summary>
            Tasks are groups of related events for a given provider (for example Process, or Thread, Kernel Provider).  
            They are defined by the provider.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventTask.Default">
            <summary>
            If you don't explicitly choose a task you get the default 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventIndex">
            <summary>
            EventIdex is a unsigned integer that is unique to a particular event. EventIndex is guaranteed to be 
            unique over the whole log.  It is only used by ETLX files.  
            <para>
            Currently the event ID simply the index in the log file of the event.  We don't however guarantee ordering.
            In the future we may add new events to the log and given them IDs 'at the end' even if the events are not
            at the end chronologically.  
            </para>
            <para>
            EventIndex is a 32 bit number limits it to 4Gig events in an ETLX file.  
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.EventIndex.Invalid">
            <summary>
            Invalid is an EventIndex that will not be used by a normal event. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ITraceParserServices">
            <summary>
            TraceEventSource has two roles.  The first is the obvious one of providing some properties
            like 'SessionStartTime' for clients.  The other role is provide an interface for TraceEventParsers
            to 'hook' to so that events can be decoded.  ITraceParserServices is the API service for this
            second role.  It provides the methods that parsers register templates for subclasses of 
            the TraceEvent class that know how to parse particular events.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ITraceParserServices.RegisterEventTemplate(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            RegisterEventTemplate is the mechanism a particular event payload description 'template' 
            (a subclass of TraceEvent) is injected into the event processing stream. Once registered, an
            event is 'parsed' simply by setting the 'rawData' field in the event. It is up to the template
            then to take this raw data an present it in a useful way to the user (via properties). Note that
            parsing is thus 'lazy' in no processing of the raw data is not done at event dispatch time but
            only when the properties of an event are accessed.
            
            Ownership of the template transfers when this call is made.   The source will modify this and
            assumes it has exclusive use (thus you should clone the template if necessary).  
            <para>
            Another important aspect is that templates are reused by TraceEventSource aggressively. The
            expectation is that no memory needs to be allocated during a normal dispatch 
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ITraceParserServices.UnregisterEventTemplate(System.Delegate,System.Int32,System.Guid)">
            <summary>
            UnregisterEventTemplate undoes the action of RegisterEventTemplate.   Logically you would 
            pass the template to unregister, but typically you don't have that at unregistration time.
            To avoid forcing clients to remember the templates they registered, UnregisterEventTemplate
            takes three things that will uniquely identify the template to unregister.   These are
            the eventID, and provider ID and the Action (callback) for the template.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ITraceParserServices.RegisterParser(Microsoft.Diagnostics.Tracing.TraceEventParser)">
            <summary>
            It is expected that when a subclass of TraceEventParser is created, it calls this
            method on the source.  This allows the source to do any Parser-specific initialization.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ITraceParserServices.RegisterUnhandledEvent(System.Func{Microsoft.Diagnostics.Tracing.TraceEvent,System.Boolean})">
            <summary>
            Indicates that this callback should be called on any unhandled event.   The callback
            returns true if the lookup should be retried after calling this (that is there is
            the unhandled event was found).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ITraceParserServices.TaskNameForGuid(System.Guid)">
            <summary>
            Looks if any provider has registered an event with task with 'taskGuid'. Will return null if
            there is no registered event.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ITraceParserServices.ProviderNameForGuid(System.Guid)">
            <summary>
            Looks if any provider has registered with the given GUID OR has registered any task that matches
            the GUID. Will return null if there is no registered event.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventParser">
            <summary>
            TraceEventParser Represents a class that knows how to decode particular set of events (typically
            all the events of a single ETW provider).  It is expected that subclasses of TraceEventParser 
            have a constructor that takes a TraceEventSource as an argument that 'attaches' th parser 
            to the TraceEventSource.  TraceEventParsers break into two groups.
            <para>
            * Those that work on a single provider, and thus the provider name is implicit in th parser.  This is the common case.
            The AddCallbackForEvent* methods are meant to be used for these TraceEventParsers</para>
            <para>
            * Those that work on multiple providers.  There are only a handful of these (DynamicTraceEventParser, ...). 
            The AddCallbackForProviderEvent* methods which take 'Provider' parameters are meant to be used for these TraceEventParsers
            </para>
            <para>
            In addition to the AddCallback* methods on TraceEventParser, there are also Observe* extension methods that
            provide callbacks using the IObservable style.  
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventParser.Source">
            <summary>
            Get the source this TraceEventParser is attached to. 
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.TraceEventParser.All">
            <summary>
            Subscribe to all the events this parser can parse.  It is shorthand for AddCallback{TraceEvent}(value)/RemoveCallback(value)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForEvent``1(System.String,System.Action{``0})">
            <summary>
            A shortcut that adds 'callback' in the provider associated with this parser (ProvderName) and an event name 'eventName'.  'eventName'
            can be null in which case any event that matches 'Action{T}' will call the callback.    
            'eventName is of the form 'TaskName/OpcodeName'   if the event has a non-trivial opcode, otherwise it is 'TaskName'.   
            <para>
            The callback alone is used as the subscription id for unregistration, so the callback delegate should be unique (by delegate comparison)
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForEvents``1(System.Action{``0})">
            <summary>
            Causes 'callback' to be called for any event in the provider associated with this parser (ProviderName) whose type is compatible with T and 
            whose eventName will pass 'eventNameFilter'.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForEvents``1(System.Predicate{System.String},System.Action{``0})">
            <summary>
            Causes 'callback' to be called for any event in the provider associated with this parser (ProviderName) whose type is compatible with T and 
            whose eventName will pass 'eventNameFilter'.    The eventNameFilter parameter can be null, in which case all events that are compatible 
            with T will be selected. 
            
            eventNames passed to the filer are of the form 'TaskName/OpcodeName'   if the event has a non-trivial opcode, otherwise it is 'TaskName'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForEvents``1(System.Predicate{System.String},System.Object,System.Action{``0})">
            <summary>
            Causes 'callback' to be called for any event in the provider associated with this parser (ProviderName) whose type is compatible with T and 
            whose eventName will pass 'eventNameFilter'.    The eventNameFilter parameter can be null, in which case all events that are compatible 
            with T will be selected.  
            <para>
            A 'subscriptionID' can be passed and this value along with the callback can be used
            to uniquely identify subscription to remove using the 'RemoveCallback' API.   If null is passed, then only the identity of the callback can
            be used to identify the subscription to remove.  
            
            eventNames passed to the filer are of the form 'TaskName/OpcodeName'   if the event has a non-trivial opcode, otherwise it is 'TaskName'. 
            </para>        
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForProviderEvent(System.String,System.String,System.Action{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            A shortcut that adds 'callback' for the event in 'providerName' and an event name 'eventName'
            The callback alone is used as the subscription id for unregistration, so the callback delegate should be unique (by delegate comparison)
            
            eventName is of the of the form 'TaskName/OpcodeName'   if the event has a non-trivial opcode, otherwise it is 'TaskName'. 
            
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForProviderEvents(System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Action{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            Cause 'callback' to be called for any event that this parser recognizes for which the function 'eventsToObserve'
            returns 'AcceptEvent'.   The 'eventsToObserve is given both the provider name (first) and the event name and can return
            'AcceptEvent' 'RejectEvent' or 'RejectProvider' (in which case it may not be called again for that provider).  
            eventsToObserver can be null in which case all events that match the parser recognizes are selected. 
            
            eventNames passed to the filer are of the form 'TaskName/OpcodeName'   if the event has a non-trivial opcode, otherwise it is 'TaskName'. 
            
            <para>
            Thus this method works for parsers that parse more than one provider (e.g. DynamicTraceEventParser).   
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.AddCallbackForProviderEvents(System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Object,System.Action{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            Cause 'callback' to be called for any event that this parser recognizes for which the function 'eventsToObserve'
            returns 'AcceptEvent'.   The 'eventsToObserve is given both the provider name (first) and the event name and can return
            'AcceptEvent' 'RejectEvent' or 'RejectProvider' (in which case it may not be called again for that provider).  
            eventsToObserver can be null in which case all events that match the parser recognizes are selected. 
            
            eventNames passed to the filer are of the form 'TaskName/OpcodeName'   if the event has a non-trivial opcode, otherwise it is 'TaskName'.         /// 
            <para>
            Thus this method works for parsers that parse more than one provider (e.g. DynamicTraceEventParser).   
            </para><para>
            A subscriptionID can optionally be passed.  This is used (along with the callback identity) to identify this to the 'RemoveCallback' If you
            don't need to remove the callback or you will do it in bulk, you don't need this parameter.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.RemoveCallback``1(System.Action{``0},System.Object)">
            <summary>
            Remove all subscriptions added with 'AddCallback' (any overload), that is compatible with T, has a callback 'callback' and subscriptionId 'subscriptionId' 
            where 'subscriptionId' was the value that was optionally passed to 'AddCallback' to provide exactly this disambiguation.  
            <para>
            'callback' or 'subscriptionId' can be null, in which case it acts as a wild card.  Thus RemoveCallback{TraceEvent}(null, null) will remove all callbacks 
            that were registered through this parser.  
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventParser.IsStatic">
            <summary>
            A static TraceEventParser is a parser where the set of events that can be subscribed to (and their payload fields) are known at 
            compile time.  There are very few dynamic TraceEventParsers (DynamicTraceEventParser, RegisteredTraceEventParser and WPPTraceEventParser)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.#ctor(Microsoft.Diagnostics.Tracing.TraceEventSource,System.Boolean)">
            <summary>
            All TraceEventParsers invoke this constructor.  If 'dontRegister' is true it is not registered with the source. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.GetProviderName">
            <summary>
            Normally a TraceEvent parser knows how to parse only one provider.   If this is true
            ProviderName returns the name of this provider.  If the parser knows how to parse 
            more than one provider, this property returns null.     
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventParser.StateObject">
            <summary>
            If the parser needs to persist data along with the events we put it in a separate object.   
            This object and then implement serialization functionality that allows it to be persisted (this is for ETLX support).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.EnumerateTemplates(System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Action{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            Returns a list of all templates currently existing (new ones can come in, but OnNewEventDefintion must be called 
            whenever that happens.   Note that the returned templates MUST be cloned and do not have their source or parser state
            fields set.  These must be set as part of subscription (after you know if you care about them or not).  
            
            eventsToObserver is given the provider name and event name and those events that return AcceptEvent will
            have the 'callback' function called on that template.   eventsToObserver can be null which mean all events.  
            
            The returned template IS READ ONLY!   If you need a read-write copy (typical), clone it first.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.OnNewEventDefintion(Microsoft.Diagnostics.Tracing.TraceEvent,System.Boolean)">
            <summary>
            If the parser can change over time (it can add new definitions),  It needs to support this interface.  See EnumerateDynamicTemplates for details.
            This function should be called any time a new event is now parsable by the parser.   If it is guaranteed that the particular event is 
            definitely being ADDED (it never existed in the past), then you can set 'mayHaveExistedBefore' to false and save some time.  
             
            It returns false if there are no definitions for that particular Provider (and thus you can skip callback if desired).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.Subscribe(Microsoft.Diagnostics.Tracing.TraceEventParser.SubscriptionRequest,Microsoft.Diagnostics.Tracing.TraceEvent,System.Object,System.Boolean)">
            <summary>
            Given a subscription request, and a template that can now be parsed (and its state, which is just TraceEventParser.StateObj) 
            If subscription states that the template should be registered with the source, then do the registration.   
            
            if 'mayHaveExistedBefore' means that this template definition may have been seen before (DynamicTraceEventParsers do this as
            you may get newer versions dynamically registering themselves).   In that case this should be set.  If you can guaranteed that
            a particular template (provider-eventID pair) will only be subscribed at most once you can set this to false.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventParser.SubscriptionRequest">
            <summary>
            Keeps track of a single 'AddCallback' request so it can be removed later.   It also handles lazy addition of events.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventParser.SubscriptionRequest.#ctor(System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse},System.Delegate,System.Object)">
            <summary>
            Create a subscription request.  'eventsToObserve takes a provider name (first) and a event name and returns a three valued EventFilterResponse
            value (accept, reject, reject provider)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.TraceEventParser.source">
            <summary>
            The source that this parser is connected to.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EventFilterResponse">
            <summary>
            EventFilterResponse is the set of responses  a user-defined filtering routine, might return.  This is used in the TraceEventParser.AddCallbackForProviderEvents method.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.EventFilterResponse.RejectEvent">
            <summary>
            Not an interesting event, but other events in the same provider may be
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.EventFilterResponse.RejectProvider">
            <summary>
            No event in the provider will be accepted
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.EventFilterResponse.AcceptEvent">
            <summary>
             An interesting event
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventDispatcherOptions">
            <summary>
            An options class for the TraceEventDispatcher
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventDispatcherOptions.StartTime">
            <summary>
            StartTime from which you want to start analyzing the events for file formats that support this.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.TraceEventDispatcherOptions.EndTime">
            <summary>
            EndTime till when you want to analyze events for file formats that support this.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventDispatcher">
            <summary>
            A TraceEventDispatcher is a TraceEventSource that supports a callback model for dispatching events.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.GetDispatcherFromFileName(System.String,Microsoft.Diagnostics.Tracing.TraceEventDispatcherOptions)">
            <summary>
            Obtains the correct TraceEventDispatcher for the given trace file name.
            </summary>
            <param name="traceFileName">A path to a trace file.</param>
            <returns>A TraceEventDispatcher for the given trace file.</returns>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.UnhandledEvents">
            <summary>
            Subscribers to UnhandledEvent are called if no other hander has processed the event.   It is
            generally used in DEBUG builds to validate that events are getting to the source at all.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.AllEvents">
            <summary>
            Subscribers to EveryEvent are called on every event in the trace.   Normally you don't want
            to subscribe to this but rather use a TraceEvenParser (which knows how to decode the payloads)
            and subscribe to particular events through that.   For example Using TraceEventSource.Dynamic.All 
            or TraceEventSource.Dynamic.All is more likely to be what you are looking for.   AllEvents is only
            an event callback of last resort, that only gives you the 'raw' data (common fields but no
            payload).  
            <para>
            This is called AFTER any event-specific handlers.
            </para>
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.UnhandledEvent">
            <summary>
            Subscribers to UnhandledEvent are called if no other hander has processed the event.   It is
            generally used in DEBUG builds to validate that events are getting to the source at all.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.EveryEvent">
            <summary>
            Subscribers to EveryEvent are called on every event in the trace.   Normally you don't want
            to subscribe to this but rather use a TraceEvenParser and subscribe to particular events
            through that.   
            <para>
            This is called AFTER any event-specific handlers.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Process">
            <summary>
            Once a client has subscribed to the events of interest, calling Process actually causes
            the callbacks to happen.   
            <para>
            Subclasses implementing this method should call 'OnCompleted' 
            before returning.  
            </para>
            </summary>
            <returns>false If StopProcessing was called</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.StopProcessing">
            <summary>
            Calling StopProcessing in a callback when 'Process()' is running will indicate that processing
            should be stopped immediately and that the Process() method should return.  
            
            Note that this stop request will not be honored until the next event from the source.   Thus
            for real time sessions there is an indeterminate delay before the stop will complete.   
            If you need to force the stop you should instead call Dispose() on the session associated with 
            the real time session.  This will cause the source to be shut down and thus also stop processing
            (Process() will return) but is guaranteed to complete in a timely manner.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Completed">
            <summary>
            Subscribers of Completed will be called after processing is complete (right before TraceEventDispatcher.Process returns.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.AddDispatchHook(System.Action{Microsoft.Diagnostics.Tracing.TraceEvent,System.Action{Microsoft.Diagnostics.Tracing.TraceEvent}})">
            <summary>
            Wrap (or filter) the dispatch of every event from the TraceEventDispatcher stream.   
            Instead of calling the normal code it calls 'hook' with both the event to be dispatched
            and the method the would normally do the processing.    Thus the routine has 
            the option to call normal processing, surround it with things like a lock
            or skip it entirely.  This can be called more than once, in which case the last
            hook method gets called first (which may end up calling the second ...)
            
            For example,here is an example that uses AddDispatchHook to 
            take a lock is taken whenever dispatch work is being performed.  
            
            AddDispatchHook((anEvent, dispatcher) => { lock (this) { dispatcher(anEvent); } });
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.OnCompleted">
            <summary>
            Called when processing is complete.  You can call this more than once if your not sure if it has already been called.  
            however we do guard against races.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.DistinctCallbackCount">
            <summary>
             Number of different events that have callbacks associated with them 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.CallbackCount">
            <summary>
            Total number of callbacks that are registered.  Even if they are for the same event.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Dispatch(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            This is the routine that is called back when any event arrives.  Basically it looks up the GUID
            and the opcode associated with the event and finds right subclass of TraceEvent that
            knows how to decode the packet, and calls its virtual TraceEvent.Dispatch method.  Note
            that TraceEvent does NOT have a copy of the data, but rather just a pointer to it. 
            This data is ONLY valid during the callback. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Lookup(Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_RECORD*)">
            <summary>
            Lookup up the event based on its ProviderID (GUID) and EventId (Classic use the TaskId and the
            Opcode field for lookup, but use these same fields (see ETWTraceEventSource.RawDispatchClassic)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Dispose(System.Boolean)">
            <summary>
            Dispose pattern. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Finalize">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.Insert(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Inserts 'template' into the hash table, using 'providerGuid' and and 'eventID' as the key. 
            For Vista ETW events 'providerGuid' must match the provider GUID and the 'eventID' the ID filed.
            For PreVist ETW events 'providerGuid must match the task GUID the 'eventID' is the Opcode
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceEventDispatcher.GenTaskGuidFromProviderGuid(System.Guid,System.UInt16)">
            <summary>
            A helper for creating a set of related guids (knowing the providerGuid can can deduce the
            'taskNumber' member of this group.  All we do is add the taskNumber to GUID as a number.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.EmptyTraceData">
            <summary>
            TraceEventParsers can use this template to define the event for the trivial case where the event has no user-defined payload  
            <para>This is only useful to TraceEventParsers.</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EmptyTraceData.#ctor(System.Action{Microsoft.Diagnostics.Tracing.EmptyTraceData},System.Int32,System.Int32,System.String,System.Guid,System.Int32,System.String,System.Guid,System.String)">
            <summary>
            Construct a TraceEvent template which has no payload fields with the given metadata and action
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EmptyTraceData.ToXml(System.Text.StringBuilder)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.EmptyTraceData.PayloadNames">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EmptyTraceData.PayloadValue(System.Int32)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.EmptyTraceData.Dispatch">
            <summary>
            Dispatches the event to the action associated with the template. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.EmptyTraceData.Target">
            <summary>
            override
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.StringTraceData">
            <summary>
            When the event has just a single string value associated with it, you can use this shared event
            template rather than making an event-specific class.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StringTraceData.Value">
            <summary>
            The value of the one string payload property.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StringTraceData.#ctor(System.Action{Microsoft.Diagnostics.Tracing.StringTraceData},System.Int32,System.Int32,System.String,System.Guid,System.Int32,System.String,System.Guid,System.String,System.Boolean)">
            <summary>
            Construct a TraceEvent template which has one string payload field with the given metadata and action
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StringTraceData.ToXml(System.Text.StringBuilder)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StringTraceData.PayloadNames">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StringTraceData.PayloadValue(System.Int32)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.StringTraceData.Dispatch">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.StringTraceData.Target">
            <summary>
            override
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent">
            <summary>
            UnhandledTraceEvent is a TraceEvent when is used when no manifest information is available for the event. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.ToXml(System.Text.StringBuilder)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.PayloadNames">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.PayloadValue(System.Int32)">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.Dispatch">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.Target">
            <summary>
            override
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.ToString">
            <summary>
            implementation of TraceEvent Interface. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.UnhandledTraceEvent.PrepForCallback">
            <summary>
            There is some work needed to prepare the generic unhandledTraceEvent that we defer
            late (since we often don't care about unhandled events)  
            
            TODO this is probably not worht the complexity...
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ObservableExtensions">
            <summary>
            ObservableExtensions defines methods on TraceEventParser that implement the IObservable protocol for implementing callbacks.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ObservableExtensions.Observe``1(Microsoft.Diagnostics.Tracing.TraceEventParser,System.String)">
            <summary>
            Returns an IObjservable that observes all events that 'parser' knows about that  return a T.  If eventName is
            non-null, the event's name must match 'eventName', but if eventName is null, any event that returns a T is observed. 
            <para>
            This means that Observe{TraceEvent}(parser) will observe all events that the parser can parse.  
            
            Note that unlike the methods on TraceEventParser, the TraceEvent object returned is already Cloned() and thus can be 
            referenced for as long as you like.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ObservableExtensions.Observe``1(Microsoft.Diagnostics.Tracing.TraceEventParser,System.Predicate{System.String})">
            <summary>
            Returns an IObjservable that observes all events that 'parser' knows about that return a T and whose event
            name matches the 'eventNameFilter' predicate.  
            
            Note that unlike the methods on TraceEventParser, the TraceEvent object returned is already Cloned() and thus can be 
            referenced for as long as you like.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ObservableExtensions.Observe(Microsoft.Diagnostics.Tracing.TraceEventParser,System.String,System.String)">
            <summary>
            Observe a particular event from a particular provider.   If eventName is null, it will return every event from the provider
             
            Note that unlike the methods on TraceEventParser, the TraceEvent object returned is already Cloned() and thus can be 
            referenced for as long as you like.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ObservableExtensions.Observe(Microsoft.Diagnostics.Tracing.TraceEventParser,System.Func{System.String,System.String,Microsoft.Diagnostics.Tracing.EventFilterResponse})">
            <summary>
            Given a predicate 'eventToObserve' which takes the name of a provider (which may be of the form Provider(GUID)) (first) and 
            an event name (which may be of the form EventID(NUM)) and indicates which events to observe, return an IObservable
            that observes those events. 
            
            Note that unlike the methods on TraceEventParser, the TraceEvent object returned is already Cloned() and thus can be 
            referenced for as long as you like.  . 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ObservableExtensions.ObserveAll(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            Returns an observable that observes all events from the event source 'source'
            
            Note that unlike the methods on TraceEventParser, the TraceEvent object returned is already Cloned() and thus can be 
            referenced for as long as you like.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ObservableExtensions.ObserveUnhandled(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            Returns an observable that observes all events from the event source 'source' which are not handled by a callback connected to 'source'
            
            Note that unlike the methods on TraceEventParser, the TraceEvent object returned is already Cloned() and thus can be 
            referenced for as long as you like.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ObservableExtensions.TraceEventObservable`1">
            <summary>
            A TraceEventObservable is a helper class that implements the IObservable pattern for TraceEventDispatcher 
            (like ETWTraceEventDispatcher).  It is called from the TraceEventParser.Observe*{T} methods.  
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ObservableExtensions.TraceEventObservable`1.TraceEventSubscription">
            <summary>
            A TraceEventSubscription is helper class that hooks 'callback' and 'completedCallback' to the 'observable' and 
            unhooks them when 'Dispose' is called.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods">
            <summary>
            TraceEventNativeMethods contains the PINVOKE declarations needed
            to get at the Win32 TraceEvent infrastructure.  It is effectively
            a port of evntrace.h to C# declarations.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.TIME_ZONE_INFORMATION">
            <summary>
            Time zone info.  Used as one field of TRACE_EVENT_LOGFILE, below.
            Total struct size is 0xac.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.WNODE_HEADER">
            <summary>
            EventTraceHeader structure used by EVENT_TRACE_PROPERTIES
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_TRACE_PROPERTIES">
            <summary>
            EVENT_TRACE_PROPERTIES is a structure used by StartTrace, ControlTrace
            however it can not be used directly in the definition of these functions
            because extra information has to be hung off the end of the structure
            before being passed.  (LofFileNameOffset, LoggerNameOffset)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_TRACE_HEADER">
            <summary>
            EventTraceHeader and structure used to defined EVENT_TRACE (the main packet)
            I have simplified from the original struct definitions.  I have
            omitted alternate union-fields which we don't use.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_TRACE">
            <summary>
            EVENT_TRACE is the structure that represents a single 'packet'
            of data repesenting a single event.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.TRACE_LOGFILE_HEADER">
            <summary>
            TRACE_LOGFILE_HEADER is a header used to define EVENT_TRACE_LOGFILEW.
            Total struct size is 0x110.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_TRACE_LOGFILEW">
            <summary>
            EVENT_TRACE_LOGFILEW Main struct passed to OpenTrace() to be filled in.
            It represents the collection of ETW events as a whole.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_HEADER">
            <summary>
            EventTraceHeader and structure used to define EVENT_TRACE_LOGFILE (the main packet on Vista and above)
            I have simplified from the original struct definitions.  I have
            omitted alternate union-fields which we don't use.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.ETW_BUFFER_CONTEXT">
            <summary>
            Provides context information about the event
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_RECORD">
            <summary>
            Defines the layout of an event that ETW delivers
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ControllerCommand">
            <summary>
            Possible control commands (borrowed from EventSource)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ControllerCommand.Update">
            <summary>
            Standard 'update' command to send additional information to a provider
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.ControllerCommand.SendManifest">
            <summary>
            Instructs an EventSource-based provider to send its manifest
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventSession">
            <summary>
            A TraceEventSession represents a single ETW Tracing Session.   A session is and event sink that 
            can enable or disable event logging from event providers).    TraceEventSessions can log their
            events either to a file, or by issuing callbacks when events arrive (a so-called 'real time' 
            session).   
            <para>
            Session are MACHINE wide and unlike most OS resources the operating system does NOT reclaim 
            them when the process that created it dies.  By default TraceEventSession tries is best to
            do this reclamation, but it is possible that for 'orphan' session to accidentally survive
            if the process is ended abruptly (e.g. by the debugger or a user explicitly killing it).  It is 
            possible to turn off TraceEventSession automatic reclamation by setting the StopOnDispose 
            property to false (its default is true).  
            </para>
            <para> 
            Kernel events have additional restrictions.   In particular there is a special API (EnableKernelProvider).  
            Before Windows 8, there was a restriction that kernel events could only be enabled from a session 
            with a special name (see KernelTraceEventParser.KernelSessionName) and thus there could only be a single
            session that could log kernel events (and that session could not log non-kernel events).  These
            restrictions were dropped in windows 8. 
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.#ctor(System.String,System.String,Microsoft.Diagnostics.Tracing.Session.TraceEventSessionOptions)">
            <summary>
            Create a new logging session sending the output to a given file.  
            </summary>
            <param name="sessionName">
            The name of the session. Since session can exist beyond the lifetime of the process this name is
            used to refer to the session from other processes after it is created.   By default TraceEventSessions
            do their best to close down if the TraceEventSession dies (see StopOnDispose), however if StopOnDispose
            is set to false, the session can live on after process death, and you use the name to refer to it later.  
            </param>
            <param name="fileName">
            The output moduleFile (by convention .ETL) to put the event data.  If this is null, and CircularMB is set
            to something non-zero, then it will do an in-memory circular buffer.   You can get this buffer by 
            using the 'SetFileName()' method which dumps the data in the buffer.  
            </param>
            <param name="options">Additional flags that influence behavior.  Note that the 'Create' option is implied for file mode sessions. </param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.#ctor(System.String,Microsoft.Diagnostics.Tracing.Session.TraceEventSessionOptions)">
            <summary>
            Open a logging session.   By default (if options is not specified) a new 'real time' session is created if
            the session already existed it is closed and reopened (thus orphans are cleaned up on next use).  By default
            sessions are closed on Dispose, but if the destructor does not run it can produce 'orphan' session that will
            live beyond the lifetime of the process.   You can use the StopOnDispose property to force sessions to live
            beyond the TraceEventSession that created them and use the TraceEventSessionOptions.Attach option to reattach
            to these sessions.
            </summary>
            <param name="sessionName"> The name of the session to open.  Should be unique across the machine.</param>
            <param name="options"> Construction options.  TraceEventSessionOptions.Attach indicates a desire to attach
            to an existing session. </param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.GetActiveSession(System.String)">
            <summary>
            Looks for an existing active session named 'sessionName; and returns the TraceEventSession associated with it if it exists. 
            Returns null if the session does not exist.   You can use the GetActiveSessionNames() to get a list of names to pass to this method. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProvider(System.String,Microsoft.Diagnostics.Tracing.TraceEventLevel,System.UInt64,Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions)">
            <summary>
            Enable a NON-KERNEL provider (see also EnableKernelProvider) which has a given provider name.  
            This API first checks if a published provider exists by that name, otherwise it 
            assumes it is an EventSouce and determines the provider Guid by hashing the name according to a
            well known algorithm.  Thus it will never return a failure for a incorrect spelling of the name.  
            </summary>
            <param name="providerName">
            The name of the provider.  It must either be registered with the operating system (logman query providers returns it)
            or it must be an EventSource (see GetEventSourceGuidFromName)</param>
            <param name="providerLevel">The verbosity to turn on</param>
            <param name="matchAnyKeywords">A bitvector representing the areas to turn on. Only the
            low 32 bits are used by classic providers and passed as the 'flags' value.  Zero
            is a special value which is a provider defined default, which is usually 'everything'</param>
            <param name="options">Additional options for the provider (e.g. taking a stack trace), arguments ... </param>
            <returns>true if the session already existed and needed to be restarted.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProvider(System.Guid,Microsoft.Diagnostics.Tracing.TraceEventLevel,System.UInt64,Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions)">
            <summary>
            Enable a NON-KERNEL provider (see also EnableKernelProvider) which has a given provider Guid.  
            </summary>
            <param name="providerGuid">
            The Guid that represents the event provider enable. </param>
            <param name="providerLevel">The verbosity to turn on</param>
            <param name="matchAnyKeywords">A bitvector representing the areas to turn on. Only the
            low 32 bits are used by classic providers and passed as the 'flags' value.  Zero
            is a special value which is a provider defined default, which is usually 'everything'</param>
            <param name="options">Additional options for the provider (e.g. taking a stack trace), arguments ... </param>
            <returns>true if the session already existed and needed to be restarted.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProvider(System.String,Microsoft.Diagnostics.Tracing.TraceEventLevel,System.UInt64,Microsoft.Diagnostics.Tracing.Session.TraceEventOptions,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Enable a NON-KERNEL provider (see also EnableKernelProvider) which has a given provider name.  
            This API first checks if a published provider exists by that name, otherwise it 
            assumes it is an EventSouce and determines the provider Guid by hashing the name according to a
            well known algorithm.  Thus it will never return a failure for a incorrect spelling of the name.  
            </summary>
            <param name="providerName">
            The name of the provider.  It must either be registered with the operating system (logman query providers returns it)
            or it must be an EventSource (see GetEventSourceGuidFromName)</param>
            <param name="providerLevel">The verbosity to turn on</param>
            <param name="matchAnyKeywords">A bitvector representing the areas to turn on. Only the
            low 32 bits are used by classic providers and passed as the 'flags' value.  Zero
            is a special value which is a provider defined default, which is usually 'everything'</param>
            <param name="options">Additional options for the provider (e.g. taking a stack trace)</param>
            <param name="values">This is set of key-value strings that are passed to the provider
            for provider-specific interpretation. Can be null if no additional args are needed.  
            If the special key-value pair 'Command'='SendManifest' is provided, then the 'SendManifest'
            command will be sent (which causes EventSources to re-dump their manifest to the ETW log.  </param>
            <returns>true if the session already existed and needed to be restarted.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProvider(System.Guid,Microsoft.Diagnostics.Tracing.TraceEventLevel,System.UInt64,Microsoft.Diagnostics.Tracing.Session.TraceEventOptions,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Enable a NON-KERNEL provider (see also EnableKernelProvider) represented by 'providerGuid'.
            </summary>
            <param name="providerGuid">
            The Guid that represents the event provider enable. </param>
            <param name="providerLevel">The verbosity to turn on</param>
            <param name="matchAnyKeywords">A bitvector representing the areas to turn on. Only the
            low 32 bits are used by classic providers and passed as the 'flags' value.  Zero
            is a special value which is a provider defined default, which is usually 'everything'</param>
            <param name="options">Additional options for the provider (e.g. taking a stack trace)</param>
            <param name="values">This is set of key-value strings that are passed to the provider
            for provider-specific interpretation. Can be null if no additional args are needed.  
            If the special key-value pair 'Command'='SendManifest' is provided, then the 'SendManifest'
            command will be sent (which causes EventSources to re-dump their manifest to the ETW log.  </param>
            <returns>true if the session already existed and needed to be restarted.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProviderWithRawProviderData(System.Guid,Microsoft.Diagnostics.Tracing.TraceEventLevel,System.UInt64,Microsoft.Diagnostics.Tracing.Session.TraceEventOptions,System.Byte[],System.Int32)">
            <summary>
            Enable an ETW provider, passing a raw blob of data to the provider as a Filter specification.   
            
            Note that this routine is only provided to interact with old ETW providers that can interpret EVENT_FILTER_DESCRIPTOR data
            but did not conform to the key-value string conventions.   This allows this extra information to be passed to these old
            providers.   Ideally new providers follow the key-value convention and EnableProvider can be used.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.MakeDictionary(System.String[])">
            <summary>
            Helper function that is useful when using EnableProvider with key value pairs. 
            Given a list of key-value pairs, create a dictionary of the keys mapping to the values.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableKernelProvider(Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords,Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords)">
            <summary>
            Enable the kernel provider for the session. Before windows 8 this session must be called 'NT Kernel Session'.   
            This API is OK to call from one thread while Process() is being run on another
            <param name="flags">Specifies the particular kernel events of interest</param>
            <param name="stackCapture">
            Specifies which events should have their stack traces captured when an event is logged</param>
            <returns>Returns true if the session existed before and was restarted (see TraceEventSession)</returns>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableWindowsHeapProvider(System.Int32)">
            <summary>
            Turn on windows heap logging (stack for allocation) for a particular existing process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableWindowsHeapProvider(System.String)">
            <summary>
            Turn on windows heap logging for a particular EXE file name (just the file name, no directory, but it DOES include the .exe extension)
            This API is OK to call from one thread while Process() is being run on another
            </summary>
            <param name="exeFileName"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.DisableProvider(System.Guid)">
            <summary>
            Disables a provider with the given provider ID completely
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.DisableProvider(System.String)">
            <summary>
            Disables a provider with the given name completely
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.Stop(System.Boolean)">
            <summary>
            Once started, event sessions will persist even after the process that created them dies.  They will also be
            implicitly stopped when the TraceEventSession is closed unless the StopOnDispose property is set to false.  
            This API is OK to call from one thread while Process() is being run on another
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.Dispose">
            <summary>
            Close the session and clean up any resources associated with the session.     It is OK to call this more than once.  
            This API is OK to call from one thread while Process() is being run on another.   Calling Dispose is on 
            a real time session is the way you can force a real time session to stop in a timely manner.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.Flush">
            <summary>
            Asks all providers to flush events to the session
            This API is OK to call from one thread while Process() is being run on another
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.SetFileName(System.String)">
            <summary>
            For either session create with a file name this method can be used to redirect the data to a
            new file (so the previous one can be uploaded or processed offline), 
            
            It can also be used for a in-memory circular buffer session (FileName == null and CircularMB != 0)
            but its semantics is that simply writes the snapshot to the file (and closes it).  It does not
            actually make the FileName property become non-null because it only flushes the data, it does
            not cause persistent redirection of the data stream.  (it is like it auto-reverts).  
            
            It is an error to call this on a real time session.  (FileName == null and CircularMB == 0)
            </summary>
            <param name="newName">The path to the file to write the data to.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.CaptureStateOnSetFileName">
            <summary>
            If set, whenever a SetFileName is called (causing a new ETL file to be created), force 
            a capture state for every provider that is currently turned on.    This way the file
            will be self-contained (will contain all the capture state information needed to decode events)
            This setting is true by default.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.CaptureState(System.Guid,System.UInt64,System.Int32,System.Object)">
            <summary>
            Sends the CAPTURE_STATE command to the provider.  This instructs the provider to log any events that are needed to
            reconstruct important state that was set up before the session started.  What is actually done is provider specific.  
            EventSources will re-dump their manifest on this command. 
            This API is OK to call from one thread while Process() is being run on another
            <para>
            This routine only works Win7 and above, since previous versions don't have this concept.   The providers also has 
            to support it.  
            </para>
            </summary>
            <param name="providerGuid">The GUID that identifies the provider to send the CaptureState command to</param>
            <param name="matchAnyKeywords">The Keywords to send as part of the command (can influence what is sent back)</param>
            <param name="filterType">if non-zero, this is passed along to the provider as type of the filter data.</param>
            <param name="data">If non-null this is either an int, or a byte array and is passed along as filter data.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EnableProviderTimeoutMSec">
            <summary>
            When you issue a EnableProvider command, on windows 7 and above it can be done synchronously (that is you know that because 
            the EnableProvider returned that the provider actually got the command).   However synchronous behavior means that
            you may wait forever.   This is the time EnableProvider waits until it gives up.   Setting this
            to 0 means asynchronous (fire and forget).   The default is 10000 (wait 10 seconds) 
            Before windows 7 EnableProvider is always asynchronous.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.StopOnDispose">
            <summary>
            If set then Stop() will be called automatically when this object is Disposed or Finalized by the GC.  
            This is true BY DEFAULT, so if you want your session to survive past the end of the process
            you must set this to false.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.CircularBufferMB">
            <summary>
            Cause the log to be a circular buffer.  The buffer size (in MegaBytes) is the value of this property.
            Setting this to 0 will cause it to revert to non-circular mode.  
            The setter can only be called BEFORE any provider is enabled.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.MultiFileMB">
            <summary>
            Cause the as a set of files with a given maximum size.   The file name must end in .ETL and the
            output is then a series of files of the form *NNN.ETL (That is it adds a number just before the
            .etl suffix).   If you make your file name *.user.etl then the output will be *.user1.etl, *.user2.etl ...
            And the MergeInPlace command below will merge them all nicely.  
            
            You can have more control over this by using a normal sequential file but use the SetFileName()
            method to redirect the data to new files as needed.    
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.BufferSizeMB">
            <summary>
            Sets the size of the buffer the operating system should reserve to avoid lost packets.   Starts out 
            as a very generous 64MB for files.  If events are lost, this can be increased, but keep in mind that
            no value will help if the average incoming rate is faster than the processing rate.  
            The setter can only be called BEFORE any provider is enabled.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.BufferQuantumKB">
            <summary>
            This is the unit in which data is flushed in Kilobytes.   By default it is 64 (KB).  
            By default a TraceEventSession will flush every second, and this amount of space will be transferred
            to the file.   Ideally it is smaller than the number data bytes you expect in a second from any
            particular processor.  It can't be less than 1K per processor on the machine.   However if you make 
            it less than 64 (K) you will limit the size of the event that the process can send 
            (they will simply be discarded).   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.CpuSampleIntervalMSec">
            <summary>
            The rate at which CPU samples are collected.  By default this is 1 (once a millisecond per CPU).
            There is a lower bound on this (typically .125 Msec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.StackCompression">
            <summary>
            Indicate that this session should use compress the stacks to save space.  
            Must be set before any providers are enabled.  Currently only works for kernel events.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.SessionName">
            <summary>
            The name of the session that can be used by other threads to attach to the session. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.FileName">
            <summary>
            The name of the moduleFile that events are logged to.  Null means the session is real time
            or is a circular in-memory buffer.    See also SetFileName() method. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.Source">
            <summary>
            If this is a real time session you can fetch the source associated with the session to start receiving events.  
            Currently does not work on file based sources (we expect you to wait until the file is complete).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.IsActive">
            <summary>
            Creating a TraceEventSession does not actually interact with the operating system until a
            provider is enabled. At that point the session is considered active (OS state that survives a
            process exit has been modified). IsActive returns true if the session is active. 
            
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.EventsLost">
            <summary>
            Returns the number of events that should have been delivered to this session but were lost 
            (typically because the incoming rate was too high).   This value is up-to-date for real time
            sessions.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.IsCircular">
            <summary>
            Returns true if the session is logging to a circular buffer.  This may be in-memory (FileName == null)
            or to a file (FileName != null)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.IsRealTime">
            <summary>
            Returns true if the session is Real Time.  This means it is not to a file, and not circular.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.IsInMemoryCircular">
            <summary>
            Returns true if this is a in-memory circular buffer (it is circular without an output file).  
            Use SetFileName() to dump the in-memory buffer to a file.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.GetActiveSessionNames">
            <summary>
            ETW trace sessions survive process shutdown. Thus you can attach to existing active sessions.
            GetActiveSessionNames() returns a list of currently existing session names.  These can be passed
            to the TraceEventSession constructor to open it.   
            </summary>
            <returns>A enumeration of strings, each of which is a name of a session</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.Merge(System.String[],System.String,Microsoft.Diagnostics.Tracing.Session.TraceEventMergeOptions)">
            <summary>
            It is sometimes useful to merge the contents of several ETL files into a single 
            output ETL file.   This routine does that.  It also will attach additional 
            information that will allow correct file name and symbolic lookup if the 
            ETL file is used on a machine other than the one that the data was collected on.
            If you wish to transport the file to another machine you need to merge them, even 
            if you have only one file so that this extra information get incorporated.  
            </summary>
            <param name="inputETLFileNames">The input ETL files to merge</param>
            <param name="outputETLFileName">The output ETL file to produce.</param>
            <param name="options">Optional Additional options for the Merge (seeTraceEventMergeOptions) </param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.MergeInPlace(System.String,System.IO.TextWriter)">
            <summary>
            This variation of the Merge command takes the 'primary' etl file name (X.etl)
            and will merge in any files that match .clr*.etl .user*.etl. and .kernel.etl.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.IsElevated">
            <summary>
            Is the current process Elevated (allowed to turn on a ETW provider).   This is useful because
            you need to be elevated to enable providers on a TraceEventSession.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.SetDebugPrivilege">
            <summary>
            Set the Windows Debug Privilege.   Useful because some event providers require this privilege, and 
            and it must be enabled explicitly (even if the process is elevated). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.Finalize">
            <summary>
            The 'properties' field is only the header information.  There is 'tail' that is 
            required.  'ToUnmangedBuffer' fills in this tail properly. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.ProviderNameToGuid">
            <summary>
            Returns a sorted dictionary of  names and Guids for every provider registered on the system.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.ComputeEventIds(Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_FILTER_DESCRIPTOR*,System.Byte*,System.Int32,System.Collections.Generic.IList{System.Int32},System.Boolean,System.Int32)">
            <summary>
            sets up the EVENT_FILTER_DESCRIPTOR descr to represent the Event Ids in 'eventIds'.   You are given the buffer 
            necessary for this (precomputed) for the EVENT_FILTER_EVENT_ID structure.   'enable' is true if this is to enable
            (otherwise disable) the events, and descrType indicates the descriptor type (either EVENT_FILTER_TYPE_EVENT_ID or
            EVENT_FILTER_TYPE_STACKWALK)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.ComputeEventIdsBufferSize(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Computes the number of bytes needed for the EVENT_FILTER_EVENT_ID structure to represent 'eventIds'
            return 0 if there is not need for the filter at all.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.CleanFilterDataForEtwSession">
            <summary>
            Cleans out all provider data associated with this session.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.SetFilterDataForEtwSession(System.String,System.Byte[],System.Boolean)">
            <summary>
            SetDataForSession sets the filter data for an ETW session by storing it in the registry.
            This is basically a work-around for the fact that filter data does not get transmitted to
            the provider if the provider is not alive at the time the controller issues the EnableProvider 
            call.   We store in the registry and EventSource looks there for it if it is not present.  
            
            Note that we support up to 'maxSession' etw sessions simultaneously active (having different 
            filter data).   The function return a sessionIndex that indicates which of the 'slots' 
            was used to store the data.   This routine also 'garbage collects' data for sessions that
            have died without cleaning up their filter data.  
            
            If 'data' is null, then it indicates that no data should be stored and the registry entry
            is removed.
            
            If 'allSesions' is true it means that you want 'old style' data filtering that affects all ETW sessions
            This is present only used for compatibilty 
            </summary>
            <returns>the session index that will be used for this session.  Returns -1 if an entry could not be found </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.SetStackTraceIds(Microsoft.Diagnostics.Tracing.Parsers.KernelTraceEventParser.Keywords,Microsoft.Diagnostics.Tracing.Extensions.STACK_TRACING_EVENT_ID*,System.Int32)">
            <summary>
            Given a mask of kernel flags, set the array stackTracingIds of size stackTracingIdsMax to match.
            It returns the number of entries in stackTracingIds that were filled in.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventSession.GetProperties(System.Byte*)">
            <summary>
            Get a EVENT_TRACE_PROPERTIES structure suitable for passing the the ETW out of a 'buffer' which must be PropertiesSize bytes
            in size.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventMergeOptions">
            <summary>
            Used in the TraceEventSession.Merge method 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventMergeOptions.None">
            <summary>
            No special options 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventMergeOptions.Compress">
            <summary>
            Compress the resulting file.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventMergeOptions.ImageIDsOnly">
            <summary>
            Only perform image ID injection.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions">
            <summary>
            TraceEventProviderOptions represents all the optional arguments that can be passed to EnableProvider command.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.#ctor">
            <summary>
            Create new options object with no options set
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.#ctor(System.String[])">
            <summary>
            Create new options object with a set of given provider arguments key-value pairs.  There must be a even number
            of strings provided and each pair forms a key-value pair that is passed to the AddArgument() operator.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.Arguments">
            <summary>
            Arguments are a set of key-value strings that are passed uninterpreted to the EventSource.   These can be accessed
            from the EventSource's command callback.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.AddArgument(System.String,System.String)">
            <summary>
            As a convenience, the 'Arguments' property can be modified by calling AddArgument that adds another Key-Value pair
            to it.   If 'Arguments' is not a IDictionary, it is replaced with an IDictionary with the same key-value pairs before
            the new pair is added.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.RawArguments">
            <summary>
            For EventSources, you pass arguments to the EventSource by using key value pairs (this 'Arguments' property). 
            However other ETW providers may expect arguments using another convention.  RawArguments give a way of passing
            raw bytes to the provider as arguments.   This is only meant for compatibility with old providers.   Setting
            this property will cause the 'Arguments' property to be ignored.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.StacksEnabled">
            <summary>
            Setting StackEnabled to true will cause all events in the provider to collect stacks when events are fired. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.ProcessIDFilter">
            <summary>
            Setting ProcessIDFilter will limit the providers that receive the EnableCommand to those that match one of
            the given Process IDs.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.ProcessNameFilter">
            <summary>
            Setting ProcessNameFilter will limit the providers that receive the EnableCommand to those that match one of
            the given Process names (a process name is the name of the EXE without the PATH but WITH the extension).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.EventIDsToEnable">
            <summary>
            Setting EventIDs to Enable will enable a particular event of a provider by EventID (in addition to those 
            enabled by keywords). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.EventIDStacksToEnable">
            <summary>
            Setting EventIDs to Enable will enable the collection of stacks for an event of a provider by EventID 
            (Has no effect if StacksEnabled is also set since that enable stacks for all events IDs)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.EventIDsToDisable">
            <summary>
            Setting EventIDsToDisable to Enable will disable the event of a provider by EventID 
            This happens after keywords have been processed, so disabling overrides enabling.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.EventIDStacksToDisable">
            <summary>
            Setting EventIDs to Enable will disable the collection of stacks for an event of a provider by EventID 
            Has no effect unless StacksEnabled is also set (since otherwise stack collection is off).   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.EnableInContainers">
            <summary>
            Setting this to true will cause this provider to be enabled inside of any silos (containers) running on the machine.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.EnableSourceContainerTracking">
            <summary>
            Setting this to true will cause all events emitted inside of a container to contain the container ID in its payload.
            Has no effect if <code>EnableInContainers == false</code>.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.Clone">
            <summary>
            Make a deep copy of options and return it.  
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.FilteringSupported">
            <summary>
            This return true on OS version beyond 8.1 (windows Version 6.3).   It means most of the
            per-event filtering is supported.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.s_IsEtwFilteringSupported">
            <summary>
            This is the backing field for the lazily-computed <see cref="P:Microsoft.Diagnostics.Tracing.Session.TraceEventProviderOptions.FilteringSupported"/> property.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventSessionOptions">
            <summary>
            TraceEventSessionOptions indicates special handling when creating a TraceEventSession.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventSessionOptions.Create">
            <summary>
            Create a new session, stop and recreated it if it already exists.  This is the default.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventSessionOptions.Attach">
            <summary>
            Attach to an existing session, fail if the session does NOT already exist.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventSessionOptions.NoRestartOnCreate">
            <summary>
            Normally if you create a session it will stop and restart it if it exists already.  Setting
            this flat will disable the 'stop and restart' behavior.   This is useful if only a single
            monitoring process is intended. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders">
            <summary>
            TraceEventProviders returns information about providers on the system.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetProviderGuidByName(System.String)">
            <summary>
            Given the friendly name of a provider (e.g. Microsoft-Windows-DotNETRuntimeStress) return the
            GUID for the provider.   It does this by looking at all the PUBLISHED providers on the system
            (that is those registered with wevtutuil).   EventSources in particular do not register themselves
            in this way (see GetEventSourceGuidFromName).  Names are case insensitive.   
            It also checks to see if the name is an actual GUID and if so returns that.  
            Returns Guid.Empty on failure.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetEventSourceGuidFromName(System.String)">
            <summary>
            EventSources have a convention for converting its name to a GUID.  Use this convention to 
            convert 'name' to a GUID.   In this way you can get the provider GUID for a EventSource
            however it can't check for misspellings.   Names are case insensitive.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetProviderName(System.Guid)">
            <summary>
            Finds the friendly name for 'providerGuid'  Returns the Guid as a string if can't be found.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.MaybeAnEventSource(System.Guid)">
            <summary>
            Returns true if 'providerGuid' can be an eventSource.   If it says true, there is a 1/16 chance it is not.  
            However if it returns false, it is definitely not following EventSource Guid generation conventions.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetPublishedProviders">
            <summary>
            Returns the Guid of every event provider that published its manifest on the machine.  This is the 
            same list that the 'logman query providers' command will generate.  It is pretty long (&gt; 1000 entries)
            <para>
            A event provider publishes a manifest by compiling its manifest into a special binary form and calling
            the wevtutil utility.   Typically EventSource do NOT publish their manifest but most operating
            system provider do publish their manifest.   
            </para>
            </summary>  
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetRegisteredOrEnabledProviders">
            <summary>
            Returns the GUID of all event provider that either has registered itself in a running process (that is
            it CAN be enabled) or that a session has enabled (even if no instances of the provider exist in any process).  
            <para>
            This is a relatively small list (less than 1000), unlike GetPublishedProviders. 
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetRegisteredProvidersInProcess(System.Int32)">
            <summary>
            Returns a list of provider GUIDs that are registered in a process with 'processID'.   Useful for discovering
            what providers are available for enabling for a particular process.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.GetProviderKeywords(System.Guid)">
            <summary>
            Returns a description of the keywords a particular provider provides.  Only works if the provider has 
            published its manifest to the operating system.  
            Throws an exception if providerGuid is not found
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProviders.SessionInfosForProvider(System.Guid,System.Int32)">
            <summary>
            Returns a list of TRACE_ENABLE_INFO structures that tell about each session (what keywords and level they are
            set to, for the provider associated with 'providerGuid'.  If 'processId != 0, then only providers in that process
            are returned.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.ProviderDataItem">
            <summary>
            A list of these is returned by GetProviderKeywords
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProviderDataItem.Name">
            <summary>
            The name of the provider keyword. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProviderDataItem.Description">
            <summary>
            The description for the keyword for the provider 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProviderDataItem.Value">
            <summary>
            the value (bitvector) for the keyword.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.ProviderDataItem.ToString">
            <summary>
            and XML representation for the ProviderDataItem (for debugging)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventProfileSources">
            <summary>
            TraceEventProfileSources is the interface for the Windows processor CPU counter support
            (e.g. causing a stack to be taken every N dcache misses, or branch mispredicts etc)
            <para>
            Note that the interface to these is machine global (That is when you set these you 
            cause any session with the kernel PMCProfile keyword active to start emitting
            PMCCounterProf events for each ProfileSouce that is enabled.  
            </para>
            /// </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProfileSources.GetInfo">
            <summary>
            Returns a dictionary of keyed by name of ProfileSourceInfo structures for all the CPU counters available on the machine. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProfileSources.Set(System.Int32,System.Int32)">
            <summary>
            Sets a single Profile Source (CPU machine counters) that will be used if PMC (Precise Machine Counters)
            are turned on.   The profileSourceID is the ID field from the ProfileSourceInfo returned from 'GetInfo()'.
            and the profileSourceInterval is the interval between sampples (the number of events before a stack
            is recoreded.    If you need more that one (the OS allows up to 4 I think), use the variation of this
            routine that takes two int[].   Calling this will clear all Profiler sources previously set (it is NOT
            additive).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Session.TraceEventProfileSources.Set(System.Int32[],System.Int32[])">
            <summary>
            Sets the Profile Sources (CPU machine counters) that will be used if PMC (Precise Machine Counters)
            are turned on.   Each CPU counter is given a id (the profileSourceID) and has an interval 
            (the number of counts you skip for each event you log).   You can get the human name for 
            all the supported CPU counters by calling GetProfileSourceInfo.  Then choose the ones you want
            and configure them here (the first array indicating the CPU counters to enable, and the second
            array indicating the interval.  The second array can be shorter then the first, in which case
            the existing interval is used (it persists and has a default on boot).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.ProfileSourceInfo">
            <summary>
            Returned by GetProfileSourceInfo, describing the CPU counter (ProfileSource) available on the machine. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProfileSourceInfo.Name">
            <summary>
            Human readable name of the CPU performance counter (eg BranchInstructions, TotalIssues ...)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProfileSourceInfo.ID">
            <summary>
            The ID that can be passed to SetProfileSources
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProfileSourceInfo.Interval">
            <summary>
            This many events are skipped for each sample that is actually recorded
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProfileSourceInfo.MinInterval">
            <summary>
            The smallest Interval can be (typically 4K)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.ProfileSourceInfo.MaxInterval">
            <summary>
            The largest Interval can be (typically maxInt).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Session.TraceEventOptions">
            <summary>
            These are options to EnableProvider
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventOptions.None">
            <summary>
            No options
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Session.TraceEventOptions.Stacks">
            <summary>
            Take a stack trace with the event
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLog">
            <summary>
            The data model for an Event trace log (ETL) file is simply a stream of events.     More sophisticated 
            analysis typically needs a a richer data model then ETL files can provide, and this is the 
            motivation for the ETLX (Event Trace Log eXtended) file format.   In particular any 
            analysis that needs non-sequential access to the events or manipulates stack traces associated 
            with events needs the additional support that the ETLX format provides.   See the TraceEventProgrammers guide
            for more on the capabilities of ETLX.  
            <para>
            The TraceLog class is the programmatic representation of an ETLX file.   It represents the ETLX file as a whole.
            </para><para>
            ETLX files are typically created from ETL files using the TraceLog.OpenOrCreate method or more explicitly 
            by the TraceLog.CreateFromEventTraceLogFile. 
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CreateFromEventTraceLogFile(System.String,System.String,Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions,Microsoft.Diagnostics.Tracing.TraceEventDispatcherOptions)">
            <summary>
            Given the path to an ETW trace log file (ETL) file, create an ETLX file for the data. 
            <para>If etlxFilePath is null the output name is derived from etlFilePath by changing its file extension to .ETLX.</para>
            <returns>The name of the ETLX file that was generated.</returns>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CreateFromEventTraceLogFile(Microsoft.Diagnostics.Tracing.TraceEventDispatcher,System.String,Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions)">
            <summary>
            Given a <see cref="T:Microsoft.Diagnostics.Tracing.TraceEventDispatcher"/> that can be created from data source, create an ETLX file for the data. 
            </summary>
            <para>If etlxFilePath is null the output name is derived from etlFilePath by changing its file extension to .ETLX.</para>
            <returns>The name of the ETLX file that was generated.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.OpenOrConvert(System.String,Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions)">
            <summary>
            Open an ETLX or ETL file as a ETLX file. 
            <para>
            This routine assumes that you follow normal conventions of naming ETL files with the .ETL file extension 
            and ETLX files with the .ETLX file extension.  It further assumes the ETLX file for a given ETL file 
            should be in a file named the same as the ETL file with the file extension changed.  
            </para><para>
            etlOrEtlxFilePath can be either the name of the ETL or ETLX file.   If the ETLX file does not
            exist or if it older than the corresponding ETL file then the ETLX file is regenerated with
            the given options.   However if an up-to-date ETLX file exists the conversion step is skipped.  
            </para><para>
            Ultimately the ETLX file is opened and the resulting TraceLog instance is returned.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CreateFromTraceEventSession(Microsoft.Diagnostics.Tracing.Session.TraceEventSession)">
            <summary>
            From a TraceEventSession, create a real time TraceLog Event Source.   Like a ETWTraceEventSource a TraceLogEventSource
            will deliver events in real time.   However an TraceLogEventSource has an underlying Tracelog (which you can access with
            the .Log Property) which lets you get at aggregated information (Processes, threads, images loaded, and perhaps most
            importantly TraceEvent.CallStack() will work.  Thus you can get real time stacks from events).  
            
            Note that in order for native stacks to resolve symbolically, you need to have some Kernel events turned on (Image, and Process)
            and only windows 8 has a session that allows both kernel and user mode events simultaneously.   Thus this is most useful
            on Win 8 systems.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CreateFromLttngTextDataFile(System.String,System.String,Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions)">
            <summary>
            Creates a ETLX file an Lttng Text file 'filePath'.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CreateFromEventPipeDataFile(System.String,System.String,Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions)">
            <summary>
            Creates a ETLX file an EventPipe 'filePath'.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.#ctor(System.String)">
            <summary>
            Opens an existing Extended Trace Event log file (ETLX) file.  See also TraceLog.OpenOrCreate. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Events">
            <summary>
            All the events in the ETLX file. The returned TraceEvents instance supports IEnumerable so it can be used 
            in foreach statements, but it also supports other methods to further filter the evens before enumerating over them.  
            
            Note that the TraceEvent returned from this IEnumerable may only be used for one iteration of the foreach.
            (it is reused for the next event).  If you need more lifetime than that you must call Clone() (see 'Lifetime
            Constraints' in the programmers guide for more).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Processes">
            <summary>
            All the Processes that logged an event in the ETLX file.  The returned TraceProcesses instance supports IEnumerable so it can be used 
            in foreach statements, but it also supports other methods to select particular a particular process.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Threads">
            <summary>
            All the Threads that logged an event in the ETLX file.  The returned TraceThreads instance supports IEnumerable so it can be used 
            in foreach statements, but it also supports other methods to select particular thread.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.ModuleFiles">
            <summary>
            All the module files (DLLs) that were loaded by some process in the ETLX file.  The returned TraceModuleFiles instance supports IEnumerable so it can be used 
            in foreach statements, but it also supports other methods to select particular module file.  
            </summary>  
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CallStacks">
            <summary>
            All the call stacks in the ETLX file.  Normally you don't enumerate over these, but use you use other methods on TraceCallStacks 
            information about code addresses using CallStackIndexes. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CodeAddresses">
            <summary>
            All the code addresses in the ETLX file.  Normally you don't enumerate over these, but use you use other methods on TraceCodeAddresses 
            information about code addresses using CodeAddressIndexes. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Stats">
            <summary>
            Summary statistics on the events in the ETX file.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetCallStackForEvent(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            If the event has a call stack associated with it, retrieve it.   Returns null if there is not call stack associated with the event.
            <para>If you are retrieving many call stacks consider using GetCallStackIndexForEvent, as it is more efficient.</para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetCallStackIndexForEvent(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            If the event has a call stack associated with it, retrieve CallStackIndex.   Returns CallStackIndex.Invalid if there is not call stack associated with the event.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.MaxEventIndex">
            <summary>
            Events are given an Index (ID) that are unique across the whole TraceLog.   They are not guaranteed
            to be sequential, but they are guaranteed to be between 0 and MaxEventIndex.  Ids can be used to
            allow clients to associate additional information with event (with a side lookup table).   See
            TraceEvent.EventIndex and EventIndex for more 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetEvent(Microsoft.Diagnostics.Tracing.EventIndex)">
            <summary>
            Given an eventIndex, get the event.  This is relatively expensive because we need to create a
            copy of the event that will not be reused by the TraceLog.   Ideally you would not use this API
            but rather use iterate over event using TraceEvents
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.EventCount">
            <summary>
            The total number of events in the log.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Size">
            <summary>
            The size of the log file in bytes.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.EventsLost">
            <summary>
            override
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FilePath">
            <summary>
            The file path for the ETLX file associated with this TraceLog instance.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.MachineName">
            <summary>
            The machine on which the log was collected.  Returns empty string if unknown. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.OSName">
            <summary>
            The name of the Operating system.  Returns empty string if unknown.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.OSBuild">
            <summary>
            The build number information for the OS.  Returns empty string if unknown.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.BootTime">
            <summary>
            The time the machine was booted.   Returns DateTime.MinValue if it is unknown.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.UTCOffsetMinutes">
            <summary>
            This is the number of minutes between the local time where the data was collected and UTC time.  
            It is negative if your time zone is WEST of Greenwich.  This DOES take Daylights savings time into account
            but might be a daylight savings time transition happens inside the trace.  
            May be unknown, in which case it returns null.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.HasPdbInfo">
            <summary>
            When an ETL file is 'merged', for every DLL in the trace information is added that allows the symbol
            information (PDBS) to be identified unambiguously on a symbol server.   This property returns true
            if the ETLX file was created from an ETL file with this added information.    
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.MemorySizeMeg">
            <summary>
            The size of the main memory (RAM) on the collection machine.  Will return 0 if memory size is unknown 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.HasCallStacks">
            <summary>
            Are there any event in trace that has a call stack associated with it. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.SampleProfileInterval">
            <summary>
            If Kernel CPU sampling events are turned on, CPU samples are taken at regular intervals (by default every MSec).
            <para>This property returns the time interval between samples.  
            </para><para>
            If the sampling interval was changed over the course of the trace, this property does not reflect that.  It
            returns the first value it had in the trace.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CurrentMachineIsCollectionMachine">
            <summary>
            Returns true if the  machine running this code is the same as the machine where the trace data was collected.   
            <para>
            If this returns false, the path names references in the trace cannot be inspected (since they are on a different machine).  
            </para> 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Truncated">
            <summary>
            There is a size limit for ETLX files.  Thus  it is possible that the data from the original ETL file was truncated.  
            This property returns true if this happened.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FirstTimeInversion">
            <summary>
            Returns the EvnetIndex (order in the file) of the first event that has a 
            timestamp smaller than its predecessor.  Returns Invalid if there are no time inversions. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Parsers">
            <summary>
            Returns all the TraceEventParsers associated with this log.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.ToString">
            <summary>
            An XML fragment that gives useful summary information about the trace as a whole.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.#ctor(Microsoft.Diagnostics.Tracing.Session.TraceEventSession)">
            <summary>
            Create a new real time session called 'sessionName' and connect a TraceLog to it and return that TraceLog.
            Functionality of TraceLog that does not depend on either remembering past EVENTS or require future 
            knowledge (e.g. stacks of kernel events), will 'just work'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.RemoveAllButLastEntries``1(System.Collections.Generic.GrowableArray{``0}@,System.Int32)">
            <summary>
            Removes all but the last 'keepCount' entries in 'growableArray' by sliding them down. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.DispatchClonedEvent(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Forwards an event that was saved (cloned) to the dispatcher associated with the real time source.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.FlushRealTimeEvents(System.Object)">
            <summary>
            Flushes any event that has waited around long enough 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetCodeAddressIndexAtEvent(System.UInt64,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Given a process's virtual address 'address' and an event which acts as a 
            context (determines which process and what time in that process), return 
            a CodeAddressIndex (which represents a particular location in a particular
            method in a particular DLL). It is possible that different addresses will
            go to the same code address for the same address (in different contexts).
            This is because DLLS where loaded in different places in different processes.
            </summary>  
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetCodeAddressAtEvent(System.UInt64,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            If an event has a field of type 'Address' the address can be converted to a symbolic value (a
            TraceCodeAddress) by calling this function.   C
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetCallStackIndexForEventIndex(Microsoft.Diagnostics.Tracing.EventIndex)">
            <summary>
            Given an EventIndex for an event, retrieve the call stack associated with it
            (that can be given to TraceCallStacks). Many events may not have associated
            call stack in which case CallSTackIndex.Invalid is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetCallStackIndexForCSwitchBlockingEventIndex(Microsoft.Diagnostics.Tracing.EventIndex)">
            <summary>
            Given a eventIndex for a CSWTICH event, return the call stack index for the thread
            that LOST the processor (the normal callStack is for the thread that GOT the CPU)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CreateFromTraceEventSource(Microsoft.Diagnostics.Tracing.TraceEventDispatcher,System.String,Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions)">
            <summary>
            Given a source of events 'source' generated a ETLX file representing these events from them. This
            file can then be opened with the TraceLog constructor. 'options' can be null.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.SetupCallbacks(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            SetupCallbacks installs all the needed callbacks for TraceLog Processing (stacks, process, thread, summaries etc)
            on the TraceEventSource rawEvents.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CopyRawEvents(Microsoft.Diagnostics.Tracing.TraceEventDispatcher,FastSerialization.IStreamWriter)">
            <summary>
             Copies the events from the 'rawEvents' dispatcher to the output stream 'IStreamWriter'.  It
             also creates auxiliary data structures associated with the raw events (eg, processes, threads,
             modules, address lookup maps...  Basically any information that needs to be determined by
             scanning over the events during TraceLog creation should hook in here.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.AddAddressToCodeAddressMap(Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt64)">
            <summary>
            This is a helper routine that adds the address 'address' in the event 'data' to the map from events
            to this list of addresses.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GenerateMemInfoRecordsPerProcess(Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryProcessMemInfoTraceData,FastSerialization.IStreamWriter)">
            <summary>
            Special logic to form MemInfoWSTraceData.   We take the single event (which has 
            The working sets for every process in the system, an split them out into N events
            each of which has the processID for the event set properly, and only has the
            information for that process.    The first 3 processes in the list are -1, -2, and -3
            that have special meaning.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.GetIncompleteStackForStackEvent(Microsoft.Diagnostics.Tracing.TraceEvent,System.Int64)">
            <summary>
            Given just the stack event and the timestamp for the event the stack event is to attach to, find
            the IncompleteStack for the event.   If the event to attach to cannot be this will return null
            but otherwise it will make an IncompleteStack entry if one does not already exist or it.   
            
            As part of allocating an Incomplete stack, it will increment the stack counts for target event.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.EmitStackOnExitFromKernel(Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack@,Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack)">
            <summary>
            Do the processing necessary to attach the user mode stack 'userModeStack' to any of the stacks in listOfIncompleteKernelStacks.
            It then clears this list.   While doing this processing it will check to see if the target stack 'target' is in that list and
            it will return true if it was.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.EmitStackOnExitFromKernel(Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack@,System.UInt64,Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack)">
            <summary>
            Do the processing necessary to attach the user mode stack 'userModeStack' to any of the stacks in listOfIncompleteKernelStacks.
            It then clears this list.   While doing this processing it will check to see if the target stack 'target' is in that list and
            it will return true if it was.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.LogStackDefinition(Microsoft.Diagnostics.Tracing.Parsers.Kernel.StackWalkDefTraceData)">
            <summary>
            Called when we get a definition event (for either a user mode or kernel mode stack fragment). 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack">
            <summary>
            Holds information about stacks associated with an event.  This is a transient structure.  We only need it 
            until all the information is collected for a particular event, at which point we can create a 
            CallStackIndex for the stack and eventsToStacks table.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.Clear">
            <summary>
            Clear clears entires that typically don't get set when we only have 1 frame fragment
            We can recycle the entries without setting these in that case.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.Initialize(Microsoft.Diagnostics.Tracing.EventIndex,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.EventIndex)">
            <summary>
            Clear all entries that can potentially change every time.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.LogKernelStackFragment(System.Void*,System.Int32,System.Int32,System.Int64,Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            Log the Kernel Stack fragment.  We simply remember all the frames (converted to CodeAddressIndexes).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.LogKernelStackFragment(System.UInt64,Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            Log the kernel stack fragment.  Returns true if all the pieces of the stack fragment are collected
            (we don't have to log something on the thread).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.LogUserStackFragment(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex,Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.EmitStackForEventIfReady(Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            Determine if 'stackInfo' is complete and if so emit it to the 'eventsToStacks' array.  If 'force' is true 
            then force what information there is out even if it is not complete (there is nothing else coming). 
            
            Returns true if it was able to emit the stack
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.IsDead">
            <summary>
            returns true if the IncompleteStack is dead (just waiting to be reused).   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.IncompleteStack.BlockingEventIndex">
            <summary>
            We track the stacks for when CSwitches block, this is the CSWITCH event where that blocking happened.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.CategorizeThread(Microsoft.Diagnostics.Tracing.TraceEvent,System.String,System.Boolean)">
            <summary>
            Put the thread that owns 'data' in to the category 'category.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.ProcessExtendedData(Microsoft.Diagnostics.Tracing.TraceEvent,System.UInt16,Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts)">
            <summary>
            Process any extended data (like Win7 style stack traces) associated with 'data'
            returns true if the event should be considered a bookkeeping event.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.Dispose(System.Boolean)">
            <summary>
            Dispose pattern
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.SeekToTimeOnPage(FastSerialization.PinnedStreamReader,System.Int64,System.Int32,System.Int32@,FastSerialization.StreamLabel[])">
            <summary>
            Advance 'reader' until it point at a event that occurs on or after 'timeQPC'.  on page
            'pageIndex'.  If 'positions' is non-null, fill in that array.  Also return the index in
            'positions' for the entry that was found.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.AllocLookup">
            <summary>
            We need a TraceEventDispatcher in the Enumerators for TraceLog that know how to LOOKUP an event 
            We don't actually dispatch through it.  We do mutate the templates (to point a particular data
            record), but once we are done with it we can reuse this TraceEventDispatcher again an again
            (it is only concurrent access that is a problem).  Thus we have an Allocate and Free pattern
            to reuse them in the common case of sequential access.  
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.cswitchBlockingEventsToStacks">
            <summary>
            The context switch event gives the stack of the thread GETTING the CPU, but it is also very useful
            to have this stack at the point of blocking.   cswitchBlockingEventsToStacks gives this stack.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.PastEventInfo">
            <summary>
            We need to remember the the EventIndexes of the events that were 'just before' this event so we can
            associate eventToStack traces with the event that actually caused them.  PastEventInfo does this.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.PastEventInfo.GetPreviousEventIndex(Microsoft.Diagnostics.Tracing.Etlx.TraceLog.PastEventInfoIndex,System.Int32,System.Boolean,Microsoft.Diagnostics.Tracing.EventIndex)">
            <summary>
            Returns the previous Event on the 'threadID'.  Events with -1 thread IDs are also always returned.   
            Returns PastEventInfoIndex.Invalid if there are not more events to consider.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.PastEventInfo.GetBestEventForQPC(System.Int64,System.Int32,System.Int32)">
            <summary>
            Find the event event on thread threadID to the given QPC timestamp.  If there is more than
            one event with the same QPC, we use thread and processor number to disambiguate.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLog.AddStackToEvent(Microsoft.Diagnostics.Tracing.EventIndex,Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Add a new entry that associates the stack 'stackIndex' with the event with index 'eventIndex'
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource">
            <summary>
            Represents a source for a TraceLog file (or real time stream).  It is basically a TraceEventDispatcher
            (TraceEventSource) but you can also get at the TraceLog for it as well.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource.TraceLog">
            <summary>
            Returns the TraceLog associated with this TraceLogEventSource. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource.CurrentEventIndex">
            <summary>
            Returns the event Index of the 'current' event (we post increment it so it is always one less)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource.Process">
            <summary>
            override
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource.EventsLost">
            <summary>
            override
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogEventSource.Dispose(System.Boolean)">
            <summary>
            override
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceEventStats">
            <summary>
            TraceEventStats represents the summary statistics (counts) of all the events in the log.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventStats.Count">
            <summary>
            The total number of distinct event types (there will be a TraceEventCounts for each distinct event Type)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEventStats.ToString">
            <summary>
            An XML representation of the TraceEventStats (for Debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEventStats.GetEventCounts(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Given an event 'data' look up the statistics for events that type.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts">
            <summary>
            TraceEventCount holds number of events (Counts) and the number of events with call stacks associated with them (StackCounts) for a particular event type.   
            <para>It also has properties for looking up the event and provider names, but this information can only be complete if all the TraceEventParsers needed
            were associated with the TraceLog instance.  
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.ProviderName">
            <summary>
            Returns a provider name for events in this TraceEventCounts.   It may return a string with a GUID or even
            UnknownProvider for classic ETW if the event is unknown to the TraceLog.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.EventName">
            <summary>
            Returns a name for events in this TraceEventCounts.   If the event is unknown to the Tracelog 
            it will return EventID(XXX) (for manifest based events) or Task(XXX)/Opcode(XXX) (for classic events)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.PayloadNames">
            <summary>
            Returns the payload names associated with this Event type.   Returns null if the payload names are unknown.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.IsClassic">
            <summary>
            Returns true the provider associated with this TraceEventCouts is a classic (not manifest based) ETW provider.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.ProviderGuid">
            <summary>
            Returns the provider GUID of the events in this TraceEventCounts.  Returns Guid.Empty if IsClassic
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.EventID">
            <summary>
            Returns the event ID of the events in this TraceEventCounts.  Returns TraceEventID.Illegal if IsClassic
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.TaskGuid">
            <summary>
            Returns the Task GUID of the events in this TraceEventCounts.  Returns Guid.Empty if not IsClassic
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.Opcode">
            <summary>
            Returns the Opcode of the events in the TraceEventCounts.  Returns TraceEventOpcode.Info if not IsClassic
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.AveragePayloadSize">
            <summary>
            Returns the average size of the event specific payload data (not the whole event) for all events in the TraceEventsCounts.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.Count">
            <summary>
            Returns the number of events in the TraceEventCounts.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.StackCount">
            <summary>
            Returns the number of events in the TraceEventCounts that have stack traces associated with them.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.FullName">
            <summary>
            Returns the full name of the event (ProviderName/EventName)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.ToString">
            <summary>
            An XML representation  of the top level statistics of the TraceEventCounts. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEventCounts.GetHashCode">
            <summary>
            GetHashCode
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents">
            <summary>
            A TraceEvents represents a list of TraceEvent instances.  It is IEnumerable&lt;TraceEvent&gt; but 
            also has additional useful ways of filtering the list.  
            
            Note that the TraceEvent returned from this IEnumerable may only be used for one iteration of the foreach.
            (it is reused for the next event).  If you need more lifetime than that you must call Clone() (see 'Lifetime
            Constraints' in the programmers guide for more).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.ByEventType``1">
            <summary>
            Returns a list of events in the TraceEvents that return a payload of type T.   Thus
            ByEventType &lt; TraceEvent &gt; returns all events.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.GetSource">
            <summary>
            Returns a TraceEventDispatcher (a push model object on which you can register
            callbacks for particular events) that will push all the vents in the TraceEvents.  
            
            Note that the TraceEvent returned from this callback may only be used for the duration of the callback.
            If you need more lifetime than that you must call Clone() (see 'Lifetime Constraints' in the programmers guide for more).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.Backwards">
            <summary>
            Returns a new list which is the same as the TraceEvents but the events are
            delivered from last to first.  This allows you to search backwards in the
            event stream.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.FilterByTime(System.DateTime,System.DateTime)">
            <summary>
            Filter the events by time.  Both starTime and endTime are inclusive. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.FilterByTime(System.Double,System.Double)">
            <summary>
            Filter the events by time.  StartTimeRelativeMSec and endTimeRelativeMSec are relative to the SessionStartTime and are inclusive.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.Filter(System.Predicate{Microsoft.Diagnostics.Tracing.TraceEvent})">
            <summary>
            Create new list of Events that has all the events in the current TraceEvents
            that pass the given predicate.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.Log">
            <summary>
            Returns the TraceLog associated with the events in the TraceEvents
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.StartTime">
            <summary>
            Returns a time that is guaranteed  to be before the first event in the TraceEvents list.  
            It is returned as DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.StartTimeRelativeMSec">
            <summary>
            Returns a time that is guaranteed to be before the first event in the TraceEvents list.  
            It is returned as floating point number of MSec since the start of the TraceLog
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.EndTime">
            <summary>
            Returns a time that is guaranteed to be after the last event in the TraceEvents list.  
            It is returned as DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceEvents.EndTimeRelativeMSec">
            <summary>
            Returns a time that is guaranteed to be after the last event in the TraceEvents list.  
            It is returned as floating point number of MSec since the start of the TraceLog
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.ProcessIndex">
            <summary>
            Each process is given a unique index from 0 to TraceProcesses.Count-1 and unlike 
            the OS Process ID, is  unambiguous (The OS process ID can be reused after a
            process dies).  ProcessIndex represents this index.   By using an enum rather than an int
            it allows stronger typing and reduces the potential for errors.  
            <para>
            It is expected that users of this library might keep arrays of size TraceProcesses.Count to store
            additional data associated with a process in the trace.  
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.ProcessIndex.Invalid">
            <summary>
            Returned when no appropriate Process exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses">
            <summary>
            A TraceProcesses instance represents the list of processes in the Event log.  
            
            TraceProcesses are IEnumerable, and will return the processes in order of creation time.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.Log">
            <summary>
            The log associated with this collection of processes. 
            </summary> 
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.Count">
            <summary>
            The count of the number of TraceProcess instances in the TraceProcesses list. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.Item(Microsoft.Diagnostics.Tracing.Etlx.ProcessIndex)">
            <summary>
            Each process that occurs in the log is given a unique index (which unlike the PID is unique), that
            ranges from 0 to Count - 1.   Return the TraceProcess for the given index.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.GetProcess(System.Int32,System.Double)">
            <summary>
            Given an OS process ID and a time, return the last TraceProcess that has the same process ID,
            and whose process start time is less than 'timeRelativeMSec'. 
            <para>
            If 'timeRelativeMSec' is during the processes's lifetime this is guaranteed to be the correct process. 
            for the given process ID since process IDs are unique during the lifetime of the process.  
            </para><para>
            If timeRelativeMSec == TraceLog.SessionDuration this method will return the last process with 
            the given process ID, even if it had died during the trace.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.LastProcessWithID(System.Int32)">
            <summary>
            Returns the last process in the log with the given process ID.  Useful when the logging session
            was stopped just after the processes completed (a common scenario).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.FirstProcessWithName(System.String,System.Double)">
            <summary>
            Find the first process in the trace that has the process name 'processName' and whose process
            start time is after the given point in time.  
            <para>A process's name is the file name of the EXE without the extension.</para>
            <para>Processes that began before the trace started have a start time of 0,  Thus 
            specifying 0 for the time will include processes that began before the trace started.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.LastProcessWithName(System.String,System.Double)">
            <summary>
            Find the last process in the trace that has the process name 'processName' and whose process
            start time is after the given point in time.  
            <para>A process's name is the file name of the EXE without the extension.</para>
            <para>Processes that began before the trace started have a start time of 0,  Thus 
            specifying 0 for the time will include processes that began before the trace started.  
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.ToString">
            <summary>
            An XML representation of the TraceEventProcesses (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.System#Collections#Generic#IEnumerable{Microsoft#Diagnostics#Tracing#Etlx#TraceProcess}#GetEnumerator">
            <summary>
            Enumerate all the processes that occurred in the trace log, ordered by creation time.   
            </summary> 
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.GetProcess(System.Int32,System.Int64)">
            <summary>
            Given an OS process ID and a time, return the last TraceProcess that has the same process ID,
            and whose offset start time is less than 'timeQPC'. If 'timeQPC' is during the thread's lifetime this
            is guaranteed to be the correct process. Using timeQPC = TraceLog.sessionEndTimeQPC will return the
            last process with the given PID, even if it had died.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcesses.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            TraceProcesses represents the entire ETL moduleFile log.   At the node level it is organized by threads.  
            
            The TraceProcesses also is where we put various caches that are independent of the process involved. 
            These include a cache for TraceModuleFile that represent native images that can be loaded into a
            process, as well as the process lookup tables and a cache that remembers the last calls to
            GetNameForAddress(). 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess">
            <summary>
            A TraceProcess represents a process in the trace. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.ProcessID">
            <summary>
            The OS process ID associated with the process. It is NOT unique across the whole log.  Use
            ProcessIndex for that. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.ProcessIndex">
            <summary>
            The index into the logical array of TraceProcesses for this process. Unlike ProcessID (which
            may be reused after the process dies, the process index is unique in the log. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.Name">
            <summary>
            This is a short name for the process.  It is the image file name without the path or suffix.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.CommandLine">
            <summary>
            The command line that started the process (may be empty string if unknown)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.ImageFileName">
            <summary>
            The path name of the EXE that started the process (may be empty string if unknown)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.StartTime">
            <summary>
            The time when the process started.  Returns the time the trace started if the process existed when the trace started.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.StartTimeRelativeMsec">
            <summary>
            The time when the process started.  Returns the time the trace started if the process existed when the trace started.  
            Returned as the number of MSec from the beginning of the trace. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.EndTime">
            <summary>
            The time when the process ended.  Returns the time the trace ended if the process existed when the trace ended.  
            Returned as a DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.EndTimeRelativeMsec">
            <summary>
            The time when the process ended.  Returns the time the trace ended if the process existed when the trace ended. 
            Returned as the number of MSec from the beginning of the trace. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.ParentID">
            <summary>
            The process ID of the parent process 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.Parent">
            <summary>
            The process that started this process.  Returns null if unknown    Unlike ParentID
            the chain of Parent's will never form a loop.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.ExitStatus">
            <summary>
            If the process exited, the exit status of the process.  Otherwise null. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.CPUMSec">
            <summary>
            The amount of CPU time spent in this process based on the kernel CPU sampling events.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.Is64Bit">
            <summary>
            Returns true if the process is a 64 bit process
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.Log">
            <summary>
            The log file associated with the process. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.Threads">
            <summary>
            A list of all the threads that occurred in this process.  
            </summary> 
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.LoadedModules">
            <summary>
            Returns the list of modules that were loaded by the process.  The modules may be managed or
            native, and include native modules that were loaded event before the trace started.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.EventsInProcess">
            <summary>
            Filters events to only those for a particular process. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.EventsDuringProcess">
            <summary>
            Filters events to only that occurred during the time the process was alive. 
            </summary>
            
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.ToString">
            <summary>
            An XML representation of the TraceEventProcess (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.SetParentForProcess(Microsoft.Diagnostics.Tracing.Etlx.TraceProcess)">
            <summary>
            Sets the 'Parent' field for the process (based on the ParentID).   
            
            sentinel is internal to the implementation, external callers should always pass null. 
            TraceProcesses that have a parent==sentinel considered 'illegal' since it would form
            a loop in the parent chain, which we definitely don't want.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.#ctor(System.Int32,Microsoft.Diagnostics.Tracing.Etlx.TraceLog,Microsoft.Diagnostics.Tracing.Etlx.ProcessIndex)">
            <summary>
            Create a new TraceProcess.  It should only be done by log.CreateTraceProcess because
            only TraceLog is responsible for generating a new ProcessIndex which we need.   'processIndex'
            is a index that is unique for the whole log file (where as processID can be reused).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.codeAddressesInProcess">
            <summary>
            This table allows us to intern codeAddress so we only at most one distinct address per process.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.unresolvedCodeAddresses">
            <summary>
            We also keep track of those code addresses that are NOT yet resolved to at least a File (for JIT compiled 
            things this would be to a method 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.MethodLookupInfo">
            <summary>
            This is all the information needed to remember about at JIT compiled method (used in the jitMethods variable)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.jitMethods">
            <summary>
            This table has a entry for each JIT compiled method that remembers its range.   It is actually only needed
            for the real time case, as the non-real time case you resolve code addresses on method unload/rundown and thus
            don't need to remember the information.   This table is NOT persisted in the ETLX file since is only needed
            to convert raw addresses into TraceMethods.  
            
            It is a array of arrays to make insertion efficient.  Most of the time JIT methods will be added in 
            contiguous memory (thus will be in order), however from time to time things will 'jump around' to a new 
            segment.   By having a list of lists, (which are in order in both lists) you can efficiently (log(N)) search
            as well as insert.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceProcess.scheduledActivityIdToActivityIndex">
            <summary>
            Maps a newly scheduled "user" activity ID to the ActivityIndex of the
            Activity. This keeps track of currently created/scheduled activities
            that have not started yet, and for multi-trigger events, created/scheduled
            activities that have not conclusively "died" (e.g. by having their "user" 
            activity ID reused by another activity).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex">
            <summary>
            Each thread is given a unique index from 0 to TraceThreads.Count-1 and unlike 
            the OS Thread ID, is  unambiguous (The OS thread ID can be reused after a
            thread dies).  ThreadIndex represents this index.   By using an enum rather than an int
            it allows stronger typing and reduces the potential for errors.  
            <para>
            It is expected that users of this library might keep arrays of size TraceThreads.Count to store
            additional data associated with a process in the trace.  
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex.Invalid">
            <summary>
            Returned when no appropriate Thread exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads">
            <summary>
            A TraceThreads represents the list of threads in a process. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.System#Collections#Generic#IEnumerable{Microsoft#Diagnostics#Tracing#Etlx#TraceThread}#GetEnumerator">
            <summary>
            Enumerate all the threads that occurred in the trace log. It does so in order of their thread
            offset events in the log.  
            </summary> 
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.Count">
            <summary>
            The count of the number of TraceThreads in the trace log. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.Item(Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex)">
            <summary>
            Each thread that occurs in the log is given a unique index (which unlike the PID is unique), that
            ranges from 0 to Count - 1.   Return the TraceThread for the given index.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.GetThread(System.Int32,System.Double)">
            <summary>
            Given an OS thread ID and a time, return the last TraceThread that has the same thread ID,
            and whose start time is less than 'timeRelativeMSec'. If 'timeRelativeMSec' is during the thread's lifetime this
            is guaranteed to be the correct thread. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.ToString">
            <summary>
            An XML representation of the TraceThreads (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.#ctor(Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            TraceThreads   represents the collection of threads in a process. 
            
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThreads.GetOrCreateThread(System.Int32,System.Int64,Microsoft.Diagnostics.Tracing.Etlx.TraceProcess,System.Boolean)">
            <summary>
            Get the thread for threadID and timeQPC.   Create if necessary.  If 'isThreadCreateEvent' is true, 
            then force  the creation of a new thread EVEN if the thread exist since we KNOW it is a new thread 
            (and somehow we missed the threadEnd event).   Process is the process associated with the thread.  
            It can be null if you really don't know the process ID.  We will try to fill it in on another event
            where we DO know the process id (ThreadEnd event).     
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceThread">
            <summary>
            A TraceThread represents a thread of execution in a process.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.ThreadID">
            <summary>
            The OS process ID associated with the process. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.ThreadIndex">
            <summary>
            The index into the logical array of TraceThreads for this process.  Unlike ThreadId (which
            may be reused after the thread dies) the T index is unique over the log.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.Process">
            <summary>
            The process associated with the thread. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.StartTime">
            <summary>
            The time when the thread started.  Returns the time the trace started if the thread existed when the trace started.  
            Returned as a DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.StartTimeRelativeMSec">
            <summary>
            The time when the thread started.  Returns the time the trace started if the thread existed when the trace started.  
            Returned as the number of MSec from the beginning of the trace. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.EndTime">
            <summary>
            The time when the thread ended.  Returns the time the trace ended if the thread existed when the trace ended.  
            Returned as a DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.EndTimeRelativeMSec">
            <summary>
            The time when the thread ended.  Returns the time the trace ended if the thread existed when the trace ended. 
            Returned as the number of MSec from the beginning of the trace. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.CPUMSec">
            <summary>
            The amount of CPU time spent on this thread based on the kernel CPU sampling events.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.EventsInThread">
            <summary>
            Filters events to only those for a particular thread. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.EventsDuringThread">
            <summary>
            Filters events to only those that occurred during the time a the thread was alive. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.GetActivityIndex(System.Double)">
            <summary>
            REturns the activity this thread was working on at the time instant 'relativeMsec' 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.DefaultActivityIndex">
            <summary>
            Represents the "default" activity for the thread, the activity that no one has set
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.ThreadInfo">
            <summary>
            ThreadInfo is a string that identifies the thread symbolically.   (e.g. .NET Threadpool, .NET GC)  It may return null if there is no useful symbolic name.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.VerboseThreadName">
            <summary>
            VerboseThreadName is a name for the thread including the ThreadInfo and the CPU time used.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.UserStackBase">
            <summary>
            The base of the thread's stack.  This is just past highest address in memory that is part of the stack
            (we don't really know the lower bound (userStackLimit is this lower bound at the time the thread was created
            which is not very useful).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.ToString">
            <summary>
            An XML representation of the TraceThread (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.#ctor(System.Int32,Microsoft.Diagnostics.Tracing.Etlx.TraceProcess,Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex)">
            <summary>
            Create a new TraceProcess.  It should only be done by log.CreateTraceProcess because
            only TraceLog is responsible for generating a new ProcessIndex which we need.   'processIndex'
            is a index that is unique for the whole log file (where as processID can be reused).  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.activityIds">
            <summary>
            This is a list of the activities (snippet of threads) that have run on this
            thread.   They are ordered by time so you can binary search for your activity based
            on timestamp.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceThread.lastBlockingCSwitchEventIndex">
            <summary>
            We want to have the stack for when CSwtichs BLOCK as well as when they unblock.
            this variable keeps track of the last blocking CSWITCH on this thread so that we can
            compute this.   It is only used during generation of a TraceLog file.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules">
            <summary>
            TraceLoadedModules represents the collection of modules (loaded DLLs or EXEs) in a 
            particular process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.Process">
            <summary>
            The process in which this Module is loaded.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.GetModuleContainingAddress(System.UInt64,System.Double)">
            <summary>
            Returns the module which was mapped into memory at at 'timeRelativeMSec' and includes the address 'address' 
            <para> Note that Jit compiled code is placed into memory that is not associated with the module and thus will not
            be found by this method.
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.GetLoadedModule(System.String,System.Double)">
            <summary>
            Returns the module representing the unmanaged load of a particular fiele at a given time. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.ToString">
            <summary>
            An XML representation of the TraceLoadedModules (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.GetEnumerator">
            <summary>
            Returns all modules in the process.  Note that managed modules may appear twice 
            (once for the managed load and once for an unmanaged (LoadLibrary) load.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.GetLoadedModule(System.String,System.Int64)">
            <summary>
            This function will find the module associated with 'address' at 'timeQPC' however it will only
            find modules that are mapped in memory (module associated with JIT compiled methods will not be found).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.FindManagedModuleAndIndex(System.Int64,System.Int64,System.Int32@)">
            <summary>
            Finds the index and module for an a given managed module ID.  If not found, new module
            should be inserted at index + 1;
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModules.FindModuleAndIndexContainingAddress(System.UInt64,System.Int64,System.Int32@)">
            <summary>
            Finds the index and module for an address that lives within the image.  If the module
            did not match the new entry should go at index+1.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule">
            <summary>
            A TraceLoadedModule represents a module (DLL or EXE) that was loaded into a process.  It represents
            the time that this module was mapped into the processes address space.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.ImageBase">
            <summary>
            The address where the DLL or EXE was loaded.   Will return 0 for managed modules without NGEN images.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.LoadTime">
            <summary>
            The load time is the time the LoadLibrary was done if it was loaded from a file, otherwise is the
            time the CLR loaded the module.  Expressed as a DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.LoadTimeRelativeMSec">
            <summary>
            The load time is the time the LoadLibrary was done if it was loaded from a file, otherwise is the
            time the CLR loaded the module.  Expressed as as MSec from the beginning of the trace.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.UnloadTime">
            <summary>
            The load time is the time the FreeLibrary was done if it was unmanaged, otherwise is the
            time the CLR unloaded the module.  Expressed as a DateTime
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.UnloadTimeRelativeMSec">
            <summary>
            The load time is the time the FreeLibrary was done if it was unmanaged, otherwise is the
            time the CLR unloaded the module.  Expressed as MSec from the beginning of the trace. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.Process">
            <summary>
            The process that loaded this module
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.ModuleID">
            <summary>
            An ID that uniquely identifies the module in within the process.  Works for both the managed and unmanaged case.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.ModuleFile">
            <summary>
            If this managedModule was a file that was mapped into memory (eg LoadLibary), then ModuleFile points at
            it.  If a managed module does not have a file associated with it, this can be null.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.FilePath">
            <summary>
            Shortcut for ModuleFile.FilePath, but returns the empty string if ModuleFile is null
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.Name">
            <summary>
            Shortcut for ModuleFile.Name, but returns the empty string if ModuleFile is null
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.ManagedModule">
            <summary>
            Because .NET applications have AppDomains, a module that is loaded once from a process 
            perspective, might be loaded several times (once for each AppDomain) from a .NET perspective 
            <para> This property returns the loadedModule record for the first such managed module
            load associated with this load.   
            </para>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.ToString">
            <summary>
            An XML representation of the TraceLoadedModule (used for debugging)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.FastSerialization#IFastSerializable#ToStream(FastSerialization.Serializer)">
            <summary>
            See IFastSerializable.ToStream.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLoadedModule.FastSerialization#IFastSerializable#FromStream(FastSerialization.Deserializer)">
            <summary>
            See IFastSerializable.FromStream.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceManagedModule">
            <summary>
            A TraceManagedModule represents the loading of a .NET module into .NET AppDomain.
            It represents the time that that module an be used in the AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceManagedModule.ModuleID">
            <summary>
            The module ID that the .NET Runtime uses to identify the file (module) associated with this managed module
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceManagedModule.AssemblyID">
            <summary>
            The Assembly ID that the .NET Runtime uses to identify the assembly associated with this managed module. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceManagedModule.IsAppDomainNeutral">
            <summary>
            Returns true if the managed module was loaded AppDOmain Neutral (its code can be shared by all appdomains in the process. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceManagedModule.NativeModule">
            <summary>
            If the managed module is an IL module that has an NGEN image, return it. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceManagedModule.ToString">
            <summary>
            An XML representation of the TraceManagedModule (used for debugging)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex">
            <summary>
            CallStackIndex uniquely identifies a callstack within the log.  Valid values are between 0 and
            TraceCallStacks.Count-1. Thus, an array can be used to 'attach' data to a call stack.   
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex.Invalid">
            <summary>
            Returned when no appropriate CallStack exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks">
            <summary>
            Call stacks are so common in most traces, that having a .NET object (a TraceEventCallStack) for
            each one is often too expensive.   As optimization, TraceLog also assigns a call stack index
            to every call stack and this index uniquely identifies the call stack in a very light weight fashion.
            <para>
            To be useful, however you need to be able to ask questions about a call stack index without creating
            a TraceEventCallStack.   This is the primary purpose of a TraceCallStacks (accessible from TraceLog.CallStacks).   
            It has a set of 
            methods that take a CallStackIndex and return properties of the call stack (like its caller or 
            its code address).  
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.Count">
            <summary>
            Returns the count of call stack indexes (all Call Stack indexes are strictly less than this).   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.CodeAddressIndex(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Given a call stack index, return the code address index representing the top most frame associated with it
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.Caller(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Given a call stack index, look up the call stack  index for caller.  Returns CallStackIndex.Invalid at top of stack.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.Depth(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Given a call stack index, returns the number of callers for the call stack 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.Item(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Given a call stack index, returns a TraceCallStack for it.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.CodeAddresses">
            <summary>
            Returns the TraceCodeAddresses instance that can resolve CodeAddressIndexes in the TraceLog 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.ThreadIndex(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Given a call stack index, returns the ThreadIndex which represents the thread for the call stack
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.Thread(Microsoft.Diagnostics.Tracing.Etlx.CallStackIndex)">
            <summary>
            Given a call stack index, returns the TraceThread which represents the thread for the call stack
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.ToString">
            <summary>
            An XML representation of the TraceCallStacks (used for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.GetEnumerator">
            <summary>
            IEnumerable Support
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.SetSize(System.Int32)">
            <summary>
            Used to 'undo' the effects of adding a eventToStack that you no longer want.  This happens when we find
            out that a eventToStack is actually got more callers in it (when a eventToStack is split).  
            </summary>
            <param name="origSize"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStacks.GetRootForThread(Microsoft.Diagnostics.Tracing.Etlx.ThreadIndex)">
            <summary>
            Returns an index that represents the 'threads' of the stack.  It encodes the thread which owns this stack into this. 
            We encode this as -ThreadIndex - 2 (since -1 is the Invalid node)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack">
            <summary>
            A TraceCallStack is a structure that represents a call stack as a linked list. Each TraceCallStack 
            contains two properties, the CodeAddress for the current frame, and the TraceCallStack of the
            caller of this frame.   The Caller property will return null at the thread start frame.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack.CallStackIndex">
            <summary>
             Return the CallStackIndex that uniquely identifies this call stack in the TraceLog.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack.CodeAddress">
            <summary>
            Returns the TraceCodeAddress for the current method frame in the linked list of frames.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack.Caller">
            <summary>
            The TraceCallStack for the caller of of the method represented by this call stack.  Returns null at the end of the list. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack.Depth">
            <summary>
            The depth (count of callers) of this call stack.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack.ToString">
            <summary>
            An XML representation of the TraceCallStack (used for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCallStack.ToString(System.Text.StringBuilder)">
            <summary>
            Writes an XML representation of the TraceCallStack to the stringbuilder 'sb'
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex">
            <summary>
            CodeAddressIndex uniquely identifies a symbolic codeAddress within the log . 
            Valid values are between 0 and TraceCodeAddresses.Count. Thus, an array
            can be used to 'attach' data to a code address.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex.Invalid">
            <summary>
            Returned when no appropriate Method exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses">
            <summary>
            Code addresses are so common in most traces, that having a .NET object (a TraceCodeAddress) for
            each one is often too expensive.   As optimization, TraceLog also assigns a code address index
            to every code address and this index uniquely identifies the code address in a very light weight fashion.
            <para>
            To be useful, however you need to be able to ask questions about a code address index without creating
            a TraceCodeAddress.   This is the primary purpose of a TraceCodeAddresses (accessible from TraceLog.CodeAddresses).   
            It has a set of 
            methods that take a CodeAddressIndex and return properties of the code address (like its method, address, and module file)
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ChunkSize">
            <summary>
            Chunk size for <see cref="F:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.codeAddressObjects"/>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.Count">
            <summary>
            Returns the count of code address indexes (all code address indexes are strictly less than this).   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.Name(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a code address index, return the name associated with it (the method name).  It will
            have the form MODULE!METHODNAME.   If the module name is unknown a ? is used, and if the
            method name is unknown a hexadecimal number is used as the method name.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.Address(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a code address index, returns the virtual address of the code in the process.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ModuleFileIndex(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a code address index, returns the index for the module file (representing the file's path) 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.MethodIndex(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a code address index, returns the index for the method associated with the code address (it may return MethodIndex.Invalid 
            if no method can be found). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ModuleFile(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a code address index, returns the module file (the DLL paths) associated with it
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ILOffset(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            If the code address is associated with managed code, return the IL offset within the method.    If the method
            is unmanaged -1 is returned.   To determine the IL offset the PDB for the NGEN image (for NGENed code) or the
            correct .NET events (for JIT compiled code) must be present.   If this information is not present -1 is returned. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.Item(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Given a code address index, returns a TraceCodeAddress for it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.Methods">
            <summary>
            Returns the TraceMethods object that can look up information from MethodIndexes 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ModuleFiles">
            <summary>
            Returns the TraceModuleFiles that can look up information about ModuleFileIndexes
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ManagedMethodRecordCount">
            <summary>
            Indicates the number of managed method records that were encountered.  This is useful to understand if symbolic information 'mostly works'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.LookupSymbolsForModule(Microsoft.Diagnostics.Symbols.SymbolReader,Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile)">
            <summary>
            Initially CodeAddresses for unmanaged code will have no useful name.  Calling LookupSymbolsForModule 
            lets you resolve the symbols for a particular file so that the TraceCodeAddresses for that DLL
            will have Methods (useful names) associated with them.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.GetSourceLine(Microsoft.Diagnostics.Symbols.SymbolReader,Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            A TraceCodeAddress can contain a method name, but does not contain number information.   To 
            find line number information you must read the PDB again and fetch it.   This is what
            GetSoruceLine does.  
            <para> 
            Given a SymbolReader (which knows how to look up PDBs) and a code address index (which
            represent a particular point in execution), find a SourceLocation (which represents a
            particular line number in a particular source file associated with the code address.
            Returns null if anything goes wrong (and diagnostic information will be written to the
            log file associated with the SymbolReader.
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.TotalCodeAddresses">
            <summary>
            The number of times a particular code address appears in the log.   Unlike TraceCodeAddresses.Count, which tries
            to share a code address as much as possible, TotalCodeAddresses counts the same code address in different 
            call stacks (and even if in the same stack) as distinct.    This makes TotalCodeAddresses a better measure of
            the 'popularity' of a particular address (which can factor into decisions about whether to call LookupSymbolsForModule)
            <para>
            The sum of ModuleFile.CodeAddressesInModule for all modules should sum to this number.
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.UnsafePDBMatching">
            <summary>
            If set to true, will only use the name of the module and not the PDB GUID to confirm that a PDB is correct
            for a given DLL.   Setting this value is dangerous because it is easy for the PDB to be for a different
            version of the DLL and thus give inaccurate method names.   Nevertheless, if a log file has no PDB GUID
            information associated with it, unsafe PDB matching is the only way to get at least some symbolic information. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ToString">
            <summary>
            Returns an XML representation of the TraceCodeAddresses (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.NativeMap(Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            We expose ILToNativeMap internally so we can do diagnostics.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.GetEnumerator">
            <summary>
            IEnumerable support.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.AddMethod(Microsoft.Diagnostics.Tracing.Parsers.Clr.MethodLoadUnloadVerboseTraceData)">
            <summary>
            Called when JIT CLR Rundown events are processed. It will look if there is any
            address that falls into the range of the JIT compiled method and if so log the
            symbolic information (otherwise we simply ignore it)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.AddMethod(Microsoft.Diagnostics.Tracing.Parsers.JScript.MethodLoadUnloadJSTraceData,System.Collections.Generic.Dictionary{Microsoft.Diagnostics.Tracing.Etlx.JavaScriptSourceKey,System.String})">
            <summary>
            Adds a JScript method 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ForAllUnresolvedCodeAddressesInRange(Microsoft.Diagnostics.Tracing.Etlx.TraceProcess,System.UInt64,System.Int32,System.Boolean,Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ForAllCodeAddrAction)">
            <summary>
            Allows you to get a callback for each code address that is in the range from start to 
            start+length within the process 'process'.   If 'considerResolved' is true' then the address range
            is considered resolved and future calls to this routine will not find the addresses (since they are resolved).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.GetOrCreateCodeAddressIndex(Microsoft.Diagnostics.Tracing.Etlx.TraceProcess,System.UInt64)">
            <summary>
            Gets the symbolic information entry for 'address' which can be any address.  If it falls in the
            range of a symbol, then that symbolic information is returned.  Regardless of whether symbolic
            information is found, however, an entry is created for it, so every unique address has an entry
            in this table.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ProcessForAddress(Microsoft.Diagnostics.Tracing.Etlx.TraceProcess,System.UInt64)">
            <summary>
            All processes might have kernel addresses in them, this returns the kernel process (process ID == 0) if 'address' is a kernel address.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.GetSortedCodeAddressIndexes">
            <summary>
            Sort from lowest address to highest address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.LookupSymbols(Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions)">
            <summary>
            Do symbol resolution for all addresses in the log file. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.OpenPdbForModuleFile(Microsoft.Diagnostics.Symbols.SymbolReader,Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile)">
            <summary>
            Look up the SymbolModule (open PDB) for a given moduleFile.   Will generate NGEN pdbs as needed.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.TraceModuleUnchanged(Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile,System.IO.TextWriter,System.String)">
            <summary>
            Returns true if 'moduleFile' seems to be unchanged from the time the information about it
            was generated.  Logs messages to 'log' if it fails.  
            Specify overrideModuleFilePath if the path needs to be converted to a different format in order to be accessed (e.g. from device path to volume path).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.CodeAddressInfo">
            <summary>
            A CodeAddressInfo is the actual data stored in the ETLX file that represents a 
            TraceCodeAddress.     It knows its Address in the process and it knows the 
            TraceModuleFile (which knows its base address), so it also knows its relative
            address in the TraceModuleFile (which is what is needed to look up the value 
            in the PDB.  
            
            Note that by the time that the CodeAddressInfo is persisted in the ETLX file
            it no longer knows the process it originated from (thus separate processes 
            with the same address and same DLL file loaded at the same address can share
            the same CodeAddressInfo.  This is actually reasonably common, since OS tend
            to load at their preferred base address.  
            
            We also have to handle the managed case, in which case the CodeAddressInfo may
            also know about the TraceMethod or the ILMapIndex (which remembers both the
            method and the line numbers for managed code. 
            
            However when the CodeAddressInfo is first created, we don't know the TraceModuleFile
            so we also need to remember the Process
            
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.CodeAddressInfo.GetProcessIndex(Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses)">
            <summary>
            This is only valid until MethodIndex or ModuleFileIndex is set.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.CodeAddressInfo.GetMethodIndex(Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses)">
            <summary>
            Only for managed code.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.CodeAddressInfo.GetModuleFileIndex(Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses)">
            <summary>
            Only for unmanaged code.   TODO, this can be folded into methodOrProcessIlMap index and save a DWORD.  
            since if the method or IlMap is present then you can get the ModuelFile index from there.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.CodeAddressInfo.InclusiveCount">
            <summary>
            This is a count of how many times this code address appears in any stack in the trace.  
            It is a measure of what popular the code address is (whether we should look up its symbols).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.FindAndRemove(System.Int64,Microsoft.Diagnostics.Tracing.Etlx.ProcessIndex,Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddresses.ILMapIndex@)">
            <summary>
            Find the ILToNativeMap for 'methodId' in process associated with 'processIndex' 
            and then remove it from the table (this is what you want to do when the method is unloaded)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress">
             <summary>
             Conceptually a TraceCodeAddress represents a particular point of execution within a particular 
             line of code in some source code.    As a practical matter, they are represented two ways
             depending on whether the code is managed or not.
             <para>* For native code (or NGened code), it is represented as a virtual address along with the loaded native
             module that includes that address along with its load address.  A code address does NOT 
             know its process because they can be shared among all processes that load a particular module
             at a particular location.   These code addresses will not have methods associated with them
             unless symbols information (PDBS) are loaded for the module using the LookupSymbolsForModule.  
             </para>
             <para> * For JIT compiled managed code, the address in a process is eagerly resolved into a method, module
             and an IL offset and that is stored in the TraceCodeAddress.  
             </para>
            <para> Sometimes it is impossible to even determine the module associated with a virtual
            address in a process.   These are represented as simply the virtual address.  
            </para>
            <para>
            Because code addresses are so numerous, consider using CodeAddressIndex instead of TraceCodeAddress
            to represent a code address.   Methods on TraceLog.CodeAddresses can access all the information
            that would be in a TraceCodeAddress from a CodeAddressIndex without the overhead of creating
            a TraceCodeAddress object. 
            </para>
             </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.CodeAddressIndex">
            <summary>
            The CodeAddressIndex that uniquely identifies the same code address as this TraceCodeAddress
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.Address">
            <summary>
            The Virtual address of the code address in the process.  (Note that the process is unknown by the code address to allow for sharing)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.FullMethodName">
            <summary>
            The full name (Namespace name.class name.method name) of the method associated with this code address.   
            Returns the empty string if no method is associated with the code address. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.Method">
            <summary>
            Returns the TraceMethod associated with this code address or null if there is none. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.ILOffset">
            <summary>
            If the TraceCodeAddress is associated with managed code, return the IL offset within the method.    If the method
            is unmanaged -1 is returned.   To determine the IL offset the PDB for the NGEN image (for NGENed code) or the
            correct .NET events (for JIT compiled code) must be present.   If this information is not present -1 is returned. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.GetSourceLine(Microsoft.Diagnostics.Symbols.SymbolReader)">
            <summary>
            A TraceCodeAddress can contain a method name, but does not contain number information.   To 
            find line number information you must read the PDB again and fetch it.   This is what
            GetSoruceLine does.  
            <para> 
            Given a SymbolReader (which knows how to look up PDBs) find a SourceLocation (which represents a
            particular line number in a particular source file associated with the current TraceCodeAddress.
            Returns null if anything goes wrong (and diagnostic information will be written to the
            log file associated with the SymbolReader.
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.ModuleFile">
            <summary>
            Returns the TraceModuleFile representing the DLL path associated with this code address (or null if not known)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.ModuleName">
            <summary>
            ModuleName is the name of the file without path or extension. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.ModuleFilePath">
            <summary>
            The full path name of the DLL associated with this code address.  Returns empty string if not known. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.CodeAddresses">
            <summary>
            The CodeAddresses container that this Code Address lives within
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.ToString">
            <summary>
            An XML representation for the CodeAddress (for debugging)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceCodeAddress.ToString(System.Text.StringBuilder)">
            <summary>
            Writes an XML representation for the CodeAddress to the stringbuilder sb
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.MethodIndex">
            <summary>
            MethodIndex uniquely identifies a method within the log.  Valid values are between 0 and
            TraceMethods.Count-1. Thus, an array can be used to 'attach' data to a method.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.MethodIndex.Invalid">
            <summary>
            Returned when no appropriate Method exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods">
            <summary>
            Methods are so common in most traces, that having a .NET object (a TraceMethod) for
            each one is often too expensive.   As optimization, TraceLog also assigns a method index
            to every method and this index uniquely identifies the method in a very light weight fashion.
            <para>
            To be useful, however you need to be able to ask questions about a method index without creating
            a TraceMethod.   This is the primary purpose of a TraceMethods (accessible from TraceLog.CodeAddresses.Methods).   
            It has a set of 
            methods that take a MethodIndex and return properties of the method (like its name, and module file)
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.Count">
            <summary>
            Returns the count of method indexes.  All MethodIndexes are strictly less than this. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.MethodToken(Microsoft.Diagnostics.Tracing.Etlx.MethodIndex)">
            <summary>
            Given a method index, if the method is managed return the IL meta data MethodToken (returns 0 for native code)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.MethodRva(Microsoft.Diagnostics.Tracing.Etlx.MethodIndex)">
            <summary>
            Given a method index, return the Method's RVA (offset from the base of the DLL in memory)  (returns 0 for managed code)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.MethodModuleFileIndex(Microsoft.Diagnostics.Tracing.Etlx.MethodIndex)">
            <summary>
            Given a method index, return the index for the ModuleFile associated with the Method Index.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.FullMethodName(Microsoft.Diagnostics.Tracing.Etlx.MethodIndex)">
            <summary>
            Given a method index, return the Full method name (Namespace.ClassName.MethodName) associated with the Method Index.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.Item(Microsoft.Diagnostics.Tracing.Etlx.MethodIndex)">
            <summary>
            Given a method index, return a TraceMethod that also represents the method.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.ToString">
            <summary>
            Returns an XML representation of the TraceMethods.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethods.GetEnumerator">
            <summary>
            IEnumerable support
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod">
            <summary>
            A TraceMethod represents the symbolic information for a particular method.   To maximizes haring a TraceMethod 
            has very little state, just the module and full method name.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.MethodIndex">
            <summary>
            Each Method in the TraceLog is given an index that uniquely identifies it.  This return this index for this TraceMethod
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.FullMethodName">
            <summary>
            The full name of the method (Namespace.ClassName.MethodName). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.MethodToken">
            <summary>
            .Net runtime methods have a token (32 bit number) that uniquely identifies it in the meta data of the managed DLL.  
            This property returns this token. Returns 0 for unmanaged code or method not found. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.MethodRva">
            <summary>
            For native code the RVA (relative virtual address, which is the offset from the base of the file in memory)
            for the method in the file. Returns 0 for managed code or method not found;
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.MethodModuleFileIndex">
            <summary>
            Returns the index for the DLL ModuleFile (which represents its file path) associated with this method
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.MethodModuleFile">
            <summary>
            Returns the ModuleFile (which represents its file path) associated with this method
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.ToString">
            <summary>
            A XML representation of the TraceMethod. (Used for debugging)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.ToString(System.Text.StringBuilder)">
            <summary>
            Writes an XML representation of the TraceMethod to the stringbuilder 'sb'
            </summary>
            <param name="sb"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceMethod.PrefixOptimizationTier(System.String,Microsoft.Diagnostics.Tracing.Parsers.Clr.OptimizationTier)">
            <summary>
            Returns a new string prefixed with the optimization tier if it would be useful. Typically used to adorn a method's
            name with the optimization tier of the specific code version of the method.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.ModuleFileIndex">
            <summary>
            A ModuleFileIndex represents a particular file path on the disk.   It is a number
            from 0 to MaxModuleFileIndex, which means that you can create a side array to hold
            information about module files.
            
            You can look up information about the ModuleFile from the ModuleFiles type.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.ModuleFileIndex.Invalid">
            <summary>
            Returned when no appropriate ModuleFile exists.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles">
            <summary>
            TraceModuleFiles is the list of all the ModuleFiles in the trace.   It is an IEnumerable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.Count">
            <summary>
            Each file is given an index for quick lookup.   Count is the
            maximum such index (thus you can create an array that is 1-1 with the
            files easily).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.Item(Microsoft.Diagnostics.Tracing.Etlx.ModuleFileIndex)">
            <summary>
            Given a ModuleFileIndex, find the TraceModuleFile which also represents it
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.Log">
            <summary>
            Returns the TraceLog associated with this TraceModuleFiles
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.ToString">
            <summary>
            Returns an XML representation of the TraceModuleFiles
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.System#Collections#Generic#IEnumerable{Microsoft#Diagnostics#Tracing#Etlx#TraceModuleFile}#GetEnumerator">
            <summary>
            Enumerate all the files that occurred in the trace log.  
            </summary> 
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.GetOrCreateModuleFile(System.String,System.UInt64)">
            <summary>
            We cache information about a native image load in a TraceModuleFile.  Retrieve or create a new
            cache entry associated with 'nativePath' and 'moduleImageBase'.  'moduleImageBase' can be 0 for managed assemblies
            that were not loaded with LoadLibrary.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFiles.GetModuleFile(System.String,System.UInt64)">
            <summary>
            For a given file name, get the TraceModuleFile associated with it.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile">
            <summary>
            The TraceModuleFile represents a executable file that can be loaded into memory (either an EXE or a
            DLL).  It represents the path on disk as well as the location in memory where it loads (or
            its ModuleID if it is a managed module), but not the load or unload time or the process in which
            it was loaded (this allows them to be shared within the trace).   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ModuleFileIndex">
            <summary>
            The ModuleFileIndex ID that uniquely identifies this module file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.FilePath">
            <summary>
            The moduleFile name associated with the moduleFile.  May be the empty string if the moduleFile has no moduleFile
            (dynamically generated).  For managed code, this is the IL moduleFile name.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.Name">
            <summary>
            This is the short name of the moduleFile (moduleFile name without extension). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ImageBase">
            <summary>
            Returns the address in memory where the dll was loaded.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ImageSize">
            <summary>
            Returns the size of the DLL when loaded in memory
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ImageEnd">
            <summary>
            Returns the address just past the memory the module uses. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.PdbName">
            <summary>
            The name of the symbol file (PDB file) associated with the DLL
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.PdbSignature">
            <summary>
            Returns the GUID that uniquely identifies the symbol file (PDB file) for this DLL
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.PdbAge">
            <summary>
            Returns the age (which is a small integer), that is also needed to look up the symbol file (PDB file) on a symbol server.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.FileVersion">
            <summary>
            Returns the file version string that is optionally embedded in the DLL's resources.   Returns the empty string if not present. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ProductName">
            <summary>
            Returns the product name  recorded in the file version information.     Returns empty string if not present
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ProductVersion">
            <summary>
            Returns a version string for the product as a whole (could include GIT source code hash).    Returns empty string if not present
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ImageChecksum">
            <summary>
            This is the checksum value in the PE header. Can be used to validate 
            that the file on disk is the same as the file from the trace.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ImageId">
            <summary>
            This used to be called TimeDateStamp, but linkers may not use it as a 
            timestamp anymore because they want deterministic builds.  It still is 
            useful as a unique ID for the image.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.IsReadyToRun">
            <summary>
            Tells if the module file is ReadyToRun (the has precompiled code for some managed methods)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.GitCommitHash">
            <summary>
            If the Product Version fields has a GIT Commit Hash component, this returns it,  Otherwise it is empty.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.BuildTime">
            <summary>
            Returns the time the DLL was built as a DateTime.   Note that this may not
            work if the build system uses deterministic builds (in which case timestamps
            are not allowed.   We may not be able to tell if this is a bad timestamp
            but we include it because when it is timestamp it is useful.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.CodeAddressesInModule">
            <summary>
            The number of code addresses included in this module.  This is useful for determining if 
            this module is worth having its symbolic information looked up or not.   It is not 
            otherwise a particularly interesting metric.  
            <para>
            This number is defined as the number of appearances this module has in any stack 
            or any event with a code address (If the modules appears 5 times in a stack that
            counts as 5 even though it is just one event's stack).  
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ManagedModule">
            <summary>
            If the module file was a managed native image, this is the IL file associated with it.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceModuleFile.ToString">
            <summary>
            Returns an XML representation of the TraceModuleFile (for debugging) 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.ActivityIndex">
            <summary>
            A ActivityIndex uniquely identifies an Activity in the log. Valid values are between
            0 and Activities.Count-1.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.ActivityIndex.Invalid">
            <summary>
            valid activity indexes are non-negative integers
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity">
            <summary>
            Representation of an Activity. An activity can be thought of as a unit of execution associated with
            a task or workitem; it executes on one thread, and has a start and end time. An activity keeps track
            of its "creator" or "caller" -- which is the activity that scheduled it. Using the "creator" link a
            user can determine the chain of activities that led up to the current one.
            
            Given an event you can get the Activity for the event using the Activity() extension method.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind">
            <summary>
            Describes the kinds of known Activities (used for descriptive purposes alone)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.Invalid">
            <summary>Invalid</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.Initial">
            <summary>
            Default activity on a thread (when the thread does not execute any code on
            behalf of anyone else)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.TaskScheduled">
            <summary>
            An activity that was initiated by a Task.Run
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.TaskStarted">
            <summary>
            An activity that's a task, but for which we didn't see a "Scheduled" event
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.AwaitTaskScheduled">
            <summary>
            An activity that allows correlation between the antecedent and continuation 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.ClrThreadStart">
            <summary>A thread started with Thread.Start</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.ClrThreadPool">
            <summary>Native CLR threadpool workitem</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.ClrIOThreadPool">
            <summary>Native CLR IO threadpool workitem</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.FxThreadPool">
            <summary>Managed threadpool workitem</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.FxTransfer">
            <summary>Generic managed thread transfer</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.FxAsyncIO">
            <summary>Managed async IO workitem</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.FxWinRTDispatch">
            <summary>WinRT Dispatched workitem</summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.Implied">
            <summary>
            Used when we make up ones because we know that have to be there but we don't know enough to do more than that. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.TaskWait">
            <summary>
            An activity that allows correlation between the antecedent and continuation 
            if have bit 5 set it means you auto-compete
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.TaskWaitSynchronous">
            <summary>
            Same as TaskWait, hwoever it auto-completes
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ActivityKind.FxTimer">
            <summary>
            Managed timer workitem
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.Index">
            <summary>A trace-wide unique id identifying an activity</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.Creator">
            <summary>The activity that initiated or caused the current one</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ID">
            <summary>
            This return an unique string 'name' for the activity.  It is a the Index followed by 
            a - followed by the TPL index (if available).  It is a bit nicer since it gives
            more information for debugging.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.Path">
            <summary>
            Computes the creator path back to root. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.Thread">
            <summary>The thread on which the activity is running</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.MultiTrigger">
            <summary>True if there may be multiple activities that were initiated by caller (e.g. managed Timers)</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.Name">
            <summary>A descriptive label for the activity
                TODO: eliminate and use ToString()?
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.IsThreadActivity">
            <summary>
            A thread activity is the activity associate with an OS thread.   It is special because it may 
            have a region that is disjoint.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.StartTimeRelativeMSec">
            <summary>Time from beginning of trace (in msec) when activity started executing</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.EndTimeRelativeMSec">
            <summary>Time from beginning of trace (in msec) when activity completed execution.  Does not include children.</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.CreationEventIndex">
            <summary>The event index of the TraceEvent instance that created/scheduled this activity</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.CreationCallStackIndex">
            <summary>The call stack index of the TraceEvent instance that scheduled (caused the creation of) the activity</summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.CreationTimeRelativeMSec">
            <summary>Time from beginning of trace (in msec) when activity was scheduled</summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceActivity.ToString">
            <summary>
            To use mainly for debugging
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions">
            <summary>
            TraceLogOptions control the generation of a TraceLog (ETLX file) from an ETL file.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.#ctor">
            <summary>
            Creates a new object containing options for constructing a TraceLog file.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.ShouldResolveSymbols">
            <summary>
            If non-null, this is a predicate that, given a file path to a dll, answers the question
            whether the PDB associated with that DLL be looked up and its symbolic information added
            to the TraceLog file as part of conversion.   Symbols can be looked up afterward when 
            the file is later opened, so the default (which is to look up no symbols during
            conversion) is typically OK. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.LocalSymbolsOnly">
            <summary>
            Resolving symbols from a symbol server can take a long time. If
            there is a DLL that always fails, it can be quite annoying because
            it will always cause delays, By specifying only local symbols it
            will only resolve the symbols if it can do so without the delay of network traffic. 
            Symbols that have been previously cached locally from a symbol
            server count as local symbols.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.AlwaysResolveSymbols">
            <summary>
            By default symbols are only resolved if there are stacks associated with the trace. 
            Setting this option forces resolution even if there are no stacks. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.ConversionLog">
            <summary>
            Writes status to this log.  Useful for debugging symbol issues.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.ConversionLogName">
            <summary>
            If ConversionLogName is set, it indicates that any messages associated with creating the TraceLog should be written here. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.KeepAllEvents">
            <summary>
            ETL files typically contain a large number of 'bookkeeping' event for resolving names of files, or methods or to indicate information
            about processes that existed when the trace was started (DCStart and DCStop events).   By default these events are stripped from
            the ETLX file because their information has already been used to do the bookkeeping as part of the conversion
            <para> 
            However sometimes it is useful to keep these events (typically for debugging TraceEvent itself) and setting this
            property to true will cause every event in the ETL file to be copied as an event to the ETLX file.  
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.MaxEventCount">
            <summary>
            Sometimes ETL files are too big , and you just want to look at a fraction of it to speed things up
            (or to keep file size under control).  The MaxEventCount property allows that.   10M will produce a 3-4GB ETLX file.  
            1M is a good value to keep ETLX file size under control.  Note that that the conversion still scan the entire 
            original ETL file too look for bookkeeping events, however MaxEventCount events will be transferred to the ETLX 
            file as events.
            <para>
            The default is 10M because ETLX has a restriction of 4GB in size.  
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.SkipMSec">
            <summary>
            If an ETL file has too many events for efficient processing the first part of the trace can be skipped by setting this
            property.   Any event which happens before 'SkipMSec' into the session will be filtered out.   This property is
            intended to be used along with the MaxEventCount property to carve out a arbitrary chunk of time from an ETL
            file as it is converted to an ETLX file.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.OnLostEvents">
            <summary>
            If this delegate is non-null, it is called if there are any lost events or if the file was truncated.
            It is passed a bool whether the ETLX file was truncated, as well as the number of lost events and the 
            total number of events in the ETLX file.  You can throw if you want to abort.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.ExplicitManifestDir">
            <summary>
            If you have the manifests for particular providers, you can read them in explicitly by setting this directory.
             All files of the form *.manifest.xml will be read into the DynamicTraceEventParser's database before conversion
             starts.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Etlx.TraceLogOptions.ContinueOnError">
            <summary>
            If errors occur during conversion, just assume the traced ended at that point and continue. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions">
            <summary>
            The TraceEvent instances returned during the processing of a TraceLog have additional capabilities that these extension methods can access.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.Process(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the TraceProcess associated with a TraceEvent.
            Guaranteed to be non-null for non-real-time sessions if the process ID is != -1 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.Thread(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the TraceThread associated with a TraceEvent. 
            Guaranteed to be non-null for non-real-time sessions if the process ID is != -1 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.Log(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the TraceLog associated with a TraceEvent.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.CallStack(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the TraceCallStack associated with a TraceEvent.   Returns null if the event does not have callstack.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.CallStackIndex(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the CallStack index associated with a TraceEvent.   Returns Invalid if the event does not have callstack.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.BlockingStack(Microsoft.Diagnostics.Tracing.Parsers.Kernel.CSwitchTraceData)">
            <summary>
            Finds the CallStack index associated the blocking thread for CSwitch event
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.CallStacks(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the TraceCallStacks associated with a TraceEvent.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.Activity(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the Activity associated with a TraceEvent
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.ActivityIndex(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Finds the ActivityIndex associated with a TraceEvent
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.ProgramCounterAddress(Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryPageFaultTraceData)">
            <summary>
            For a PageFaultTraceData event, gets the TraceCodeAddress associated with the ProgramCounter address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.ProgramCounterAddressIndex(Microsoft.Diagnostics.Tracing.Parsers.Kernel.MemoryPageFaultTraceData)">
            <summary>
            For a PageFaultTraceData event, gets the CodeAddressIndex associated with the ProgramCounter address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.IntructionPointerCodeAddress(Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData)">
            <summary>
            For a SampledProfileTraceData event, gets the TraceCodeAddress associated with the InstructionPointer address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.IntructionPointerCodeAddressIndex(Microsoft.Diagnostics.Tracing.Parsers.Kernel.SampledProfileTraceData)">
            <summary>
            For a SampledProfileTraceData event, gets the CodeAddressIndex associated with the InstructionPointer address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.SysCallAddress(Microsoft.Diagnostics.Tracing.Parsers.Kernel.SysCallEnterTraceData)">
            <summary>
            For a SysCallEnterTraceData event, gets the CodeAddressIndex associated with the SysCallAddress address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.IntructionPointerCodeAddress(Microsoft.Diagnostics.Tracing.Parsers.Kernel.PMCCounterProfTraceData)">
            <summary>
            For a PMCCounterProfTraceData event, gets the TraceCodeAddress associated with the InstructionPointer address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.IntructionPointerCodeAddressIndex(Microsoft.Diagnostics.Tracing.Parsers.Kernel.PMCCounterProfTraceData)">
            <summary>
            For a PMCCounterProfTraceData event, gets the CodeAddressIndex associated with the InstructionPointer address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.RoutineCodeAddressIndex(Microsoft.Diagnostics.Tracing.Parsers.Kernel.ISRTraceData)">
            <summary>
            For a ISRTraceData event, gets the CodeAddressIndex associated with the Routine address. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Etlx.TraceLogExtensions.RoutineCodeAddressIndex(Microsoft.Diagnostics.Tracing.Parsers.Kernel.DPCTraceData)">
            <summary>
            For a DPCTraceData event, gets the CodeAddressIndex associated with the Routine address. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceLoggingEventId">
            <summary>
            TraceLoggingEvnetId is a class that manages assigning event IDs (small 64k numbers)
            to TraceLogging Style events (which don't have them).  Because TraceEvent uses EventIDs
            so fundamentally this deficiency is very problematic.   
            
            Arguably this should have been done by the ETW system itself.  
            
            You use it by calling TestForTraceLoggingEventAndFixupIfNeeded on eventRecords.  
            You also have to explicitly call 'Dispose' when you are done with this class.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceLoggingEventId.TestForTraceLoggingEventAndFixupIfNeeded(Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_RECORD*)">
            <summary>
            Checks to see if eventRecord has TraceLogging meta data associated with it (EVENT_HEADER_EXT_TYPE_EVENT_SCHEMA_TL)
            and if so updates EventHeader.Id to be an event ID unique to that provider/opcode/meta-data blob. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceLoggingEventId.Dispose">
            <summary>
            cleans up native memory allocated by this routine.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceLoggingEventId.TestForTraceLoggingEventAndFixupIfNeededHelper(Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_RECORD*)">
            <summary>
            Checks to see if this event has TraceLogging meta data associated with it (EVENT_HEADER_EXT_TYPE_EVENT_SCHEMA_TL)
            and if so updates EventHeader.Id to be an event ID unique to that provider/opcode/meta-data blob. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.TraceLoggingEventId.GetEventIDForTraceLoggingEvent(Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_RECORD*,Microsoft.Diagnostics.Tracing.TraceEventNativeMethods.EVENT_HEADER_EXTENDED_DATA_ITEM*)">
            <summary>
            given that 'eventRecord' is a TraceLogging event (with meta-data 'metaData'), return a eventID that is unique
            to that provider/opcode/meta-data blob.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.TraceLoggingEventId.ProviderMetaDataKey">
            <summary>
            ProviderMetaDataKey is what we use to look up TraceLogging meta-data.  It is 
            basically just GUID (representing the provider) an opcode (start/stop) and 
            a blob (representing the TraceLogging meta-data for an event) that knows how to 
            compare itself so it can be a key to a hash table. 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Utilities.HistoryDictionary`2">
            <summary>
            A HistoryDictionary is designed to look up 'handles' (pointer sized quantities), that might get reused
            over time (eg Process IDs, thread IDs).  Thus it takes a handle AND A TIME, and finds the value
            associated with that handle at that time.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Utilities.HistoryDictionary`2.Add(`0,System.Int64,`1,System.Boolean)">
            <summary>
            Adds the association that 'id' has the value 'value' from 'startTime100ns' ONWARD until
            it is supersede by the same id being added with a time that is after this.   Thus if
            I did Add(58, 1000, MyValue1), and add(58, 500, MyValue2) 'TryGetValue(58, 750, out val) will return
            MyValue2 (since that value is 'in force' between time 500 and 1000.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Utilities.HistoryDictionary`2.Remove(`0)">
            <summary>
            Remove all entries associated with a given key (over all time).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.Utilities.FastStream">
            <summary>
            The is really what BinaryReader should have been... (sigh)
            
            We need really fast, byte-by-byte streaming. ReadChar needs to be inliable .... All the routines that
            give back characters assume the bytes are ASCII (The translations from bytes to chars is simply a
            cast).
            
            The basic model is that of a Enumerator. There is a 'Current' property that represents the current
            byte, and 'MoveNext' that moves to the next byte and returns false if there are no more bytes. Like
            Enumerators 'MoveNext' needs to be called at least once before 'Current' is valid.
            
            Unlike standard Enumerators, FastStream does NOT consider it an error to read 'Current' is read when
            there are no more characters.  Instead Current returns a Sentinal value (by default this is 0, but
            the 'Sentinal' property allow you to choose it).   This is often more convenient and efficient to
            allow checking end-of-file (which is rare), to happen only at certain points in the parsing logic.  
            
            Another really useful feature of this stream is that you can peek ahead efficiently a large number
            of bytes (since you read ahead into a buffer anyway).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Tracing.Utilities.FastStream.Sentinal">
            <summary>
            For efficient reads, we allow you to read Current past the end of the stream.  You will
            get the 'Sentinal' value in that case.  This defaults to 0, but you can change it if 
            there is a better 'rare' value to use as an end of stream marker.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Utilities.FastStream.ReadFixedString(System.Int32,System.Text.StringBuilder)">
            <summary>
            Reads 'charCount' characters into the string build sb from the source.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Utilities.FastStream.ReadAsciiStringUpToAny(System.String,System.Text.StringBuilder)">
            <summary>
            Reads the string into the stringBuilder until a byte is read that
            is one of the characters in 'endMarkers'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Utilities.FastStream.ReadAsciiStringUpToLastBeforeTrue(System.Char,System.Text.StringBuilder,System.Func{System.Byte,System.Boolean})">
            <summary>
            Reads the stream into the string builder until the last end marker on the line is hit.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Utilities.FastStream.ReadAsciiStringUpToTrue(System.Text.StringBuilder,System.Func{System.Byte,System.Boolean})">
            <summary>
            Reads the stream in the string builder until the given predicate function is false.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Utilities.FastStream.Peek(System.UInt32)">
            <summary>
            Returns a number of bytes ahead without advancing the pointer. 
            Peek(0) is the same as calling Current.  
            </summary>
            <param name="bytesAhead"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Utilities.FastStream.Skip(System.UInt32)">
            <summary>
            Moves through the FastStream without actually reading data.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Utilities.FastStream.ReadSubStream(System.Int32,System.String)">
            <summary>
            Creates a FastStream with the read in stream with the given length.
            The "trail" is am ASCII string that is attached to the end of the returned FastStream.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Utilities.FastStream.PeekString(System.Int32)">
            <summary>
            Gets a string from the position to the length indicated (for debugging)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ZippedETLWriter">
            <summary>
            ZippedETLWriter is a helper class used to compress ETW data (ETL files)
            along with symbolic information (e.g. NGEN pdbs), as well as other optional
            metadata (e.g. collection log files), into a single archive ready for 
            transfer to another machine.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLWriter.#ctor(System.String,System.IO.TextWriter)">
            <summary>
            Declares the intent to write a new ZIP archive that will
            contain ETW file 'etlFilePath' in it as well as symbolic information (NGEN
            pdbs) and possibly other information.   log is a Text stream to send detailed
            information to.  
            <para>
            This routine assumes by default (unless Merge is set to false) that the ETL 
            file needs to be merged before it is archived.   It will also generate all
            the NGEN pdbs needed for the archive.   
            </para>
            <para>
            You must call the WriteArchive method before any operations actually happen. 
            Up to that point is is just remembering instructions for WriteArchive to
            follow.  
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.ZipArchivePath">
            <summary>
            This is the name of the output archive.  By default is the same as the ETL file name 
            with a .zip' suffix added (thus it will typically be .etl.zip).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.Log">
            <summary>
            If set this is where messages about progress and detailed error information goes.  
            While you dont; have to set this, it is a good idea to do so.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLWriter.AddFile(System.String,System.String)">
            <summary>
            By default ZippedETL file will zip the ETL file itself and the NGEN pdbs associated with it.
            You can add additional files to the archive by calling AddFile.   In specififed 'archivePath' 
            is the path in the archive and defaults to just the file name of the original file path.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLWriter.WriteArchive(System.IO.Compression.CompressionLevel)">
            <summary>
            Actually do the work specified by the ZippedETLWriter constructors and other methods.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.SymbolReader">
            <summary>
            This is the symbol reader that is used to generate the NGEN Pdbs as needed
            If it is not specififed one is created on the fly.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.Merge">
            <summary>
            By default the ETL file is merged before being added to the archive.  If
            this is not necessary, you can set this to false.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.MergeImageIDsOnly">
            <summary>
            By default there are a number of steps to merging an ETL file.  Sometimes,
            it is desirable to only perform ImageID merging.  If desired, set this to true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.CompressETL">
            <summary>
            Uses a compressed format for the ETL file.   Normally off.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.NGenSymbolFiles">
            <summary>
            By default the symbol files (PDBs) are included in the ZIP file.   If this
            is not desired for whatever reason, this property can be set to false.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.LowPriority">
            <summary>
            Do the work at low priority so as to avoid impacting the system. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.Zip">
            <summary>
            Normally WriteArchive creates a ZIP archive.  However it is possible that you only wish
            to do the merging and NGEN symbol generation.   Setting this property to false
            will suppress the final ZIP operation.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.DeleteInputFile">
            <summary>
            Normally if you ZIP you will delete the original ETL file.  Setting this to false overrides this.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.IncludeExistingPDBs">
            <summary>
            When merging an ETL for the first time, we might generate some NGEN PDBs and save them as part of the archive.
            When merging the second time, use this option to make sure that the PDBs that were part of the original archive are included in the new archive.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLWriter.GetNGenPdbs(System.String,Microsoft.Diagnostics.Symbols.SymbolReader,System.IO.TextWriter)">
            <summary>
            Returns the list of path names to the NGEN pdbs for any NGEN image in 'etlFile' that has
            any samples in it.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ZippedETLReader">
            <summary>
            ZippedETLReader is a helper class that unpacks the ZIP files generated
            by the ZippedETLWriter class.    It can be smart about placing the 
            symbolic information in these files on the SymbolReader's path so that
            symbolic lookup 'just works'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLReader.#ctor(System.String,System.IO.TextWriter)">
            <summary>
            Declares the intent to unzip an .ETL.ZIP file that contain an compressed ETL file 
            (and NGEN pdbs) from the archive at 'zipFilePath'.   If present, messages about
            the unpacking go to 'log'.   Note that this unpacking only happens when the
            UnpackArchive() method is called.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLReader.Log">
            <summary>
            If set messages about unpacking go here. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLReader.EtlFileName">
            <summary>
            The name of the ETL file to extract (it is an error if there is not exactly 1).  
            If not present it is derived by changing the extension of the zip archive. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLReader.SymbolDirectory">
            <summary>
            Where to put the symbols.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLReader.UnpackArchive">
            <summary>
            After setting any properties to override default behavior, calling this method
            will actually do the unpacking.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.NativeSymbolModule">
            <summary>
            A NativeSymbolModule represents symbol information for a native code module.   
            NativeSymbolModules can potentially represent Managed modules (which is why it is a subclass of that interface).  
            
            NativeSymbolModule should just be the CONTRACT for Native Symbols (some subclass implements
            it for a particular format like Windows PDBs), however today because we have only one file format we
            simply implement Windows PDBS here.   This can be factored out of this class when we 
            support other formats (e.g. Dwarf).
            
            To implmente support for Windows PDBs we use the Debug Interface Access (DIA).  See 
            http://msdn.microsoft.com/library/x93ctkx8.aspx for more.   I have only exposed what
            I need, and the interface is quite large (and not super pretty).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.GetTypeForHeapAllocationSite(System.UInt32)">
            <summary>
            Returns the name of the type allocated for a given relative virtual address.
            Returns null if the given rva does not match a known heap allocation site.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.FindNameForRva(System.UInt32)">
            <summary>
            Finds a (method) symbolic name for a given relative virtual address of some code.  
            Returns an empty string if a name could not be found. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.FindNameForRva(System.UInt32,System.UInt32@)">
            <summary>
            Finds a (method) symbolic name for a given relative virtual address of some code.  
            Returns an empty string if a name could not be found.  
            symbolStartRva is set to the start of the symbol start 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.SourceLocationForRva(System.UInt32)">
            <summary>
            Fetches the source location (line number and file), given the relative virtual address (RVA)
            of the location in the executable.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.SourceLocationForRva(System.UInt32,System.String@,System.UInt32@,System.Int32@)">
            <summary>
            This overload of SourceLocationForRva like the one that takes only an RVA will return a source location
            if it can.   However this version has additional support for NGEN images.   In the case of NGEN images 
            for .NET V4.6.1 or later), the NGEN images can't convert all the way back to a source location, but they 
            can convert the RVA back to IL artifacts (ilAssemblyName, methodMetadataToken, iloffset).  THese can then
            be used to look up the source line using the IL PDB.  
            
            Thus if the return value from this is null, check to see if the ilAssemblyName is non-null, and if not 
            you can look up the source location using that information.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.SourceLocationForManagedCode(System.UInt32,System.Int32)">
            <summary>
            Managed code is shipped as IL, so RVA to NATIVE mapping can't be placed in the PDB. Instead
            what is placed in the PDB is a mapping from a method's meta-data token and IL offset to source
            line number.  Thus if you have a metadata token and IL offset, you can again get a source location
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.NativeSymbolModule.GlobalSymbol">
            <summary>
            The symbol representing the module as a whole.  All global symbols are children of this symbol 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.NativeSymbolModule.PdbGuid">
            <summary>
            The a unique identifier that is used to relate the DLL and its PDB.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.NativeSymbolModule.PdbAge">
            <summary>
            Along with the PdbGuid, there is a small integer 
            call the age is also used to find the PDB (it represents the different 
            post link transformations the DLL has undergone).  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.NativeSymbolModule.MicrosoftPdbSourceFile">
            <summary>
            A source file represents a source file from a PDB.  This is not just a string
            because the file has a build time path, a checksum, and it needs to be 'smart'
            to copy down the file if requested.  
            
            TODO We don't need this subclass.   We can have SourceFile simply a container
            that holds the BuildTimePath, hashType and hashValue.    The lookup of the
            source can then be put on NativeSymbolModule and called from SourceFile generically.  
            This makes the different symbol files more similar and is a nice simplification.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.MicrosoftPdbSourceFile.GetSourceLinkInfo(System.String@,System.String@)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.MicrosoftPdbSourceFile.GetSourceFromSrcServer">
             <summary>
             Try to fetch the source file associated with 'buildTimeFilePath' from the symbol server 
             information from the PDB from 'pdbPath'.   Will return a path to the returned file (uses 
             SourceCacheDirectory associated symbol reader for context where to put the file), 
             or null if unsuccessful.  
             
             There is a tool called pdbstr associated with srcsrv that basically does this.  
                 pdbstr -r -s:srcsrv -p:PDBPATH
             will dump it. 
            
             The basic flow is 
             
             There is a variables section and a files section
             
             The file section is a list of items separated by *.   The first is the path, the rest are up to you
             
             You form a command by using the SRCSRVTRG variable and substituting variables %var1 where var1 is the first item in the * separated list
             There are special operators %fnfile%(XXX), etc that manipulate the string XXX (get file name, translate \ to / ...
             
             If what is at the end is a valid URL it is looked up.   
             </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.MicrosoftPdbSourceFile.GetSourceServerTargetAndCommand(System.String@,System.String@,System.String)">
            <summary>
            Parse the 'srcsrv' stream in a PDB file and return the target for SourceFile
            represented by the 'this' pointer.   This target is iether a ULR or a local file
            path.  
            
            You can dump the srcsrv stream using a tool called pdbstr 
                pdbstr -r -s:srcsrv -p:PDBPATH
            
            The target in this stream is called SRCSRVTRG and there is another variable SRCSRVCMD
            which represents the command to run to fetch the soruce into SRCSRVTRG
            
            To form the target, the stream expect you to private a %targ% variable which is a directory
            prefix to tell where to put the source file being fetched.   If the source file is
            available via a URL this variable is not needed.  
            
             ********* This is a typical example of what is in a PDB with source server information. 
             SRCSRV: ini ------------------------------------------------
             VERSION=3
             INDEXVERSION=2
             VERCTRL=Team Foundation Server
             DATETIME=Thu Mar 10 16:15:55 2016
             SRCSRV: variables ------------------------------------------
             TFS_EXTRACT_CMD=tf.exe view /version:%var4% /noprompt "$%var3%" /server:%fnvar%(%var2%) /output:%srcsrvtrg%
             TFS_EXTRACT_TARGET=%targ%\%var2%%fnbksl%(%var3%)\%var4%\%fnfile%(%var1%)
             VSTFDEVDIV_DEVDIV2=http://vstfdevdiv.redmond.corp.microsoft.com:8080/DevDiv2
             SRCSRVVERCTRL=tfs
             SRCSRVERRDESC=access
             SRCSRVERRVAR=var2
             SRCSRVTRG=%TFS_extract_target%
             SRCSRVCMD=%TFS_extract_cmd%
             SRCSRV: source files ---------------------------------            ------
             f:\dd\externalapis\legacy\vctools\vc12\inc\cvconst.h*VSTFDEVDIV_DEVDIV2*/DevDiv/Fx/Rel/NetFxRel3Stage/externalapis/legacy/vctools/vc12/inc/cvconst.h*1363200
             f:\dd\externalapis\legacy\vctools\vc12\inc\cvinfo.h*VSTFDEVDIV_DEVDIV2*/DevDiv/Fx/Rel/NetFxRel3Stage/externalapis/legacy/vctools/vc12/inc/cvinfo.h*1363200
             f:\dd\externalapis\legacy\vctools\vc12\inc\vc\ammintrin.h*VSTFDEVDIV_DEVDIV2*/DevDiv/Fx/Rel/NetFxRel3Stage/externalapis/legacy/vctools/vc12/inc/vc/ammintrin.h*1363200
             SRCSRV: end ------------------------------------------------
             
             ********* And here is a more modern one where the source code is available via a URL.  
             SRCSRV: ini ------------------------------------------------
             VERSION=2
             INDEXVERSION=2
             VERCTRL=http
             SRCSRV: variables ------------------------------------------
             SRCSRVTRG=https://nuget.smbsrc.net/src/%fnfile%(%var1%)/%var2%/%fnfile%(%var1%)
             SRCSRVCMD=
             SRCSRVVERCTRL=http
             SRCSRV: source files ---------------------------------------
             c:\Users\rafalkrynski\Documents\Visual Studio 2012\Projects\DavidSymbolSourceTest\DavidSymbolSourceTest\Demo.cs*SQPvxWBMtvANyCp8Pd3OjoZEUgpKvjDVIY1WbaiFPMw=
             SRCSRV: end ------------------------------------------------
             
            </summary>
            <param name="target">returns the target source file path</param>
            <param name="command">returns the command to fetch the target source file</param>
            <param name="localDirectoryToPlaceSourceFiles">Specify the value for %targ% variable. This is the
            directory where source files can be fetched to.  Typically the returned file is under this directory
            If the value is null, %targ% variable be emtpy.  This assumes that the resulting file is something
            that does not need to be copied to the machine (either a URL or a file that already exists)</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.MicrosoftPdbSourceFile.FindTfExe">
            <summary>
            Returns the location of the tf.exe executable or 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.GetSrcSrvStream">
            <summary>
            Gets the 'srcsvc' data stream from the PDB and return it in as a string.   Returns null if it is not present. 
            
            There is a tool called pdbstr associated with srcsrv that basically does this.  
                pdbstr -r -s:srcsrv -p:PDBPATH
            will dump it. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.GetMergedAssembliesMap">
            <summary>
            For Project N modules it returns the list of pre merged IL assemblies and the corresponding mapping.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.GetEmbeddedILImage">
            <summary>
            For ProjectN modules, gets the merged IL image embedded in the .PDB (only valid for single-file compilation)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.GetPseudoAssembly">
            <summary>
            For ProjectN modules, gets the pseudo-assembly embedded in the .PDB, if there is one.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.GetFuncMDTokenMap">
            <summary>
            For ProjectN modules, gets the binary blob that describes the mapping from RVAs to methods.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.GetTypeMDTokenMap">
            <summary>
            For ProjectN modules, gets the binary blob that describes the mapping from RVAs to types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.NativeSymbolModule.ThrowIfDisposed">
            <summary>
            This function checks if the SymbolModule is disposed before proceeding with the call.
            This is important because DIA doesn't provide any guarantees as to what will happen if 
            one attempts to call after the session is disposed, so this at least ensure that we
            fail cleanly in non-concurrent cases.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.NativeSymbolModule.HeapAllocationTypeInfo">
            <summary>
            This static class contains the GetTypeName method for retrieving the type name of 
            a heap allocation site. 
            
            See https://github.com/KirillOsenkov/Dia2Dump/blob/master/PrintSymbol.cpp for more details
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.Symbol">
            <summary>
            Represents a single symbol in a PDB file.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.Symbol.Name">
            <summary>
            The name for the symbol 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.Symbol.RVA">
            <summary>
            The relative virtual address (offset from the image base when loaded in memory) of the symbol
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.Symbol.Length">
            <summary>
            The length of the memory that the symbol represents.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.Symbol.Id">
            <summary>
            A small integer identifier tat is unique for that symbol in the DLL. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.Symbol.UndecoratedName">
            <summary>
            Decorated names are names that most closely resemble the source code (have overloading).  
            However when the linker does not directly support all the expressiveness of the
            source language names are encoded to represent this.   This return this encoded name. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.Symbol.InSameSection(Microsoft.Diagnostics.Symbols.Symbol,Microsoft.Diagnostics.Symbols.Symbol)">
            <summary>
            Returns true if the two symbols live in the same linker section (e.g. text,  data ...)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.Symbol.GetChildren">
            <summary>
            Returns the children of the symbol.  Will return null if there are no children.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.Symbol.GetChildren(Dia2Lib.SymTagEnum)">
            <summary>
            Returns the children of the symbol, with the given tag.  Will return null if there are no children.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.Symbol.CompareTo(Microsoft.Diagnostics.Symbols.Symbol)">
            <summary>
            Compares the symbol by their relative virtual address (RVA)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.Symbol.ToString">
            <summary>
            override
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.SymbolPath">
            <summary>
            SymPath is a class that knows how to parse _NT_SYMBOL_PATH syntax.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPath.SymbolPathFromEnvironment">
            <summary>
            This allows you to set the _NT_SYMBOL_PATH as a from the windows environment.    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.CleanSymbolPath">
            <summary>
            This 'cleans up' a symbol path.  In particular
            Empty ones are replaced with good defaults (symweb or msdl)
            All symbol server specs have local caches (%Temp%\SymbolCache if nothing else is specified).  
            
            Note that this routine does NOT update _NT_SYMBOL_PATH.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPath.MicrosoftSymbolServerPath">
            <summary>
            Returns the string representing a symbol path for the 'standard' Microsoft symbol servers.   
            This returns the public msdl.microsoft.com server if outside Microsoft.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.#ctor">
            <summary>
            Create an empty symbol path
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.#ctor(System.String)">
            <summary>
            Create a symbol that represents 'path' (the standard semicolon separated list of locations)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPath.Elements">
            <summary>
            Returns the List of elements in the symbol path. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.Add(System.String)">
            <summary>
            Append all the elements in the semicolon separated list, 'path', to the symbol path represented by 'this'. 
            returns the 'this' pointer
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.Add(Microsoft.Diagnostics.Symbols.SymbolPathElement)">
            <summary>
            append a new symbol path element to the beginning of the symbol path represented by 'this'.
            returns the 'this' pointer
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.Insert(System.String)">
            <summary>
            insert all the elements in the semicolon separated list, 'path' to the beginning of the symbol path represented by 'this'.
            returns the 'this' pointer
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.Insert(Microsoft.Diagnostics.Symbols.SymbolPathElement)">
            <summary>
            insert a new symbol path element to the beginning of the symbol path represented by 'this'.
            returns the 'this' pointer
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.DefaultSymbolCache(System.Boolean)">
            <summary>
            If you need to cache files locally, put them here.  It is defined
            to be the first local path of a SRV* qualification or %TEMP%\SymbolCache
            if not is present.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.InsureHasCache(System.String)">
            <summary>
            People can use symbol servers without a local cache.  This is bad, add one if necessary. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.LocalOnly">
            <summary>
            Removes all references to remote paths.  This insures that network issues don't cause grief.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.CacheFirst">
            <summary>
            Create a new symbol path which first search all machine local locations (either explicit location or symbol server cache locations)
            followed by all non-local symbol server.   This produces better behavior (If you can find it locally it will be fast)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.ToString">
            <summary>
            Returns the string representation (semicolon separated) for the symbol path.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.ToXml(System.IO.TextWriter,System.String)">
            <summary>
            Writes an XML representation of the symbol path to 'writer'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPath.ComputerNameExists(System.String,System.Int32)">
            <summary>
            Checks to see 'computerName' exists (there is a Domain Names Service (DNS) reply to it)
            This routine times out relative quickly (after 700 msec) if there is a problem reaching 
            the computer, and returns false.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Symbols.SymbolPath.s_MicrosoftSymbolServerPath">
            <summary>
            This is the backing field for the lazily-computed <see cref="P:Microsoft.Diagnostics.Symbols.SymbolPath.MicrosoftSymbolServerPath"/> property.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.SymbolPathElement">
            <summary>
            SymPathElement represents the text between the semicolons in a symbol path.  It can be a symbol server specification or a simple directory path. 
            
            SymPathElement follows functional conventions.  After construction everything is read-only. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPathElement.IsSymServer">
            <summary>
            Returns true if this element of the symbol server path a symbol server specification
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPathElement.Cache">
            <summary>
            Returns the local cache for a symbol server specification.  returns null if not specified
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPathElement.Target">
            <summary>
            Returns location to look for symbols.  This is either a directory specification or an URL (for symbol servers)
            This can be null if it is not specified (for cache-only paths).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolPathElement.IsRemote">
            <summary>
            IsRemote returns true if it looks like the target is not on the local machine.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPathElement.ToString">
            <summary>
            Returns the string repsentation for the symbol server path element (e.g. SRV*c:\temp*\\symbols\symbols)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPathElement.Equals(System.Object)">
            <summary>
            Implements object interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolPathElement.GetHashCode">
            <summary>
            Implements object interface
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.SymbolReader">
            <summary>
            A symbol reader represents something that can FIND pdbs (either on a symbol server or via a symbol path)
            Its job is to find a full path a PDB.  Then you can use OpenSymbolFile to get a SymbolReaderModule and do more. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.#ctor(System.IO.TextWriter,System.String)">
            <summary>
            Opens a new SymbolReader.   All diagnostics messages about symbol lookup go to 'log'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.FindSymbolFilePathForModule(System.String,System.Boolean)">
            <summary>
            Finds the symbol file for 'exeFilePath' that exists on the current machine (we open
            it to find the needed info).   Uses the SymbolReader.SymbolPath (including Symbol servers) to 
            look up the PDB, and will download the PDB to the local cache if necessary.   It will also
            generate NGEN pdbs into the local symbol cache unless SymbolReaderFlags.NoNGenPDB is set.   
            
            By default for NGEN images it returns the NGEN pdb.  However if 'ilPDB' is true it returns
            the IL PDB.  
            
            Returns null if the pdb can't be found.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.FindSymbolFilePath(System.String,System.Guid,System.Int32,System.String,System.String,System.Boolean)">
            <summary>
            Find the complete PDB path, given just the simple name (filename + pdb extension) as well as its 'signature', 
            which uniquely identifies it (on symbol servers).   Uses the SymbolReader.SymbolPath (including Symbol servers) to 
            look up the PDB, and will download the PDB to the local cache if necessary.  
            
            A Guid of Empty, means 'unknown' and will match the first PDB that matches simple name.  Thus it is unsafe. 
            
            Returns null if the PDB could  not be found
            </summary>
            <param name="pdbFileName">The name of the PDB file (we only use the file name part)</param>
            <param name="pdbIndexGuid">The GUID that is embedded in the DLL in the debug information that allows matching the DLL and the PDB</param>
            <param name="pdbIndexAge">Tools like BBT transform a DLL into another DLL (with the same GUID) the 'pdbAge' is a small integers
            that indicates how many transformations were done</param>
            <param name="dllFilePath">If you know the path to the DLL for this pdb add it here.  That way we can probe next to the DLL
            for the PDB file.</param>
            <param name="fileVersion">This is an optional string that identifies the file version (the 'Version' resource information.  
            It is used only to provided better error messages for the log.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.FindExecutableFilePath(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            This API looks up an executable file, by its build-timestamp and size (on a symbol server),  'fileName' should be 
            a simple name (no directory), and you need the buildTimeStamp and sizeOfImage that are found in the PE header.
            
            Returns null if it cannot find anything.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.OpenSymbolFile(System.String)">
            <summary>
            Given the path name to a particular PDB file, load it so that you can resolve symbols in it.  
            </summary>
            <param name="pdbFilePath">The name of the PDB file to open.</param>
            <returns>The SymbolReaderModule that represents the information in the symbol file (PDB)</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.OpenNativeSymbolFile(System.String)">
            <summary>
            Like OpenSymbolFile, which opens a PDB, but this version will fail (return null)
            if it is not WindowsSymbolModule.  It is a shortcut for OpenSymbolFile as NativeSymbolModule
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.SymbolPath">
            <summary>
            The symbol path used to look up PDB symbol files.   Set when the reader is initialized.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.SourcePath">
            <summary>
            The paths used to look up source files.  defaults to _NT_SOURCE_PATH.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.SymbolCacheDirectory">
            <summary>
            Where symbols are downloaded if needed.   Derived from symbol path.  It is the first
            directory on the local machine in a SRV*DIR*LOC spec, and %TEMP%\SymbolCache otherwise.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.AuthorizationHeaderForSourceLink">
            <summary>
            Authorization header to be ued when making requests to source server (only for SourceLink)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.SourceCacheDirectory">
            <summary>
            The place where source is downloaded from a source server.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.Options">
            <summary>
            Is this symbol reader limited to just the local machine cache or not?
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.SecurityCheck">
            <summary>
            We call back on this when we find a PDB by probing in 'unsafe' locations (like next to the EXE or in the Built location)
            If this function returns true, we assume that it is OK to use the PDB.  
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Symbols.SymbolReader.OnSymbolFileFound">
            <summary>
            If set OnSymbolFileFound will be called when a PDB file is found.  
            It is passed the complete local file path, the PDB Guid (may be Guid.Empty) and PDB age.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SymbolReader.Log">
            <summary>
            A place to log additional messages 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.GenerateNGenSymbolsForModule(System.String,System.String)">
            <summary>
            Given a full filename path to an NGEN image, insure that there is an NGEN image for it
            in the symbol cache.  If one already exists, this method simply returns that.   If not
            it is generated and placed in the symbol cache.  When generating the PDB this routine
            attempt to resolve line numbers, which DOES require looking up the PDB for the IL image. 
            Thus routine may do network accesses (to download IL PDBs).  
            
            Note that FindSymbolFilePathForModule calls this, so normally you don't need to call 
            this method directly.  
            
            By default it places the PDB in the SymbolCacheDirectory using normal symbol server 
            cache conventions (PDBNAME\Guid-AGE\Name).   You can override this by specifying
            the outputDirectory parameter.  
            
            <returns>The full path name of the PDB generated for the NGEN image.</returns>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.HandleNetCorePdbs(System.String,System.String)">
            <summary>
            Given a NGEN (or ReadyToRun) imge 'ngenImageFullPath' and the PDB path
            that we WANT it to generate generate the PDB.  Returns either pdbPath 
            on success or null on failure.  
            
            TODO can be removed when we properly publish the NGEN pdbs as part of build.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.Dispose">
            <summary>
             Called when you are done with the symbol reader.
             Closes all opened symbol files.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.PdbMatches(System.String,System.Guid,System.Int32,System.Boolean)">
            <summary>
            Returns true if 'filePath' exists and is a PDB that has pdbGuid and pdbAge.  
            if pdbGuid == Guid.Empty, then the pdbGuid and pdbAge checks are skipped. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.GetPhysicalFileFromServer(System.String,System.String,System.String,System.Predicate{System.String})">
            <summary>
            Fetches a file from the server 'serverPath' with pdb signature path 'pdbSigPath' (concatinate them with a / or \ separator
            to form a complete URL or path name).   It will place the file in 'fullDestPath'   It will return true if successful
            If 'contentTypeFilter is present, this predicate is called with the URL content type (e.g. application/octet-stream)
            and if it returns false, it fails.   This insures that things that are the wrong content type (e.g. redirects to 
            some sort of login) fail cleanly.  
            
            You should probably be using GetFileFromServer
            </summary>
            <param name="serverPath">path to server (e.g. \\symbols\symbols or http://symweb) </param>
            <param name="pdbIndexPath">pdb path with signature (e.g clr.pdb/1E18F3E494DC464B943EA90F23E256432/clr.pdb)</param>
            <param name="fullDestPath">the full path of where to put the file locally </param>
            <param name="contentTypeFilter">if present this allows you to filter out urls that dont match this ContentType.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.BuildFullUri(System.String,System.String)">
            <summary>
            Build the full uri from server path and pdb index path
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.CopyStreamToFile(System.IO.Stream,System.String,System.String,System.Boolean@)">
            <summary>
            This just copies a stream to a file path with logging.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.GetFileFromServer(System.String,System.String,System.String)">
            <summary>
            Looks up 'fileIndexPath' on the server 'urlForServer' (concatenate to form complete URL) copying the file to 
            'targetPath' and returning targetPath name there (thus it is always a local file).  Unlike  GetPhysicalFileFromServer, 
            GetFileFromServer understands how to deal with compressed files and file.ptr (redirection).  
            </summary>
            <returns>targetPath or null if the file cannot be found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.GetClrDirectoryForNGenImage(System.String,System.IO.TextWriter,System.String@)">
            <summary>
            Deduce the path to where CLR.dll (and in particular NGEN.exe live for the NGEN image 'ngenImagepath')
            Returns null if it can't be found.  If the NGEN image is associated with a private runtime return 
            that value in 'privateVerStr'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SymbolReader.BypassSystem32FileRedirection(System.String)">
            <summary>
            We may be a 32 bit app which has File system redirection turned on
            Morph System32 to SysNative in that case to bypass file system redirection         
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.ManagedSymbolModule">
            <summary>
            A SymbolModule represents a file that contains symbolic information 
            (a Windows PDB or Portable PDB).  This is the interface that is independent 
            of what kind of symbolic file format you use.  Becase portable PDBs only
            support managed code, this shared interface is by necessity the interface
            for managed code only (currently only Windows PDBs support native code).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.ManagedSymbolModule.ExePath">
            <summary>
            This is the EXE associated with the Pdb.  It may be null or an invalid path.  It is used
            to help look up source code (it is implicitly part of the Source Path search) 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.ManagedSymbolModule.SymbolFilePath">
            <summary>
            The path name to the PDB itself.  Might be empty if the symbol information is in memory.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.ManagedSymbolModule.PdbGuid">
            <summary>
            The Guid that is used to uniquely identify the DLL-PDB pair (used for symbol servers)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.ManagedSymbolModule.SymbolReader">
            <summary>
             Fetches the SymbolReader associated with this SymbolModule.  This is where shared
             attributes (like SourcePath, SymbolPath etc) are found.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.ManagedSymbolModule.SourceLocationForManagedCode(System.UInt32,System.Int32)">
            <summary>
            Given a method and an IL offset, return a source location (line number and file).   
            Returns null if it could not find it.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.ManagedSymbolModule.GetSourceLinkJson">
            <summary>
            If the symbol file format supports SourceLink JSON this routine should be overriden
            to return it.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.ManagedSymbolModule.GetUrlForFilePathUsingSourceLink(System.String,System.String@,System.String@)">
            <summary>
            Return a URL for 'buildTimeFilePath' using the source link mapping (that 'GetSourceLinkJson' fetched)
            Returns null if there is URL using the SourceLink 
            </summary>
            <param name="buildTimeFilePath">The path to the source file at build time</param>
            <param name="url">The source link URL</param>
            <param name="relativeFilePath"></param>
            <returns>true if a source link file could be found</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.ManagedSymbolModule.ParseSourceLinkJson(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Parses SourceLink information and returns a list of filepath -> url Prefix tuples.  
            </summary>  
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.SourceLocation">
            <summary>
            A SourceLocation represents a point in the source code.  That is the file and the line number.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SourceLocation.SourceFile">
            <summary>
            The source file for the code
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SourceLocation.LineNumber">
            <summary>
            The line number for the code.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Symbols.SymbolReaderOptions">
            <summary>
            SymbolReaderFlags indicates preferences on how aggressively symbols should be looked up.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Symbols.SymbolReaderOptions.None">
            <summary>
            No options this is the common case, where you want to look up everything you can. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Symbols.SymbolReaderOptions.CacheOnly">
            <summary>
            Only fetch the PDB if it lives in the symbolCacheDirectory (is local an is generated).  
            This will generate NGEN pdbs unless the NoNGenPDBs flag is set. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Symbols.SymbolReaderOptions.NoNGenSymbolCreation">
            <summary>
            No NGEN PDB generation.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SourceFile.BuildTimeFilePath">
            <summary>
            The path of the file at the time the source file was built.   We also look here when looking for the source.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SourceFile.Url">
            <summary>
            If the source file is directly available on the web (that is there is a Url that 
            can be used to fetch it with HTTP Get), then return that Url.   If no such publishing 
            point exists this property will return null.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SourceFile.GetSourceFile(System.Boolean)">
            <summary>
            This may fetch things from the source server, and thus can be very slow, which is why it is not a property. 
            returns a path to the file on the local machine (often in some machine local cache). 
            If requireChecksumMatch == false then you can see if you have an exact match by calling ChecksumMatches
            (and if there is a checksum with HasChecksum). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SourceFile.HasChecksum">
            <summary>
            true if the PDB has a checksum for the data in the source file. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SourceFile.ChecksumAlgorithm">
            <summary>
            Gets the name of the algorithm used to compute the source file hash. Values should be from System.Security.Cryptography.HashAlgorithmName.
            This is null if there is no checksum.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SourceFile.ChecksumValue">
            <summary>
            Gets the bytes of the source files checksum. This is null if there is no checksum.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Symbols.SourceFile.ChecksumMatches">
            <summary>
            If GetSourceFile is called and 'requireChecksumMatch' == false then you can call this property to 
            determine if the checksum actually matched or not.   This will return true if the original
            PDB does not have a checksum (HasChecksum == false)
            </summary>; 
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SourceFile.GetSourceLinkInfo(System.String@,System.String@)">
            <summary>
            Obtains information used to download the source file file source link
            </summary>
            <param name="url">The URL to hit to download the source file</param>
            <param name="relativePath">relative file path for the Source Link entry. For example, if the SourceLink map contains 'C:\foo\*' and this maps to 
            'C:\foo\bar\baz.cs', the relativeFilePath is 'bar\baz.cs'. For absolute SourceLink mappings, relativeFilePath will simply be the name of the file.</param>
            <returns>true if SourceLink info can be found for this file</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SourceFile.GetSourceFromSrcServer">
            <summary>
            Look up the source from the source server.  Returns null if it can't find the source
            By default this simply uses the Url to look it up on the web.   If 'Url' returns null
            so does this.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SourceFile.ProbeForBestMatch(System.String)">
            <summary>
            Given 'fileName' which is a path to a file (which may  not exist), set 
            _filePath and _checksumMatches appropriately.    Namely _filePath should
            always be the 'best' candidate for the source file path (matching checksum
            wins, otherwise first existing file wins).  
            
            Returns true if we have a perfect match (no additional probing needed).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Symbols.SourceFile.ComputeChecksumMatch(System.String)">
            <summary>
            Returns true if 'filePath' matches the checksum OR we don't have a checkdum
            (thus if we pass what validity check we have).    
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.WindowsDeviceToVolumeMap.ConvertDevicePathToVolumePath(System.String)">
            <summary>
            Convert an input file path from a device path to a volume-based path.
            Example input: c:\device\harddiskvolume7\sdk\shared\microsoft.netcore.app\3.1.7\coreclr.dll
            Example output: \\?\Volume{a296af82-8d67-4f46-a792-9e78ec0adf9b}\sdk\shared\microsoft.netcore.app\3.1.7\coreclr.dll
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.WindowsDeviceToVolumeMap.DisableLegacyPathHandling">
            <summary>
            Disable the AppContextSwitch "UseLegacyPathHandling", as legacy path handling doesn't support usage of volume-based paths.
            This is done via reflection because PerfView and TraceEvent target .NET 4.5 which doesn't have access to AppContext.  If this is
            run on a .NET 4.5 runtime, it will silently fail, but it's unlikely that anyone that needs this functionality for container support
            is going to be running .NET 4.5.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.DirectoryUtilities">
            <summary>
            General purpose utilities dealing with archiveFile system directories. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.Copy(System.String,System.String)">
            <summary>
            SafeCopy sourceDirectory to directoryToVersion recursively. The target directory does
            no need to exist
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.Copy(System.String,System.String,System.IO.SearchOption)">
            <summary>
            SafeCopy all files from sourceDirectory to directoryToVersion.  If searchOptions == AllDirectories
            then the copy is recursive, otherwise it is just one level.  The target directory does not
            need to exist. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.Clean(System.String)">
            <summary>
            Clean is sort of a 'safe' recursive delete of a directory.  It either deletes the
            files or moves them to '*.deleting' names.  It deletes directories that are completely
            empty.  Thus it will do a recursive delete when that is possible.  There will only 
            be *.deleting files after this returns.  It returns the number of files and directories
            that could not be deleted.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.DeleteOldest(System.String,System.Int32)">
            <summary>
            Removes the oldest directories directly under 'directoryPath' so that 
            only 'numberToKeep' are left. 
            </summary>
            <param variable="directoryPath">Directory to removed old files from.</param>
            <param variable="numberToKeep">The number of files to keep.</param>
            <returns> true if there were no errors deleting files</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.GetFiles(System.String,System.String,System.IO.SearchOption)">
             <summary>
             DirectoryUtilities.GetFiles is basically the same as Directory.GetFiles 
             however it returns IEnumerator, which means that it lazy.  This is very important 
             for large directory trees.  A searchPattern can be specified (Windows wildcard conventions)
             that can be used to filter the set of archiveFile names returned. 
             
             Suggested Usage
             
                 foreach(string fileName in DirectoryUtilities.GetFiles("c:\", "*.txt")){
                     Console.WriteLine(fileName);
                 }
            
             </summary>
             <param variable="directoryPath">The base directory to enumerate</param>
             <param variable="searchPattern">A pattern to filter the names (windows filename wildcards * ?)</param>
             <param variable="searchOptions">Indicate if the search is recursive or not.  </param>
             <returns>The enumerator for all archiveFile names in the directory (recursively). </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.GetFiles(System.String,System.String)">
            <summary>
            Returns a lazy enumerable for every path in 'directoryName' that matchs 'searchPattern' (default is *)MO
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.FileUtilities">
            <summary>
            General purpose utilities dealing with archiveFile system files. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ReadAllLines(System.String)">
            <summary>
            GetLines works much like File.ReadAllLines, however instead of returning a
            array of lines, it returns a IEnumerable so that the archiveFile is not read all
            at once.  This allows 'foreach' syntax to be used on very large files.  
            
            Suggested Usage
            
                foreach(string lineNumber in FileUtilities.GetLines("largeFile.txt")){
                    Console.WriteLine(lineNumber);
                }
            </summary>
            <param variable="fileName">The base directory to enumerate.</param>
            <returns>The enumerator for all lines in the archiveFile.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ExpandWildcards(System.String[],System.IO.SearchOption)">
            <summary>
            Given archiveFile specifications possibly with wildcards in them
            Returns an enumerator that returns each expanded archiveFile name in turn. 
            
            If searchOpt is AllDirectories it does a recursive match. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ForceDelete(System.String)">
            <summary>
            Delete works much like File.Delete, except that it will succeed if the
            archiveFile does not exist, and will rename the archiveFile so that even if the archiveFile 
            is locked the original archiveFile variable will be made available.  
            
            It renames the  archiveFile with a '[num].deleting'.  These files might be left 
            behind.  
            
            It returns true if it was completely successful.  If there is a *.deleting
            archiveFile left behind, it returns false. 
            </summary>
            <param variable="fileName">The variable of the archiveFile to delete</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.TryDelete(System.String)">
            <summary>
            Try to delete 'fileName' catching any exception.  Returns true if successful.   It will delete read-only files.  
            </summary>  
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ForceCopy(System.String,System.String)">
            <summary>
            SafeCopy sourceFile to destinationFile.  If the destination exists
            used ForceDelete to get rid of it first.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ForceMove(System.String,System.String)">
            <summary>
            Moves sourceFile to destinationFile.  If the destination exists
            used ForceDelete to get rid of it first.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.Equals(System.String,System.String)">
            <summary>
            Returns true if the two file have exactly the same content (as a stream of bytes). 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.PathUtil">
            <summary>
            Utilities associated with file name paths. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.PathUtil.PathRelativeTo(System.String,System.String)">
            <summary>
            Given a path and a superdirectory path relativeToDirectory compute the relative path (the path from) relativeToDirectory
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.StreamUtilities">
            <summary>
            General utilities associated with streams. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.StreamUtilities.CopyFromFile(System.String,System.IO.Stream)">
            <summary>
            Open the 'fromFilePath' and write its contents to 'toStream'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.StreamUtilities.CopyToFile(System.IO.Stream,System.String)">
            <summary>
            Open the 'toFilePath' for writing and write the contents of 'fromStream' to it
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.StreamUtilities.CopyStream(System.IO.Stream,System.IO.Stream)">
            <summary>
            CopyStream simply copies 'fromStream' to 'toStream'
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.XmlUtilities">
            <summary>
            The important thing about these general utilities is that they have only dependencies on mscorlib and
            System (they can be used from anywhere).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.OpenXmlElement(System.String)">
            <summary>
            Given an XML element, remove the closing operator for it, so you can add new child elements to it by concatination. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlEscape(System.Object,System.Boolean)">
            <summary>
            Given an object 'obj' do ToString() on it, and then transform it so that all speical XML characters are escaped and return the result. 
            If 'quote' is true also surround the resulting object with double quotes.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuote(System.Object)">
            <summary>
            A shortcut for XmlEscape(obj, true) (that is ToString the object, escape XML chars, and then surround with double quotes. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuote(System.Int32)">
            <summary>
            Create a doubly quoted string for the decimal integer value
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuoteHex(System.UInt32)">
            <summary>
            Create a double quoted string for the hexidecimal value of 'value'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuoteHex(System.UInt64)">
            <summary>
            Create a double quoted string for the hexidecimal value of 'value'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuoteHex(System.Int32)">
            <summary>
            Create a double quoted string for the hexidecimal value of 'value'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuoteHex(System.Int64)">
            <summary>
            Create a double quoted string for the hexidecimal value of 'value'
            </summary>
        </member>
        <member name="T:System.Diagnostics.Tracing.ManifestEnvelope">
            <summary>
            Used to send the rawManifest into the event stream as a series of events.  
            </summary>
        </member>
        <member name="T:NativeDlls">
            <summary>
            Finds native DLLS next to the managed DLL that uses them.   
            </summary>
        </member>
        <member name="F:NativeDlls.UnknownLocation">
            <summary>
            ManifestModule.FullyQualifiedName returns this as file path if the assembly is loaded as byte array
            </summary>
        </member>
        <member name="M:NativeDlls.LoadNative(System.String)">
            <summary>
            Loads a native DLL with a filename-extension of 'simpleName' by adding the path of the currently executing assembly
            
            </summary>
            <param name="simpleName"></param>
        </member>
        <member name="P:NativeDlls.ProcessArchitectureDirectory">
            <summary>
            Gets the name of the directory containing compiled binaries (DLLs) which have the same architecture as the
            currently executing process.
            </summary>
        </member>
        <member name="F:NativeDlls.s_ProcessArchDirectory">
            <summary>
            This is the backing field for the lazily-computed <see cref="P:NativeDlls.ProcessArchitectureDirectory"/> property.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.AggregateStackSource">
            <summary>
            A StackSource that aggregates information from other StackSources into a single unified view.
            </summary>
            <remarks>
            Each StackSource has a name associated with it. The stacks for each StackSource will be grouped under
            a pseudo-frame named the same as the source name. Source names are specified on initialization.
            </remarks>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,Microsoft.Diagnostics.Tracing.Stacks.StackSource}})">
            <summary>
            Initialize a new AggregateStackSource.
            </summary>
            <param name="sources">An IEnumerable of KeyValuePairs mapping source names to StackSources.</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Enumerate samples with a callback function.
            </summary>
            <param name="callback">The function to call on each sample.</param>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.SamplesImmutable">
            <summary>
            override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample},System.Boolean[])">
            <summary>
            Enumerate samples for a given set of scenarios with a callback function.
            </summary>
            <param name="callback">The function to call on each sample.</param>
            <param name="scenariosIncluded">An array of length ScenarioCount. If scenariosIncluded[i] == true, include scenario i.</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.ParallelForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample},System.Boolean[],System.Int32)">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.GetSampleByIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex)">
            <summary>
            Look up a sample by index.
            </summary>
            <param name="sampleIndex">The index of the sample to look up.</param>
            <returns>
            The sample, if it can be found and all sub-sources support indexing; null otherwise.
            </returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Gets the index of the caller of a given call stack.
            </summary>
            <param name="callStackIndex">The call stack to look up.</param>
            <returns>The caller, if it exists, <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex.Invalid"/> otherwise.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Get the frame index of a given call stack.
            </summary>
            <param name="callStackIndex">The call stack to look up.</param>
            <returns>The frame index of the call stack, if it exists, <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Invalid"/> otherwise.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Gets the name of a frame.
            </summary>
            <param name="frameIndex">The frame to look up.</param>
            <param name="verboseName">Whether to include full module paths.</param>
            <returns>The name of the frame.</returns>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.CallStackIndexLimit">
            <summary>
            The total number of call stacks in this source.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.CallFrameIndexLimit">
            <summary>
            The total number of frames in this source.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.SampleIndexLimit">
            <summary>
            The total number of samples in this source.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.ScenarioNames">
            <summary>
            The names for the scenarios.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.SampleTimeRelativeMSecLimit">
            <summary>
            override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.ScenarioCount">
            <summary>
            override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.ConvertSample(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample,Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample,System.Int32)">
            <summary>
            Convert a StackSourceSample produced by a sub-source into one suitable for the aggregate source.
            </summary>
            <param name="input">The StackSourceSample to convert.</param>
            <param name="storage">A place to but the returned sampled (will become the return value).</param>
            <param name="sourceIdx">The index of the source from which the sample came.</param>
            <returns>The converted sample.</returns>
            <remarks>
            If ConvertSample is called again, all previous samples produced by ConvertSample may no longer be used.
            </remarks>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.AggregateStackSource.m_sourceNames">
            <summary>
            Friendly names of sources.
            </summary>
            <remarks>
            Name 0 is the name of the pseudo-source, which should not be used.
            </remarks>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.AggregateStackSource.m_sources">
            <summary>
            The list of sources.
            </summary>
            <remarks>
            Source 0 is the pseudo-source (identical to m_pseudo).
            </remarks>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.AggregateStackSource.m_firstSampleTime">
            <summary>
            THis is the time of the first sample.  It lets us normalize the time in the sample to be relative to this.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource">
            <summary>
            A StackSource to generate the pseudo-frames needed to group scenarios.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.#ctor(System.String[])">
            <summary>
            Initialize a new PseudoStackSource.
            </summary>
            <param name="names">The names of the frames.</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.GetStackForSource(System.Int32)">
            <summary>
            Gets the CallStackIndex of the call stack corresponding to a given source.
            </summary>
            <param name="sourceIdx">The index of the source to look up.</param>
            <returns>The StackSourceCallStackIndex of a stack under which to group all call stacks for that source.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Gets the index of the caller of a given call stack.
            </summary>
            <param name="callStackIndex">The call stack to look up.</param>
            <returns>The caller, if it exists, <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex.Invalid"/> otherwise.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Get the frame index of a given call stack.
            </summary>
            <param name="callStackIndex">The call stack to look up.</param>
            <returns>The frame index of the call stack, if it exists, <see cref="F:Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex.Invalid"/> otherwise.</returns>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Gets the name of a frame.
            </summary>
            <param name="frameIndex">The frame to look up.</param>
            <param name="verboseName">Whether to include full module paths.</param>
            <returns>The name of the frame.</returns>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.CallStackIndexLimit">
            <summary>
            The total number of call stacks in this source.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.CallFrameIndexLimit">
            <summary>
            The total number of frames in this source.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.AggregateStackSource.PseudoStackSource.names">
            <summary>
            The names of the frames that this source generates.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.IndexMapExtensions">
            <summary>
            Extension methods for type-safe IndexMap operations on StackSource*Index enums.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.FilterParams">
            <summary>
            This is just a class that holds data.  It does nothing except support an 'update' events 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.#ctor">
            <summary>
            Constructs a Filter parameter class with all empty properties. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.#ctor(Diagnostics.Tracing.StackSources.FilterParams)">
            <summary>
            Create a Filter Parameters Structure form another one
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.Set(Diagnostics.Tracing.StackSources.FilterParams)">
            <summary>
            Set a Filter Parameters Structure form another one
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.Name">
            <summary>
            Fetch Name 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.StartTimeRelativeMSec">
            <summary>
            Fetch StartTimeRelativeMSec 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.EndTimeRelativeMSec">
            <summary>
            Fetch EndTimeRelativeMSec 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.MinInclusiveTimePercent">
            <summary>
            Fetch MinInclusiveTimePercent 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.FoldRegExs">
            <summary>
            Fetch FoldRegExs 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.IncludeRegExs">
            <summary>
            Fetch IncludeRegExs 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.ExcludeRegExs">
            <summary>
            Fetch ExcludeRegExs 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.GroupRegExs">
            <summary>
            Fetch GroupRegExs 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.TypePriority">
            <summary>
            Fetch TypePriority 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.ScenarioList">
            <summary>
            Fetch ScenarioList 
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterParams.Scenarios">
            <summary>
            Fetch Scenarios 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.Equals(System.Object)">
            <summary>
             override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.GetHashCode">
            <summary>
             override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.EscapeRegEx(System.String)">
            <summary>
            TODO Document
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.WriteToXml(System.Xml.XmlWriter)">
            <summary>
            Write out the FilterParameters to XML 'writer'
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterParams.ToXml">
            <summary>
            Create an XML representation of FilterParams as a string
            </summary>
            <returns></returns>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.FilterStackSource">
            <summary>
            A FilterStackSouce morphs one stack filters or groups the stacks of one stack source to form a new
            stack source.   It is very powerful mechanism.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.#ctor(Diagnostics.Tracing.StackSources.FilterParams,Microsoft.Diagnostics.Tracing.Stacks.StackSource,Microsoft.Diagnostics.Tracing.Stacks.ScalingPolicyKind)">
            <summary>
            Create a new FilterStackSource.   
            </summary>
            <param name="filterParams">Specifies how to filter or group the stacks</param>
            <param name="stackSource">The input source to morph</param>
            <param name="scalingPolicy">How to scale the data (as time or simply by size of data)</param>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.ForEach(System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetCallerIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetNumberOfFoldedFrames(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetFrameIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetFrameName(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex,System.Boolean)">
            <summary>
            Override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.SampleTimeRelativeMSecLimit">
            <summary>
            Override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.ScenarioCount">
            <summary>
            Override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.CallStackIndexLimit">
            <summary>
            Override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.CallFrameIndexLimit">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetSampleByIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex)">
            <summary>
            Override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.BaseStackSource">
            <summary>
            Override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.IsGraphSource">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetReferences(Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex,Microsoft.Diagnostics.Tracing.Stacks.RefDirection,System.Action{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSampleIndex})">
            <summary>
            Override
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.FilterStackSource.SampleIndexLimit">
            <summary>
            Override
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetStackInfo(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.RecursionGuard)">
            <summary>
            Associated with every frame is a FrameInfo which is the computed answers associated with that frame name.  
            We cache these and so most of the time looking up frame information is just an array lookup.  
            
            FrameInfo contains information that is ONLY dependent on the frame name (not the stack it came from), so
            entry point groups and include patterns can not be completely processed at this point.   Never returns null. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GenerateStackInfo(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Diagnostics.Tracing.StackSources.FilterStackSource.StackInfo,Microsoft.Diagnostics.Tracing.Stacks.RecursionGuard)">
            <summary>
            Generate the stack information for 'stack' and place it in stackInfoRet.  Only called by GetStackInfo.    
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.GetFrameInfo(Microsoft.Diagnostics.Tracing.Stacks.StackSourceFrameIndex)">
            <summary>
            Returns the frame information for frameIndex.   Never returns null.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.FilterStackSource.GroupPattern">
            <summary>
            This is just the parsed form of a grouping specification Pat->GroupNameTemplate  (it has a pattern regular 
            expression and a group name that can have replacements)  It is a trivial class
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.GroupPattern.IsModuleEntry">
            <summary>
            Experimentally we are going to special case the module entry pattern.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.ParseGroups(System.String)">
            <summary>
            Parses a string into the GroupPattern structure that allows it to executed (matched).  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.FindGroupNameFromFrameName(System.String,System.Boolean@)">
            <summary>
            Given the name of a frame, look it up in the group patterns and morph it to its group name. 
            If the group that matches is a entryGroup then set 'isEntryGroup'.  Will return null if
            no group matches 'frameName'
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.ParseRegExList(System.String)">
            <summary>
            Holds parsed information about patterns for groups includes, excludes or folds.  
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.IsMatch(System.Text.RegularExpressions.Regex[],System.String)">
            <summary>
            Returns the index in the 'pats' array of the first pattern that matches 'str'.   Returns -1 if no match. 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.SameSet(System.Int32[],System.Int32[])">
            <summary>
            returns true if set1 and set1 (as returned from MatchSet) are identical 
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.FilterStackSource.ToDotNetRegEx(System.String)">
            <summary>
            Convert a string from my regular expression format (where you only have * and {  } as grouping operators
            and convert them to .NET regular expressions string
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.FilterStackSource.FrameInfo">
            <summary>
            FrameInfo is all the information we need to associate with an Frame ID (to figure out what group/pattern it belongs to) 
            This includes what group it belongs to, the include patterns it matches whether to discard or fold it.   It is
            all the processing we can do with JUST the frame ID.  
            
            Note that FrameInfo is reused by multiple stacks, which means that you should NOT update fields in it after initial creation.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.FrameInfo.GroupID">
            <summary>
            This is what we return to the Stack crawler, it encodes either that we should filter the sample,
            fold the frame, form a group, or the frameID that we have chosen to represent the group as a whole.  
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.FilterStackSource.StackInfo">
            <summary>
            Represents all accumulated information about grouping for a particular stack.  Effectively this is the
            'result' of applying the grouping and filtering to a particular stack.   We cache the last 100 or so
            of these because stacks tend to reuse the parts of the stack close the root.     
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.StackInfo.IncPathsMatchedSoFar">
            <summary>
            The include patterns that have been matched by some frame in this stack.  (ultimately we need all bits set).
            Can be null, which means the empty set.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.MatchesNothing">
            <summary>
            Represents a frame that does not match any pattern.  Thus the default of simply returning the frame ID is appropriate
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.Discard">
            <summary>
            Represents a frame that should be discarded.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.Fold">
            <summary>
            Represents a frame that should be folded into its caller.  
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FilterStackSource.StackInfoCacheSize">
            <summary>
            We cache information about stacks we have previously seen so we can short-circuit work. 
            TODO make dynamic.   
            
            Note when this value is 4096 some memory profiles are VERY sluggish.  Don't make it too
            small unless it is adaptive.  
            </summary>
        </member>
        <member name="T:Utilities.IndexMap">
            <summary>
            A class that maps contiguous indices from various sources from and to a single range of contiguous indices.
            </summary>
            <remarks>
            This is useful for aggregating indices used, for instance, in the interface for StackSource (StackSourceCallStackIndex /
            StackSourceFrameIndex) in AggregateStackSource. This is an easy way, given the incoming StackSource*Index, to find the
            aggregated source to query, and the corresponding StackSource*Index to send to the source.
            </remarks>
            <example>
            With counts [3, 7, 5]:
                                1 1 1 1 1  
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4  = Incoming index
            __0__ ______1______ ____2____  = Source number
            0 1 2|0 1 2 3 4 5 6|0 1 2 3 4  = Offset
            </example>
        </member>
        <member name="M:Utilities.IndexMap.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Initialize a new IndexMap with the specified counts.
            </summary>
            <param name="counts">A list mapping an index to its corresponding count.</param>
        </member>
        <member name="M:Utilities.IndexMap.SourceOf(System.Int32)">
            <summary>
            Find the source for an index.
            </summary>
            <param name="aggregate">The aggregate index to look up.</param>
            <returns>The source that <paramref name="aggregate"/> belongs to.</returns>
        </member>
        <member name="M:Utilities.IndexMap.OffsetOf(System.Int32,System.Int32)">
            <summary>
            Find the offset into a given source of a given aggregate index.
            </summary>
            <param name="aggregate">The aggregate index to look up.</param>
            <param name="source">The source to find the offset into.</param>
            <returns>The offset of <paramref name="aggregate"/> into <paramref name="source"/>.</returns>
        </member>
        <member name="M:Utilities.IndexMap.IndexOf(System.Int32,System.Int32)">
            <summary>
            Finds the index for a given source/offset pair.
            </summary>
            <param name="source">The source number of the item.</param>
            <param name="offset">The offset into the corresponding source for the item.</param>
            <returns>The index corresponding to the pair of <paramref name="source"/> and <paramref name="offset"/>.</returns>
        </member>
        <member name="P:Utilities.IndexMap.Count">
            <summary>
            The total number of indices in the map.
            </summary>
        </member>
        <member name="F:Utilities.IndexMap.m_lookup">
            <summary>
            The lookup table to convert indices to source/offset pairs.
            </summary>
            <remarks>
            This contains the cumulative count of indices that occurred before each source.
            The last element is the total number of indices (equal to m_range).
            </remarks>
        </member>
        <member name="F:Utilities.IndexMap.m_range">
            <summary>
            The total number of indices in the map.
            </summary>
        </member>
        <member name="F:Utilities.IndexMap.m_lastSourceLookedUp">
            <summary>
            We remember the last source we looked up and check there first very likely they are next to one another. 
            </summary>
        </member>
        <member name="T:Utilities.Cache`2">
            <summary>
            A finite cache based with a least recently used algorithm for replacement.   
            It is meant to be fast (fast as a hashtable), and space efficient (not much
            over the MaxEntry key-value pairs are stored.  (only 8 bytes per entry additional).  
            
            After reaching MaxEntry entries.  It uses a roughly least-recently used
            algorithm to pick a entry to recycle.    To stay efficient it only searches
            a finite time (up to 5 entries) for a entry that is older than 1/2 of the
            entries in the table.  
            
            It has the property that if you are in the maxEntries/2 most commonly fetched
            things, you very unlikely to be evicted once you are in the cache.   
            </summary>
        </member>
        <member name="M:Utilities.Cache`2.#ctor(System.Int32)">
            <summary>
            maxEntries currently is only set in the constructor.   Thus this is a finite sized cache
            but is otherwise very efficient.  Currently it uses ushorts internally so the number
            of entries is limited to 64K (it silently limits it if you give maxEntries > 64K).  
            </summary>
            <param name="maxEntries"></param>
        </member>
        <member name="M:Utilities.Cache`2.Get(`0)">
            <summary>
            Fetches the value from the cache with key 'key'.  Returns default(T) if not present
            </summary>
        </member>
        <member name="M:Utilities.Cache`2.TryGet(`0,`1@)">
            <summary>
            Fetches the value from the cache with key 'key'.  Returns false if not present.
            </summary>
        </member>
        <member name="M:Utilities.Cache`2.Add(`0,`1)">
            <summary>
            Adds 'key' with value 'value' to the cache. 
            </summary>
        </member>
        <member name="M:Utilities.Cache`2.Clear">
            <summary>
            Removes all entries in the cache.  
            </summary>
        </member>
        <member name="P:Utilities.Cache`2.MaxEntries">
            <summary>
            Sets the maxiumum number of key-value pairs the cache will keep.  (after that old ones are remvoed). 
            </summary>
        </member>
        <member name="F:Utilities.Cache`2.End">
            <summary>
            Represents a null pointer (end of a linked list)
            </summary>
        </member>
        <member name="T:Utilities.CommandOptions">
            <summary>
            CommandOptions is a helper class for the Command class.  It stores options
            that affect the behavior of the execution of ETWCommands and is passes as a 
            parameter to the constructor of a Command.  
            
            It is useful for these options be be on a separate class (rather than 
            on Command itself), because it is reasonably common to want to have a set
            of options passed to several commands, which is not easily possible otherwise. 
            </summary>
        </member>
        <member name="F:Utilities.CommandOptions.Infinite">
            <summary>
            Can be assigned to the Timeout Property to indicate infinite timeout. 
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.#ctor">
            <summary>
            CommanOptions holds a set of options that can be passed to the constructor
            to the Command Class as well as Command.Run*
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.Clone">
            <summary>
            Return a copy an existing set of command options
            </summary>
            <returns>The copy of the command options</returns>
        </member>
        <member name="P:Utilities.CommandOptions.NoThrow">
            <summary>
            Normally commands will throw if the subprocess returns a non-zero 
            exit code.  NoThrow suppresses this. 
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddNoThrow">
            <summary>
            Updates the NoThrow propery and returns the updated commandOptions.
            <returns>Updated command options</returns>
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.Start">
            <summary>
            ShortHand for UseShellExecute and NoWait
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddStart">
            <summary>
            Updates the Start propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.UseShellExecute">
            <summary>
            Normally commands are launched with CreateProcess.  However it is
            also possible use the Shell Start API.  This causes Command to look
            up the executable differently 
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddUseShellExecute">
            <summary>
            Updates the Start propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.NoWindow">
            <summary>
            Indicates that you want to hide any new window created.  
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddNoWindow">
            <summary>
            Updates the NoWindow propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.NoWait">
            <summary>
            Indicates that you want don't want to wait for the command to complete.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddNoWait">
            <summary>
            Updates the NoWait propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.Elevate">
            <summary>
            Indicates that the command must run at elevated Windows privledges (causes a new command window)
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddElevate">
            <summary>
            Updates the Elevate propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.Timeout">
            <summary>
            By default commands have a 10 minute timeout (600,000 msec), If this
            is inappropriate, the Timeout property can change this.  Like all
            timouts in .NET, it is in units of milliseconds, and you can use
            CommandOptions.Infinite to indicate no timeout. 
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddTimeout(System.Int32)">
            <summary>
            Updates the Timeout propery and returns the updated commandOptions.
            CommandOptions.Infinite can be used for infinite
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.Input">
            <summary>
            Indicates the string will be sent to Console.In for the subprocess.  
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddInput(System.String)">
            <summary>
            Updates the Input propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.CurrentDirectory">
            <summary>
            Indicates the current directory the subProcess will have. 
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddCurrentDirectory(System.String)">
            <summary>
            Updates the CurrentDirectory propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.OutputFile">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a archiveFile rather than being stored in Memory in the 'Output' property of the
            command.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddOutputFile(System.String)">
            <summary>
            Updates the OutputFile propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.OutputStream">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a a TextWriter rather than being stored in Memory in the 'Output' property 
            of the command.
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddOutputStream(System.IO.TextWriter)">
            <summary>
            Updates the OutputStream property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Utilities.CommandOptions.EnvironmentVariables">
            <summary>
            Gets the Environment variables that will be set in the subprocess that
            differ from current process's environment variables.  Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath"
            </summary>
        </member>
        <member name="M:Utilities.CommandOptions.AddEnvironmentVariable(System.String,System.String)">
            <summary>
            Adds the environment variable with the give value to the set of 
            environmetn variables to be passed to the sub-process and returns the 
            updated commandOptions.   Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath"
            </summary>
        </member>
        <member name="T:Utilities.Command">
            <summary>
            Command represents a running of a command lineNumber process.  It is basically
            a wrapper over System.Diagnostics.Process, which hides the complexitity
            of System.Diagnostics.Process, and knows how to capture output and otherwise
            makes calling commands very easy.
            </summary>
        </member>
        <member name="P:Utilities.Command.StartTime">
            <summary>
            The time the process started.  
            </summary>
        </member>
        <member name="P:Utilities.Command.HasExited">
            <summary>
            Returns true if the process has exited. 
            </summary>
        </member>
        <member name="P:Utilities.Command.ExitTime">
            <summary>
            The time the processed Exited.  (HasExited should be true before calling)
            </summary>
        </member>
        <member name="P:Utilities.Command.Duration">
            <summary>
            The duration of the command (HasExited should be true before calling)
            </summary>
        </member>
        <member name="P:Utilities.Command.Id">
            <summary>
            The operating system ID for the subprocess.  
            </summary>
        </member>
        <member name="P:Utilities.Command.ExitCode">
            <summary>
            The process exit code for the subprocess.  (HasExited should be true before calling)
            Often this does not need to be checked because Command.Run will throw an exception 
            if it is not zero.   However it is useful if the CommandOptions.NoThrow property 
            was set.  
            </summary>
        </member>
        <member name="P:Utilities.Command.Output">
            <summary>
            The standard output and standard error output from the command.  This
            is accumulated in real time so it can vary if the process is still running.
            
            This property is NOT available if the CommandOptions.OutputFile or CommandOptions.OutputStream
            is specified since the output is being redirected there.   If a large amount of output is 
            expected (> 1Meg), the Run.AddOutputStream(Stream) is recommended for retrieving it since
            the large string is never materialized at one time. 
            </summary>
        </member>
        <member name="P:Utilities.Command.Options">
            <summary>
            Returns that CommandOptions structure that holds all the options that affect
            the running of the command (like Timeout, Input ...)
            </summary>
        </member>
        <member name="M:Utilities.Command.RunToConsole(System.String,Utilities.CommandOptions)">
            <summary>
            Run 'commandLine', sending the output to the console, and wait for the command to complete.
            This simulates what batch filedo when executing their commands.  It is a bit more verbose
            by default, however 
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Utilities.Command.Run(System.String,Utilities.CommandOptions)">
            <summary>
            Run 'commandLine' as a subprocess and waits for the command to complete.
            Output is captured and placed in the 'Output' property of the returned Command 
            structure. 
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Utilities.Command.#ctor(System.String,Utilities.CommandOptions)">
            <summary>
            Launch a new command and returns the Command object that can be used to monitor
            the restult.  It does not wait for the command to complete, however you 
            can call 'Wait' to do that, or use the 'Run' or 'RunToConsole' methods. */
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Utilities.Command.#ctor(System.String)">
            <summary>
            Create a subprocess to run 'commandLine' with no special options. 
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            </summary>
        </member>
        <member name="M:Utilities.Command.Wait">
            <summary>
            Wait for a started process to complete (HasExited will be true on return)
            </summary>
            <returns>Wait returns that 'this' pointer.</returns>
        </member>
        <member name="M:Utilities.Command.ThrowCommandFailure(System.String)">
            <summary>
            Throw a error if the command exited with a non-zero exit code
            printing useful diagnostic information along with the thrown message.
            This is useful when NoThrow is specified, and after post-processing
            you determine that the command really did fail, and an normal 
            Command.Run failure was the appropriate action.  
            </summary>
            <param name="message">An additional message to print in the throw (can be null)</param>
        </member>
        <member name="P:Utilities.Command.Process">
            <summary>
            Get the underlying process object.  Generally not used. 
            </summary>
        </member>
        <member name="M:Utilities.Command.Kill">
            <summary>
            Kill the process (and any child processses (recursively) associated with the 
            running command).   Note that it may not be able to kill everything it should
            if the child-parent' chain is broken by a child that creates a subprocess and
            then dies itself.   This is reasonably uncommon, however. 
            </summary>
        </member>
        <member name="M:Utilities.Command.Quote(System.String)">
            <summary>
            Put double quotes around 'str' if necessary (handles quotes quotes.  
            </summary>
        </member>
        <member name="M:Utilities.Command.FindOnPath(System.String)">
            <summary>
            Given a string 'commandExe' look for it on the path the way cmd.exe would.   
            Returns null if it was not found.   
            </summary>
        </member>
        <member name="T:Utilities.OperatingSystemVersion.RTL_OSVERSIONINFOEX">
            <summary>
            requiredOSVersion is a number that is the major version * 10 + minor.  Thus
                Win 10 == 100
                Win 8 == 62
                Win 7 == 61
                Vista == 60
            This returns true if true OS version is >= 'requiredOSVersion
            </summary>
        </member>
        <member name="T:Dia2Lib.DiaLoader">
            <summary>
            The DiaLoader class knows how to load the msdia140.dll (the Debug Access Interface) (see docs at
            http://msdn.microsoft.com/en-us/library/x93ctkx8.aspx), without it being registered as a COM object.
            Basically it just called the DllGetClassObject interface directly.
            
            It has one public method 'GetDiaSourceObject' which knows how to create a IDiaDataSource object. 
            From there you can do anything you need.  
            
            In order to get IDiaDataSource3 which includes'getStreamSize' API, you need to use the 
            vctools\langapi\idl\dia2_internal.idl file from devdiv to produce Dia2Lib.dll
            
            roughly what you need to do is 
                copy vctools\langapi\idl\dia2_internal.idl .
                copy vctools\langapi\idl\dia2.idl .
                copy vctools\langapi\include\cvconst.h .
                Change dia2.idl to include interface IDiaDataSource3 inside library Dia2Lib->importlib->coclass DiaSource
                midl dia2_internal.idl /D CC_DP_CXX
                tlbimp dia2_internal.tlb
                REM result is Dia2Lib.dll 
            </summary>
        </member>
        <member name="M:Dia2Lib.DiaLoader.GetDiaSourceObject">
            <summary>
            Load the msdia100 dll and get a IDiaDataSource from it.  This is your gateway to PDB reading.   
            </summary>
        </member>
        <member name="F:Dia2Lib.DiaLoader.s_loadedNativeDll">
            <summary>
            Used to ensure the native library is loaded at least once prior to trying to use it. No protection is
            included to avoid multiple loads, but this is not a problem since we aren't trying to unload the library
            after use.
            </summary>
        </member>
        <member name="T:PEFile.PEFile">
            <summary>
            PEFile is a reader for the information in a Portable Exectable (PE) FILE.   This is what EXEs and DLLs are.  
            
            It can read both 32 and 64 bit PE files.  
            </summary>
        </member>
        <member name="M:PEFile.PEFile.#ctor(System.String)">
            <summary>
            Create a new PEFile header reader that inspects the 
            </summary>
        </member>
        <member name="P:PEFile.PEFile.Header">
            <summary>
            The Header for the PE file.  This contains the infor in a link /dump /headers 
            </summary>
        </member>
        <member name="M:PEFile.PEFile.GetPdbSignature(System.String@,System.Guid@,System.Int32@,System.Boolean)">
            <summary>
            Looks up the debug signature information in the EXE.   Returns true and sets the parameters if it is found. 
            
            If 'first' is true then the first entry is returned, otherwise (by default) the last entry is used 
            (this is what debuggers do today).   Thus NGEN images put the IL PDB last (which means debuggers 
            pick up that one), but we can set it to 'first' if we want the NGEN PDB.
            </summary>
        </member>
        <member name="M:PEFile.PEFile.GetFileVersionInfo">
            <summary>
            Gets the File Version Information that is stored as a resource in the PE file.  (This is what the
            version tab a file's property page is populated with).  
            </summary>
        </member>
        <member name="M:PEFile.PEFile.GetSxSManfest">
            <summary>
            For side by side dlls, the manifest that describes the binding information is stored as the RT_MANIFEST resource, and it
            is an XML string.   This routine returns this.  
            </summary>
            <returns></returns>
        </member>
        <member name="P:PEFile.PEFile.HasPrecompiledManagedCode">
            <summary>
            Returns true if this is and NGEN or Ready-to-Run image (it has precompiled native code)
            </summary>
        </member>
        <member name="P:PEFile.PEFile.IsManagedReadyToRun">
            <summary>
            Returns true if file has a managed ready-to-run image.  
            </summary>
        </member>
        <member name="M:PEFile.PEFile.ReadyToRunVersion(System.Int16@,System.Int16@)">
            <summary>
            Gets the major and minor ready-to-run version.   returns true if ready-to-run. 
            </summary>
        </member>
        <member name="M:PEFile.PEFile.Dispose">
            <summary>
            Closes any file handles and cleans up resources.  
            </summary>
        </member>
        <member name="T:PEFile.PEHeader">
            <summary>
            A PEHeader is a reader of the data at the beginning of a PEFile.    If the header bytes of a 
            PEFile are read or mapped into memory, this class can parse it when given a poitner to it. 
            It can read both 32 and 64 bit PE files.  
            </summary>
        </member>
        <member name="M:PEFile.PEHeader.#ctor(System.Void*)">
            <summary>
            Returns a PEHeader for void* pointer in memory.  It does NO validity checking. 
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.PEHeaderSize">
            <summary>
            The total s,ize of the header,  including section array of the the PE header.  
            </summary>
        </member>
        <member name="M:PEFile.PEHeader.VirtualAddressToRva(System.Void*)">
            <summary>
            Given a virtual address to data in a mapped PE file, return the relative virtual address (displacement from start of the image)
            </summary>
        </member>
        <member name="M:PEFile.PEHeader.RvaToVirtualAddress(System.Int32)">
            <summary>
            Given a relative virtual address (displacement from start of the image) return the virtual address to data in a mapped PE file
            </summary>
        </member>
        <member name="M:PEFile.PEHeader.RvaToFileOffset(System.Int32)">
            <summary>
            Given a relative virtual address (displacement from start of the image) return a offset in the file data for that data.  
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.IsPE64">
            <summary>
            Returns true if this is PE file for a 64 bit architecture.  
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.IsManaged">
            <summary>
            Returns true if this file contains managed code (might also contain native code). 
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.Signature">
            <summary>   
            Returns the 'Signature' of the PE HEader PE\0\0 = 0x4550, used for sanity checking.  
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.Machine">
            <summary>
            The machine this PE file is intended to run on 
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.NumberOfSections">
            <summary>
            PE files have a number of sections that represent regions of memory with the access permisions.  This is the nubmer of such sections.  
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.TimeDateStampSec">
            <summary>
            The the PE file was created represented as the number of seconds since Jan 1 1970 
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.TimeDateStamp">
            <summary>
            The the PE file was created represented as a DateTime object
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.PointerToSymbolTable">
            <summary>
            PointerToSymbolTable (see IMAGE_FILE_HEADER in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.NumberOfSymbols">
            <summary>
            NumberOfSymbols (see IMAGE_FILE_HEADER PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfOptionalHeader">
            <summary>
            SizeOfOptionalHeader (see IMAGE_FILE_HEADER PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.Characteristics">
            <summary>
            Characteristics (see IMAGE_FILE_HEADER PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.Magic">
            <summary>
            Magic (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MajorLinkerVersion">
            <summary>
            MajorLinkerVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MinorLinkerVersion">
            <summary>
            MinorLinkerVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfCode">
            <summary>
            SizeOfCode (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfInitializedData">
            <summary>
            SizeOfInitializedData (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfUninitializedData">
            <summary>
            SizeOfUninitializedData (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.AddressOfEntryPoint">
            <summary>
            AddressOfEntryPoint (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.BaseOfCode">
            <summary>
            BaseOfCode (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ImageBase">
            <summary>
            ImageBase (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SectionAlignment">
            <summary>
            SectionAlignment (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.FileAlignment">
            <summary>
            FileAlignment (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MajorOperatingSystemVersion">
            <summary>
            MajorOperatingSystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MinorOperatingSystemVersion">
            <summary>
            MinorOperatingSystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MajorImageVersion">
            <summary>
            MajorImageVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MinorImageVersion">
            <summary>
            MinorImageVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MajorSubsystemVersion">
            <summary>
            MajorSubsystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.MinorSubsystemVersion">
            <summary>
            MinorSubsystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.Win32VersionValue">
            <summary>
            Win32VersionValue (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfImage">
            <summary>
            SizeOfImage (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfHeaders">
            <summary>
            SizeOfHeaders (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.CheckSum">
            <summary>
            CheckSum (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.Subsystem">
            <summary>
            Subsystem (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.DllCharacteristics">
            <summary>
            DllCharacteristics (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfStackReserve">
            <summary>
            SizeOfStackReserve (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfStackCommit">
            <summary>
            SizeOfStackCommit (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfHeapReserve">
            <summary>
            SizeOfHeapReserve (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.SizeOfHeapCommit">
            <summary>
            SizeOfHeapCommit (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.LoaderFlags">
            <summary>
            LoaderFlags (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.NumberOfRvaAndSizes">
            <summary>
            NumberOfRvaAndSizes (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="M:PEFile.PEHeader.Directory(System.Int32)">
            <summary>
            Returns the data directory (virtual address an blob, of a data directory with index 'idx'.   14 are currently defined.
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ExportDirectory">
            <summary>
            Returns the data directory for DLL Exports see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ImportDirectory">
            <summary>
            Returns the data directory for DLL Imports see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ResourceDirectory">
            <summary>
            Returns the data directory for DLL Resources see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ExceptionDirectory">
            <summary>
            Returns the data directory for DLL Exceptions see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.CertificatesDirectory">
            <summary>
            Returns the data directory for DLL securiy certificates (Authenticode) see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.BaseRelocationDirectory">
            <summary>
            Returns the data directory Image Base Relocations (RELOCS) see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.DebugDirectory">
            <summary>
            Returns the data directory for Debug information see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ArchitectureDirectory">
            <summary>
            Returns the data directory for DLL Exports see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.GlobalPointerDirectory">
            <summary>
            Returns the data directory for GlobalPointer (IA64) see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ThreadStorageDirectory">
            <summary>
            Returns the data directory for THread local storage see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.LoadConfigurationDirectory">
            <summary>
            Returns the data directory for Load Configuration see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.BoundImportDirectory">
            <summary>
            Returns the data directory for Bound Imports see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ImportAddressTableDirectory">
            <summary>
            Returns the data directory for the DLL Import Address Table (IAT) see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.DelayImportDirectory">
            <summary>
            Returns the data directory for Delayed Imports see PE file spec for more
            </summary>
        </member>
        <member name="P:PEFile.PEHeader.ComDescriptorDirectory">
            <summary>
             see PE file spec for more .NET Runtime infomration.  
            </summary>
        </member>
        <member name="T:PEFile.MachineType">
            <summary>
            The Machine types supported by the portable executable (PE) File format
            </summary>
        </member>
        <member name="F:PEFile.MachineType.Native">
            <summary>
            Unknown machine type
            </summary>
        </member>
        <member name="F:PEFile.MachineType.X86">
            <summary>
            Intel X86 CPU 
            </summary>
        </member>
        <member name="F:PEFile.MachineType.ia64">
            <summary>
            Intel IA64 
            </summary>
        </member>
        <member name="F:PEFile.MachineType.ARM">
            <summary>
            ARM 32 bit 
            </summary>
        </member>
        <member name="F:PEFile.MachineType.Amd64">
            <summary>
            Arm 64 bit 
            </summary>
        </member>
        <member name="T:PEFile.IMAGE_DATA_DIRECTORY">
            <summary>
            Represents a Portable Executable (PE) Data directory.  This is just a well known optional 'Blob' of memory (has a starting point and size)
            </summary>
        </member>
        <member name="F:PEFile.IMAGE_DATA_DIRECTORY.VirtualAddress">
            <summary>
            The start of the data blob when the file is mapped into memory
            </summary>
        </member>
        <member name="F:PEFile.IMAGE_DATA_DIRECTORY.Size">
            <summary>
            The length of the data blob.  
            </summary>
        </member>
        <member name="T:PEFile.FileVersionInfo">
            <summary>
            FileVersionInfo represents the extended version formation that is optionally placed in the PE file resource area. 
            </summary>
        </member>
        <member name="P:PEFile.FileVersionInfo.FileVersion">
            <summary>
            The version string 
            </summary>
        </member>
        <member name="T:PEFile.PEBuffer">
            <summary>
            A PEBuffer represents a buffer (efficient) scanner of the 
            </summary>
        </member>
    </members>
</doc>
